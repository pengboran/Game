var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(a) {
	return document.createElement(a)
};
cc._addEventListener = function(a, c, b, d) {
	a.addEventListener(c, b, d)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(a, c, b) {
	if(a)
		if(a instanceof Array)
			for(var d = 0, e = a.length; d < e && !1 !== c.call(b, a[d], d); d++);
		else
			for(d in a)
				if(!1 === c.call(b, a[d], d)) break
};
cc.extend = function(a) {
	var c = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
	cc.each(c, function(c) {
		for(var d in c) c.hasOwnProperty(d) && (a[d] = c[d])
	});
	return a
};
cc.isFunction = function(a) {
	return "function" === typeof a
};
cc.isNumber = function(a) {
	return "number" === typeof a || "[object Number]" === Object.prototype.toString.call(a)
};
cc.isString = function(a) {
	return "string" === typeof a || "[object String]" === Object.prototype.toString.call(a)
};
cc.isArray = function(a) {
	return Array.isArray(a) || "object" === typeof a && "[object Array]" === Object.prototype.toString.call(a)
};
cc.isUndefined = function(a) {
	return "undefined" === typeof a
};
cc.isObject = function(a) {
	return "object" === typeof a && "[object Object]" === Object.prototype.toString.call(a)
};
cc.isCrossOrigin = function(a) {
	if(!a) return cc.log("invalid URL"), !1;
	var c = a.indexOf("://");
	if(-1 === c) return !1;
	c = a.indexOf("/", c + 3);
	return(-1 === c ? a : a.substring(0, c)) !== location.origin
};
cc.AsyncPool = function(a, c, b, d, e) {
	var f = this;
	f._srcObj = a;
	f._limit = c;
	f._pool = [];
	f._iterator = b;
	f._iteratorTarget = e;
	f._onEnd = d;
	f._onEndTarget = e;
	f._results = a instanceof Array ? [] : {};
	f._isErr = !1;
	cc.each(a, function(a, c) {
		f._pool.push({
			index: c,
			value: a
		})
	});
	f.size = f._pool.length;
	f.finishedSize = 0;
	f._workingSize = 0;
	f._limit = f._limit || f.size;
	f.onIterator = function(a, c) {
		f._iterator = a;
		f._iteratorTarget = c
	};
	f.onEnd = function(a, c) {
		f._onEnd = a;
		f._onEndTarget = c
	};
	f._handleItem = function() {
		var a = this;
		if(!(0 === a._pool.length ||
				a._workingSize >= a._limit)) {
			var c = a._pool.shift(),
				b = c.value,
				d = c.index;
			a._workingSize++;
			a._iterator.call(a._iteratorTarget, b, d, function(c) {
				if(!a._isErr)
					if(a.finishedSize++, a._workingSize--, c) a._isErr = !0, a._onEnd && a._onEnd.call(a._onEndTarget, c);
					else {
						var b = Array.prototype.slice.call(arguments, 1);
						a._results[this.index] = b[0];
						a.finishedSize === a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
					}
			}.bind(c), a)
		}
	};
	f.flow = function() {
		if(0 === this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget,
			null, []);
		else
			for(var a = 0; a < this._limit; a++) this._handleItem()
	}
};
cc.async = {
	series: function(a, c, b) {
		a = new cc.AsyncPool(a, 1, function(a, c, f) {
			a.call(b, f)
		}, c, b);
		a.flow();
		return a
	},
	parallel: function(a, c, b) {
		a = new cc.AsyncPool(a, 0, function(a, c, f) {
			a.call(b, f)
		}, c, b);
		a.flow();
		return a
	},
	waterfall: function(a, c, b) {
		var d = [],
			e = [null],
			f = new cc.AsyncPool(a, 1, function(c, f, k) {
				d.push(function(c) {
					d = Array.prototype.slice.call(arguments, 1);
					a.length - 1 === f && (e = e.concat(d));
					k.apply(null, arguments)
				});
				c.apply(b, d)
			}, function(a) {
				if(c) {
					if(a) return c.call(b, a);
					c.apply(b, e)
				}
			});
		f.flow();
		return f
	},
	map: function(a, c, b, d) {
		var e = c;
		"object" === typeof c && (b = c.cb, d = c.iteratorTarget, e = c.iterator);
		a = new cc.AsyncPool(a, 0, e, b, d);
		a.flow();
		return a
	},
	mapLimit: function(a, c, b, d, e) {
		a = new cc.AsyncPool(a, c, b, d, e);
		a.flow();
		return a
	}
};
cc.path = {
	join: function() {
		for(var a = arguments.length, c = "", b = 0; b < a; b++) c = (c + ("" === c ? "" : "/") + arguments[b]).replace(/(\/|\\\\)$/, "");
		"undefined" != typeof g_version && (c += (0 > c.indexOf("?") ? "?" : "\x26") + "t\x3d" + g_version);
		return c
	},
	extname: function(a) {
		return 0 <= a.indexOf("file_type\x3d") ? (a = /[\?\&]file_type=([^\&]+)/i.exec(a)) ? "." + a[1] : null : (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
	},
	mainFileName: function(a) {
		if(a) {
			var c = a.lastIndexOf(".");
			if(-1 !== c) return a.substring(0, c)
		}
		return a
	},
	basename: function(a,
		c) {
		var b = a.indexOf("?");
		0 < b && (a = a.substring(0, b));
		b = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
		if(!b) return null;
		b = b[2];
		return c && a.substring(a.length - c.length).toLowerCase() === c.toLowerCase() ? b.substring(0, b.length - c.length) : b
	},
	dirname: function(a) {
		return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
	},
	changeExtname: function(a, c) {
		c = c || "";
		var b = a.indexOf("?"),
			d = "";
		0 < b && (d = a.substring(b), a = a.substring(0, b));
		b = a.lastIndexOf(".");
		return 0 > b ? a + c + d : a.substring(0, b) + c + d
	},
	changeBasename: function(a,
		c, b, d) {
		if(0 === c.indexOf(".")) return this.changeExtname(a, c);
		var e;
		d || (e = a.indexOf("?"));
		d = "";
		b = b ? this.extname(a) : "";
		0 < e && (d = a.substring(e), a = a.substring(0, e));
		e = a.lastIndexOf("/");
		return a.substring(0, 0 >= e ? 0 : e + 1) + c + b + d
	}
};
cc.loader = {
	_jsCache: {},
	_register: {},
	_langPathCache: {},
	_aliases: {},
	resPath: "",
	audioPath: "",
	cache: {},
	getXMLHttpRequest: function(a) {
		return a ? new window.XDomainRequest : window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
	},
	_getArgs4Js: function(a) {
		var c = a[0],
			b = a[1],
			d = a[2],
			e = ["", null, null];
		if(1 === a.length) e[1] = c instanceof Array ? c : [c];
		else if(2 === a.length) "function" === typeof b ? (e[1] = c instanceof Array ? c : [c], e[2] = b) : (e[0] = c || "", e[1] = b instanceof Array ? b : [b]);
		else if(3 === a.length) e[0] =
			c || "", e[1] = b instanceof Array ? b : [b], e[2] = d;
		else throw "arguments error to load js!";
		return e
	},
	loadJs: function(a, c, b) {
		var d = this,
			e = d._jsCache,
			f = d._getArgs4Js(arguments),
			g = f[0],
			h = f[1],
			f = f[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? d._loadJs4Dependency(g, h, 0, f) : cc.async.map(h, function(a, c, b) {
			a = cc.path.join(g, a);
			if(e[a]) return b(null);
			d._createScript(a, !1, b)
		}, f)
	},
	loadJsWithImg: function(a, c, b) {
		var d = this._loadJsImg(),
			e = this._getArgs4Js(arguments);
		this.loadJs(e[0], e[1], function(a) {
			if(a) throw a;
			d.parentNode.removeChild(d);
			if(e[2]) e[2]()
		})
	},
	_createScript: function(a, c, b) {
		var d = document,
			e = cc.newElement("script");
		e.async = c;
		this._jsCache[a] = !0;
		cc.game.config.noCache && "string" === typeof a ? this._noCacheRex.test(a) ? e.src = a + "\x26_t\x3d" + (new Date - 0) : e.src = a + "?_t\x3d" + (new Date - 0) : e.src = a;
		cc._addEventListener(e, "load", function() {
			e.parentNode.removeChild(e);
			this.removeEventListener("load", arguments.callee, !1);
			b()
		}, !1);
		cc._addEventListener(e, "error", function() {
			e.parentNode.removeChild(e);
			b("Load " + a + " failed!")
		}, !1);
		d.body.appendChild(e)
	},
	_loadJs4Dependency: function(a, c, b, d) {
		if(b >= c.length) d && d();
		else {
			var e = this;
			e._createScript(cc.path.join(a, c[b]), !1, function(f) {
				if(f) return d(f);
				e._loadJs4Dependency(a, c, b + 1, d)
			})
		}
	},
	_loadJsImg: function() {
		var a = document,
			c = a.getElementById("cocos2d_loadJsImg");
		if(!c) {
			c = cc.newElement("img");
			cc._loadingImage && (c.src = cc._loadingImage);
			a = a.getElementById(cc.game.config.id);
			a.style.backgroundColor = "black";
			a.parentNode.appendChild(c);
			var b = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
			b || (b = {
				width: a.width,
				height: a.height
			});
			c.style.left = a.offsetLeft + (parseFloat(b.width) - c.width) / 2 + "px";
			c.style.top = a.offsetTop + (parseFloat(b.height) - c.height) / 2 + "px";
			c.style.position = "absolute"
		}
		return c
	},
	loadTxt: function(a, c) {
		if(cc._isNodeJs) require("fs").readFile(a, function(a, b) {
			a ? c(a) : c(null, b.toString())
		});
		else {
			var b = !1;
			cc.sys.isIE9 && (0 == a.indexOf("http") || 0 == a.indexOf("//")) && 0 > a.indexOf(location.host) && (b = !0);
			var d = this.getXMLHttpRequest(b),
				e = "load " + a + " failed!";
			d.open("GET", a, !0);
			/msie/i.test(navigator.userAgent) &&
				!/opera/i.test(navigator.userAgent) ? b ? d.onload = function() {
					d.responseText && c(null, d.responseText)
				} : d.onreadystatechange = function() {
					4 === d.readyState && (200 === d.status ? c(null, d.responseText) : c(e))
				} : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dutf-8"), d.onload = function() {
					4 === d.readyState && (200 === d.status ? c(null, d.responseText) : c(e))
				});
			d.send(null)
		}
	},
	_loadTxtSync: function(a) {
		if(cc._isNodeJs) return require("fs").readFileSync(a).toString();
		var c = this.getXMLHttpRequest();
		c.open("GET", a, !1);
		/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? c.setRequestHeader("Accept-Charset", "utf-8") : c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8");
		c.send(null);
		return 4 === !c.readyState || 200 !== c.status ? null : c.responseText
	},
	loadCsb: function(a, c) {
		var b = new XMLHttpRequest;
		b.open("GET", a, !0);
		b.responseType = "arraybuffer";
		b.onload = function() {
			var d = b.response;
			d && (window.msg = d);
			4 === b.readyState && (200 === b.status ? c(null, b.response) : c("load " + a + " failed!"))
		};
		b.send(null)
	},
	loadJson: function(a, c) {
		this.loadTxt(a, function(b, d) {
			if(b) c(b);
			else {
				try {
					var e = JSON.parse(d)
				} catch(f) {
					throw "parse json [" + a + "] failed : " + f;
				}
				c(null, e)
			}
		})
	},
	_checkIsImageURL: function(a) {
		return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
	},
	loadImg: function(a, c, b) {
		var d = {
			isCrossOrigin: !0
		};
		void 0 !== b ? d.isCrossOrigin = null === c.isCrossOrigin ? d.isCrossOrigin : c.isCrossOrigin : void 0 !== c && (b = c);
		var e = this.getRes(a);
		if(e) return b && b(null, e), e;
		e = new Image;
		d.isCrossOrigin && "file://" !== location.origin &&
			(e.crossOrigin = "Anonymous");
		var f = function() {
				this.removeEventListener("load", f, !1);
				this.removeEventListener("error", h, !1);
				b && b(null, e)
			},
			g = this,
			h = function() {
				this.removeEventListener("error", h, !1);
				e.crossOrigin && "anonymous" === e.crossOrigin.toLowerCase() ? (d.isCrossOrigin = !1, g.release(a), cc.loader.loadImg(a, d, b)) : "function" === typeof b && b("load image failed")
			};
		cc._addEventListener(e, "load", f);
		cc._addEventListener(e, "error", h);
		e.src = a;
		return e
	},
	_loadResIterator: function(a, c, b) {
		var d = this,
			e = null,
			f = a.type;
		f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e));
		if(c = d.getRes(e)) return b(null, c);
		c = null;
		f && (c = d._register[f.toLowerCase()]);
		if(!c) return cc.error("loader for [" + f + "] not exists!"), b();
		f = e;
		cc._urlRegExp.test(e) || (f = c.getBasePath ? c.getBasePath() : d.resPath, f = d.getUrl(f, e));
		cc.game.config.noCache && "string" === typeof f && (f = d._noCacheRex.test(f) ? f + ("\x26_t\x3d" + (new Date - 0)) : f + ("?_t\x3d" + (new Date - 0)));
		c.load(f, e, a, function(a, c) {
			a ? (cc.log(a), d.cache[e] = null, delete d.cache[e],
				b()) : (d.cache[e] = c, b(null, c))
		})
	},
	_noCacheRex: /\?/,
	getUrl: function(a, c) {
		var b = this._langPathCache,
			d = cc.path;
		if(void 0 !== a && void 0 === c) {
			c = a;
			var e = d.extname(c),
				e = e ? e.toLowerCase() : "";
			a = (e = this._register[e]) ? e.getBasePath ? e.getBasePath() : this.resPath : this.resPath
		}
		c = cc.path.join(a || "", c);
		if(c.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
			if(b[c]) return b[c];
			d = d.extname(c) || "";
			c = b[c] = c.substring(0, c.length - d.length) + "_" + cc.sys.language + d
		}
		return c
	},
	load: function(a, c, b) {
		var d = this,
			e = arguments.length;
		if(0 === e) throw "arguments error!";
		3 === e ? "function" === typeof c && (c = "function" === typeof b ? {
			trigger: c,
			cb: b
		} : {
			cb: c,
			cbTarget: b
		}) : 2 === e ? "function" === typeof c && (c = {
			cb: c
		}) : 1 === e && (c = {});
		a instanceof Array || (a = [a]);
		e = new cc.AsyncPool(a, 0, function(a, b, e, k) {
			d._loadResIterator(a, b, function(a) {
				if(a) return e(a);
				var b = Array.prototype.slice.call(arguments, 1);
				c.trigger && c.trigger.call(c.triggerTarget, b[0], k.size, k.finishedSize);
				e(null, b[0])
			})
		}, c.cb, c.cbTarget);
		e.flow();
		return e
	},
	_handleAliases: function(a, c) {
		var b = this._aliases,
			d = [],
			e;
		for(e in a) {
			var f =
				a[e];
			b[e] = f;
			d.push(f)
		}
		this.load(d, c)
	},
	loadAliases: function(a, c) {
		var b = this,
			d = b.getRes(a);
		d ? b._handleAliases(d.filenames, c) : b.load(a, function(a, d) {
			b._handleAliases(d[0].filenames, c)
		})
	},
	register: function(a, c) {
		if(a && c) {
			if("string" === typeof a) return this._register[a.trim().toLowerCase()] = c;
			for(var b = 0, d = a.length; b < d; b++) this._register["." + a[b].trim().toLowerCase()] = c
		}
	},
	getRes: function(a) {
		return this.cache[a] || this.cache[this._aliases[a]]
	},
	release: function(a) {
		var c = this.cache,
			b = this._aliases;
		delete c[a];
		delete c[b[a]];
		delete b[a]
	},
	releaseAll: function() {
		var a = this.cache,
			c = this._aliases,
			b;
		for(b in a) delete a[b];
		for(b in c) delete c[b]
	}
};
cc.formatStr = function() {
	var a = arguments,
		c = a.length;
	if(1 > c) return "";
	var b = a[0],
		d = !0;
	"object" === typeof b && (d = !1);
	for(var e = 1; e < c; ++e) {
		var f = a[e];
		if(d)
			for(;;) {
				var g = null;
				if("number" === typeof f && (g = b.match(/(%d)|(%s)/))) {
					b = b.replace(/(%d)|(%s)/, f);
					break
				}
				b = (g = b.match(/%s/)) ? b.replace(/%s/, f) : b + ("    " + f);
				break
			} else b += "    " + f
	}
	return b
};
(function() {
	var a = window,
		c, b;
	cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (c = "webkitHidden", b = "webkitvisibilitychange") : (c = "msHidden", b = "msvisibilitychange") : (c = "mozHidden", b = "mozvisibilitychange") : (c = "hidden", b = "visibilitychange");
	var d = function() {
			cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
		},
		e = function() {
			cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
			cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
		};
	c && cc._addEventListener(document, b, function() {
		document[c] ? d() : e()
	}, !1);
	cc._addEventListener(a, "blur", d, !1);
	cc._addEventListener(a, "focus", e, !1); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function() {
		e()
	});
	"onpageshow" in window && "onpagehide" in window && (cc._addEventListener(a, "pagehide", d, !1), cc._addEventListener(a, "pageshow", e, !1));
	b = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(a, c) {
	for(var b = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < b.length; ++e) {
		try {
			d = a.getContext(b[e], c)
		} catch(f) {}
		if(d) break
	}
	return d
};
cc._initSys = function(a, c) {
	cc._RENDER_TYPE_CANVAS = 0;
	cc._RENDER_TYPE_WEBGL = 1;
	cc.sys = {};
	var b = cc.sys;
	b.LANGUAGE_ENGLISH = "en";
	b.LANGUAGE_CHINESE = "zh";
	b.LANGUAGE_FRENCH = "fr";
	b.LANGUAGE_ITALIAN = "it";
	b.LANGUAGE_GERMAN = "de";
	b.LANGUAGE_SPANISH = "es";
	b.LANGUAGE_DUTCH = "du";
	b.LANGUAGE_RUSSIAN = "ru";
	b.LANGUAGE_KOREAN = "ko";
	b.LANGUAGE_JAPANESE = "ja";
	b.LANGUAGE_HUNGARIAN = "hu";
	b.LANGUAGE_PORTUGUESE = "pt";
	b.LANGUAGE_ARABIC = "ar";
	b.LANGUAGE_NORWEGIAN = "no";
	b.LANGUAGE_POLISH = "pl";
	b.OS_IOS = "iOS";
	b.OS_ANDROID = "Android";
	b.OS_WINDOWS =
		"Windows";
	b.OS_MARMALADE = "Marmalade";
	b.OS_LINUX = "Linux";
	b.OS_BADA = "Bada";
	b.OS_BLACKBERRY = "Blackberry";
	b.OS_OSX = "OS X";
	b.OS_WP8 = "WP8";
	b.OS_WINRT = "WINRT";
	b.OS_UNKNOWN = "Unknown";
	b.UNKNOWN = -1;
	b.WIN32 = 0;
	b.LINUX = 1;
	b.MACOS = 2;
	b.ANDROID = 3;
	b.IPHONE = 4;
	b.IPAD = 5;
	b.BLACKBERRY = 6;
	b.NACL = 7;
	b.EMSCRIPTEN = 8;
	b.TIZEN = 9;
	b.WINRT = 10;
	b.WP8 = 11;
	b.MOBILE_BROWSER = 100;
	b.DESKTOP_BROWSER = 101;
	b.BROWSER_TYPE_WECHAT = "wechat";
	b.BROWSER_TYPE_ANDROID = "androidbrowser";
	b.BROWSER_TYPE_IE = "ie";
	b.BROWSER_TYPE_QQ = "qqbrowser";
	b.BROWSER_TYPE_MOBILE_QQ =
		"mqqbrowser";
	b.BROWSER_TYPE_UC = "ucbrowser";
	b.BROWSER_TYPE_360 = "360browser";
	b.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
	b.BROWSER_TYPE_BAIDU = "baidubrowser";
	b.BROWSER_TYPE_MAXTHON = "maxthon";
	b.BROWSER_TYPE_OPERA = "opera";
	b.BROWSER_TYPE_OUPENG = "oupeng";
	b.BROWSER_TYPE_MIUI = "miuibrowser";
	b.BROWSER_TYPE_FIREFOX = "firefox";
	b.BROWSER_TYPE_SAFARI = "safari";
	b.BROWSER_TYPE_CHROME = "chrome";
	b.BROWSER_TYPE_LIEBAO = "liebao";
	b.BROWSER_TYPE_QZONE = "qzone";
	b.BROWSER_TYPE_SOUGOU = "sogou";
	b.BROWSER_TYPE_UNKNOWN = "unknown";
	b.isNative = !1;
	var d = window,
		e = d.navigator,
		f = document,
		g = f.documentElement,
		h = e.userAgent.toLowerCase();
	b.isIE9 = 0 <= h.indexOf("msie 9") || 0 <= h.indexOf("msie 8") || 0 <= h.indexOf("msie 7");
	b.isMobile = -1 !== h.indexOf("mobile") || -1 !== h.indexOf("android");
	b.isMobile = !1;
	b.platform = b.isMobile ? b.MOBILE_BROWSER : b.DESKTOP_BROWSER;
	var k = e.language,
		k = (k = k ? k : e.browserLanguage) ? k.split("-")[0] : b.LANGUAGE_ENGLISH;
	b.language = k;
	var k = b.BROWSER_TYPE_UNKNOWN,
		m = h.match(/sogou|qzone|liebao|micromessenger|qqbrowser|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) ||
		h.match(/chrome|safari/i);
	m && 0 < m.length ? (k = m[0], "micromessenger" === k ? k = b.BROWSER_TYPE_WECHAT : "safari" === k && h.match(/android.*applewebkit/) ? k = b.BROWSER_TYPE_ANDROID : "trident" === k ? k = b.BROWSER_TYPE_IE : "360 aphone" === k && (k = b.BROWSER_TYPE_360)) : h.indexOf("iphone") && h.indexOf("mobile") && (k = "safari");
	b.browserType = k;
	k = h.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
	h = h.match(/android/i) || e.platform.match(/android/i) ? !0 : !1;
	m = b.OS_UNKNOWN; - 1 !== e.appVersion.indexOf("Win") ? m = b.OS_WINDOWS : k ? m = b.OS_IOS : -1 !== e.appVersion.indexOf("Mac") ?
		m = b.OS_OSX : -1 !== e.appVersion.indexOf("X11") && -1 === e.appVersion.indexOf("Linux") ? m = b.OS_UNIX : h ? m = b.OS_ANDROID : -1 !== e.appVersion.indexOf("Linux") && (m = b.OS_LINUX);
	b.os = m;
	b._supportMultipleAudio = -1 < [b.BROWSER_TYPE_BAIDU, b.BROWSER_TYPE_OPERA, b.BROWSER_TYPE_FIREFOX, b.BROWSER_TYPE_CHROME, b.BROWSER_TYPE_BAIDU_APP, b.BROWSER_TYPE_SAFARI, b.BROWSER_TYPE_UC, b.BROWSER_TYPE_QQ, b.BROWSER_TYPE_MOBILE_QQ, b.BROWSER_TYPE_IE].indexOf(b.browserType);
	(function(a, b) {
		var e = b[c.renderMode] - 0;
		if(isNaN(e) || 2 < e || 0 > e) e = 0;
		var f = [a.OS_ANDROID],
			g = [],
			h = cc.newElement("canvas");
		cc._renderType = cc._RENDER_TYPE_CANVAS;
		cc._supportRender = !1;
		var m = d.WebGLRenderingContext;
		if(2 === e || 0 === e && m && -1 === f.indexOf(a.os) && -1 === g.indexOf(a.browserType)) try {
			cc.create3DContext(h, {
				stencil: !0,
				preserveDrawingBuffer: !0
			}) && (cc._renderType = cc._RENDER_TYPE_WEBGL, cc._supportRender = !0)
		} catch(k) {}
		if(1 === e || 0 === e && !1 === cc._supportRender) try {
			h.getContext("2d"), cc._renderType = cc._RENDER_TYPE_CANVAS, cc._supportRender = !0
		} catch(n) {}
	})(b, a);
	b._canUseCanvasNewBlendModes =
		function() {
			var a = document.createElement("canvas");
			a.width = 1;
			a.height = 1;
			a = a.getContext("2d");
			a.fillStyle = "#000";
			a.fillRect(0, 0, 1, 1);
			a.globalCompositeOperation = "multiply";
			var c = document.createElement("canvas");
			c.width = 1;
			c.height = 1;
			var b = c.getContext("2d");
			b.fillStyle = "#fff";
			b.fillRect(0, 0, 1, 1);
			a.drawImage(c, 0, 0, 1, 1);
			return 0 === a.getImageData(0, 0, 1, 1).data[0]
		};
	b._supportCanvasNewBlendModes = b._canUseCanvasNewBlendModes();
	try {
		b._supportWebAudio = !!(d.AudioContext || d.webkitAudioContext || d.mozAudioContext)
	} catch(n) {
		b._supportWebAudio = !1
	}
	try {
		var p = b.localStorage = d.localStorage;
		p.setItem("storage", "");
		p.removeItem("storage");
		p = null
	} catch(s) {
		p = function() {
			cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
		}, b.localStorage = {
			getItem: p,
			setItem: p,
			removeItem: p,
			clear: p
		}
	}
	p = b.capabilities = {
		canvas: !0
	};
	cc._renderType === cc._RENDER_TYPE_WEBGL && (p.opengl = !0);
	if(void 0 !== g.ontouchstart || void 0 !== f.ontouchstart || e.msPointerEnabled) p.touches = !0;
	void 0 !== g.onmouseup && (p.mouse = !0);
	void 0 !== g.onkeyup && (p.keyboard = !0);
	if(d.DeviceMotionEvent || d.DeviceOrientationEvent) p.accelerometer = !0;
	b.garbageCollect = function() {};
	b.dumpRoot = function() {};
	b.restartVM = function() {};
	b.cleanScript = function(a) {};
	b.isObjectValid = function(a) {
		return a ? !0 : !1
	};
	b.dump = function() {
		var a;
		a = "" + ("isMobile : " + this.isMobile + "\r\n");
		a += "language : " + this.language + "\r\n";
		a += "browserType : " + this.browserType + "\r\n";
		a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
		a += "os : " + this.os + "\r\n";
		a += "platform : " + this.platform + "\r\n";
		cc.log(a)
	};
	b.openURL = function(a) {
		window.open(a)
	}
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(a, c, b) {
	if(!cc._setupCalled) {
		cc._setupCalled = !0;
		var d = window,
			e = cc.$(a) || cc.$("#" + a),
			f;
		cc.game._setAnimFrame();
		"CANVAS" === e.tagName ? (c = c || e.width, b = b || e.height, f = cc.container = cc.newElement("DIV"), a = cc._canvas = e, a.parentNode.insertBefore(f, a), a.appendTo(f), f.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" !== e.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), c = c || e.clientWidth, b = b || e.clientHeight, f = cc.container = e, a = cc._canvas = cc.$(cc.newElement("CANVAS")), e.appendChild(a));
		a.addClass("gameCanvas");
		a.setAttribute("width", c || 480);
		a.setAttribute("height", b || 320);
		a.setAttribute("tabindex", 99);
		a.style.outline = "none";
		e = f.style;
		e.width = (c || 480) + "px";
		e.height = (b || 320) + "px";
		e.margin = "0 auto";
		e.overflow = "hidden";
		f.top = "100%";
		cc._renderType === cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
			stencil: !0,
			preserveDrawingBuffer: !0,
			antialias: !cc.sys.isMobile,
			alpha: !1
		}));
		cc._renderContext ? (d.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext),
			cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = new cc.CanvasContextWrapper(a.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
		cc._gameDiv = f;
		cc.log(cc.ENGINE_VERSION);
		cc._setContextMenuEnable(!1);
		cc.sys.isMobile && (c = cc.newElement("style"), c.type = "text/css", document.body.appendChild(c), c.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
		cc.view = cc.EGLView._getInstance();
		cc.inputManager.registerSystemEvent(cc._canvas);
		cc.director = cc.Director._getInstance();
		cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
		cc.winSize = cc.director.getWinSize();
		cc.saxParser = new cc.SAXParser;
		cc.plistParser = new cc.PlistParser
	}
};
cc._checkWebGLRenderMode = function() {
	if(cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(a) {
	cc._isContextMenuEnable = a;
	cc._canvas.oncontextmenu = function() {
		if(!cc._isContextMenuEnable) return !1
	}
};
cc.game = {
	DEBUG_MODE_NONE: 0,
	DEBUG_MODE_INFO: 1,
	DEBUG_MODE_WARN: 2,
	DEBUG_MODE_ERROR: 3,
	DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
	DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
	DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
	EVENT_HIDE: "game_on_hide",
	EVENT_SHOW: "game_on_show",
	EVENT_RESIZE: "game_on_resize",
	_eventHide: null,
	_eventShow: null,
	_onBeforeStartArr: [],
	CONFIG_KEY: {
		engineDir: "engineDir",
		dependencies: "dependencies",
		debugMode: "debugMode",
		showFPS: "showFPS",
		frameRate: "frameRate",
		id: "id",
		renderMode: "renderMode",
		jsList: "jsList",
		classReleaseMode: "classReleaseMode"
	},
	_prepareCalled: !1,
	_prepared: !1,
	_paused: !0,
	_intervalId: null,
	_lastTime: null,
	_frameTime: null,
	config: null,
	onStart: null,
	onStop: null,
	setFrameRate: function(a) {
		this.config[this.CONFIG_KEY.frameRate] = a;
		this._intervalId && window.cancelAnimationFrame(this._intervalId);
		this._paused = !0;
		this._setAnimFrame();
		this._runMainLoop()
	},
	_setAnimFrame: function() {
		this._lastTime = new Date;
		this._frameTime = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
		cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ||
			60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame ||
				window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
	},
	_stTime: function(a) {
		var c = (new Date).getTime(),
			b = Math.max(0, cc.game._frameTime - (c - cc.game._lastTime)),
			d = window.setTimeout(function() {
				a()
			}, b);
		cc.game._lastTime = c + b;
		return d
	},
	_ctTime: function(a) {
		window.clearTimeout(a)
	},
	_runMainLoop: function() {
		var a = this,
			c, b = cc.director;
		b.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
		c = function() {
			a._paused || (b.mainLoop(), a._intervalId && window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(c))
		};
		window.requestAnimFrame(c);
		a._paused = !1
	},
	restart: function() {
		cc.director.popToSceneStackLevel(0);
		cc.audioEngine && cc.audioEngine.end();
		cc.game.onStart()
	},
	run: function(a) {
		var c = this,
			b = function() {
				a && (c.config[c.CONFIG_KEY.id] = a);
				c._prepareCalled || c.prepare(function() {
					c._prepared = !0
				});
				cc._supportRender && (c._checkPrepare = setInterval(function() {
					c._prepared && (cc._setup(c.config[c.CONFIG_KEY.id]),
						c._runMainLoop(), c._eventHide = c._eventHide || new cc.EventCustom(c.EVENT_HIDE), c._eventHide.setUserData(c), c._eventShow = c._eventShow || new cc.EventCustom(c.EVENT_SHOW), c._eventShow.setUserData(c), c.onStart(), clearInterval(c._checkPrepare))
				}, 10))
			};
		document.body ? b() : cc._addEventListener(window, "load", function() {
			this.removeEventListener("load", arguments.callee, !1);
			b()
		}, !1)
	},
	_initConfig: function() {
		var a = this.CONFIG_KEY,
			c = function(c) {
				c[a.engineDir] = c[a.engineDir] || "frameworks/cocos2d-html5";
				null == c[a.debugMode] &&
					(c[a.debugMode] = 0);
				c[a.frameRate] = c[a.frameRate] || 60;
				null == c[a.renderMode] && (c[a.renderMode] = 1);
				return c
			};
		if(document.ccConfig) this.config = c(document.ccConfig);
		else try {
			cc.loader.resPath = "undefined" != typeof hoowuGame ? hoowuGame.resRootDir : "";
			for(var b = document.getElementsByTagName("script"), d = 0; d < b.length; d++) {
				var e = b[d].getAttribute("cocos");
				if("" === e || e) break
			}
			var f, g, h;
			if(d < b.length) {
				if(f = b[d].src) h = /(.*)\//.exec(f)[0], cc.loader.resPath = h, f = cc.path.join(h, "project.json");
				g = cc.loader._loadTxtSync(f)
			}
			g ||
				(g = "undefined" != typeof g_project ? g_project : cc.loader._loadTxtSync(cc.path.join(cc.loader.resPath, "project.json")));
			var k = JSON.parse(g);
			this.config = c(k || {})
		} catch(m) {
			cc.log("Failed to read or parse project.json"), this.config = c({})
		}
		cc._initSys(this.config, a)
	},
	_jsAddedCache: {},
	_getJsListOfModule: function(a, c, b) {
		var d = this._jsAddedCache;
		if(d[c]) return null;
		b = b || "";
		var e = [],
			f = a[c];
		if(!f) throw "can not find module [" + c + "]";
		c = cc.path;
		for(var g = 0, h = f.length; g < h; g++) {
			var k = f[g];
			if(!d[k]) {
				var m = c.extname(k);
				m ? ".js" === m.toLowerCase() && e.push(c.join(b, k)) : (m = this._getJsListOfModule(a, k, b)) && (e = e.concat(m));
				d[k] = 1
			}
		}
		return e
	},
	prepare: function(a) {
		var c = this,
			b = c.config,
			d = c.CONFIG_KEY,
			e = b[d.engineDir],
			f = cc.loader;
		if(!cc._supportRender) throw "The renderer doesn't support the renderMode " + b[d.renderMode];
		c._prepareCalled = !0;
		var g = b[d.jsList] || [];
		cc.Class ? f.loadJsWithImg("", g, function(b) {
			if(b) throw b;
			c._prepared = !0;
			a && a()
		}) : (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function(d, f) {
			if(d) throw d;
			var m = b.modules || [],
				n = f.module,
				p = [];
			cc._renderType === cc._RENDER_TYPE_WEBGL ? m.splice(0, 0, "shaders") : 0 > m.indexOf("core") && m.splice(0, 0, "core");
			for(var s = 0, q = m.length; s < q; s++) {
				var t = c._getJsListOfModule(n, m[s], e);
				t && (p = p.concat(t))
			}
			p = p.concat(g);
			cc.loader.loadJsWithImg(p, function(b) {
				if(b) throw b;
				c._prepared = !0;
				a && a()
			})
		}))
	}
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function(a) {
	if(!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	var c = Array.prototype.slice.call(arguments, 1),
		b = this,
		d = function() {},
		e = function() {
			return b.apply(this instanceof d && a ? this : a, c.concat(Array.prototype.slice.call(arguments)))
		};
	d.prototype = this.prototype;
	e.prototype = new d;
	return e
};
cc._urlRegExp = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
cc._LogInfos = {
	ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
	ActionManager_removeAction: "cocos2d: removeAction: Target not found",
	ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
	ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
	ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
	ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
	configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
	configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
	configuration_loadConfigFile_2: "Please load the resource first : %s",
	Director_resume: "cocos2d: Director: Error in gettimeofday",
	Director_setProjection: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
	Director_popScene: "running scene should not null",
	Director_pushScene: "the scene should not null",
	arrayVerifyType: "element type is wrong!",
	Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
	Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
	Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
	Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
	Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
	Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
	Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
	Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
	Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
	Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
	Node_addChild: "An Node can't be added as a child of itself.",
	Node_addChild_2: "child already added. It can't be added again",
	Node_addChild_3: "child must be non-null",
	Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
	Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
	Node_removeChildByTag: "argument tag is an invalid tag",
	Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
	Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
	Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
	Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
	Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
	Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
	Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
	Node_reorderChild: "child must be non-null",
	Node_runAction: "cc.Node.runAction(): action must be non-null",
	Node_schedule: "callback function must be non-null",
	Node_schedule_2: "interval must be positive",
	Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
	AtlasNode_initWithTileFile: "",
	AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	_EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
	_EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
	_EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
	_EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
	EventListener_create: "Invalid parameter.",
	__getListenerID: "Don't call this method if the event is for touch.",
	eventManager__forceAddEventListener: "Invalid scene graph priority!",
	eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
	eventManager_removeListeners: "Invalid listener type!",
	eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
	eventManager_addListener_2: "Invalid parameters.",
	eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
	eventManager_addListener_4: "The listener has been registered, please don't register it again.",
	LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
	LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
	EGLView_setDesignResolutionSize: "Resolution not valid",
	EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
	inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
	swap: "cc.swap is being modified from original macro, please check usage",
	checkGLErrorDebug: "WebGL error %s",
	animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
	animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
	animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
	animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
	animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
	animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
	Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
	Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
	Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
	Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
	Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
	Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
	Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
	Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
	Sprite_initWithSpriteFrameName1: " is null, please check.",
	Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
	Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
	Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
	Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
	Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
	Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
	Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
	Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
	Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	Sprite_setSpriteFrame: "Invalid spriteFrameName",
	Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
	Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
	SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
	SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
	SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
	SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
	SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
	SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
	spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
	spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
	spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
	spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
	spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
	spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
	spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
	CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
	CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
	CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
	CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
	TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
	TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
	TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
	TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
	TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
	TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
	TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
	TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
	TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
	TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
	TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
	TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
	TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
	TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
	textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
	textureCache_addPVRImage: "addPVRImage does not support on HTML5",
	textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
	textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
	textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
	textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
	textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
	Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
	Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
	Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
	Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
	Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
	Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
	Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
	Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithData: "NSInternalInconsistencyException",
	MissingFile: "Missing file: %s",
	radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
	RectWidth: "Rect width exceeds maximum margin: %s",
	RectHeight: "Rect height exceeds maximum margin: %s",
	EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
	EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
	if(cc._canvas) {
		var c = cc._logList,
			b = document;
		if(!c) {
			var d = b.createElement("Div"),
				c = d.style;
			d.setAttribute("id", "logInfoDiv");
			cc._canvas.parentNode.appendChild(d);
			d.setAttribute("width", "200");
			d.setAttribute("height", cc._canvas.height);
			c.zIndex = "99999";
			c.position = "absolute";
			c.top = "0";
			c.left = "0";
			c = cc._logList = b.createElement("textarea");
			b = c.style;
			c.setAttribute("rows", "20");
			c.setAttribute("cols", "30");
			c.setAttribute("disabled", !0);
			d.appendChild(c);
			b.backgroundColor = "transparent";
			b.borderBottom = "1px solid #cccccc";
			b.borderRightWidth = "0px";
			b.borderLeftWidth = "0px";
			b.borderTopWidth = "0px";
			b.borderTopStyle = "none";
			b.borderRightStyle = "none";
			b.borderLeftStyle = "none";
			b.padding = "0px";
			b.margin = 0
		}
		c.value = c.value + a + "\r\n";
		c.scrollTop = c.scrollHeight
	}
};
cc._formatString = function(a) {
	if(cc.isObject(a)) try {
		return JSON.stringify(a)
	} catch(c) {
		return ""
	} else return a
};
cc._initDebugSetting = function(a) {
	var c = cc.game;
	if(a !== c.DEBUG_MODE_NONE) {
		var b;
		a > c.DEBUG_MODE_ERROR ? (b = cc._logToWebPage.bind(cc), cc.error = function() {
			b("ERROR :  " + cc.formatStr.apply(cc, arguments))
		}, cc.assert = function(a, c) {
			if(!a && c) {
				for(var f = 2; f < arguments.length; f++) c = c.replace(/(%s)|(%d)/, cc._formatString(arguments[f]));
				b("Assert: " + c)
			}
		}, a !== c.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
			b("WARN :  " + cc.formatStr.apply(cc, arguments))
		}), a === c.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
			b(cc.formatStr.apply(cc,
				arguments))
		})) : console && console.log.apply && (cc.error = function() {
			return console.error.apply(console, arguments)
		}, cc.assert = function(a, c) {
			if(!a && c) {
				for(var b = 2; b < arguments.length; b++) c = c.replace(/(%s)|(%d)/, cc._formatString(arguments[b]));
				throw c;
			}
		}, a !== c.DEBUG_MODE_ERROR && (cc.warn = function() {
			return console.warn.apply(console, arguments)
		}), a === c.DEBUG_MODE_INFO && (cc.log = function() {
			return console.log.apply(console, arguments)
		}))
	}
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.loader.loadBinary = function(a, c) {
	var b = this,
		d = this.getXMLHttpRequest(),
		e = "load " + a + " failed!";
	d.open("GET", a, !0);
	cc.loader.loadBinary._IEFilter ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
		if(4 === d.readyState && 200 === d.status) {
			var a = cc._convertResponseBodyToText(d.responseBody);
			c(null, b._str2Uint8Array(a))
		} else c(e)
	}) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dx-user-defined"), d.onload = function() {
		4 === d.readyState && 200 === d.status ? c(null,
			b._str2Uint8Array(d.responseText)) : c(e)
	});
	d.send(null)
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function(a) {
	if(!a) return null;
	for(var c = new Uint8Array(a.length), b = 0; b < a.length; b++) c[b] = a.charCodeAt(b) & 255;
	return c
};
cc.loader.loadBinarySync = function(a) {
	var c = this.getXMLHttpRequest(),
		b = "load " + a + " failed!";
	c.open("GET", a, !1);
	a = null;
	if(cc.loader.loadBinary._IEFilter) {
		c.setRequestHeader("Accept-Charset", "x-user-defined");
		c.send(null);
		if(200 !== c.status) return cc.log(b), null;
		(c = cc._convertResponseBodyToText(c.responseBody)) && (a = this._str2Uint8Array(c))
	} else {
		c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dx-user-defined");
		c.send(null);
		if(200 !== c.status) return cc.log(b), null;
		a = this._str2Uint8Array(c.responseText)
	}
	return a
};
window.Uint8Array = window.Uint8Array || window.Array;
if(cc.loader.loadBinary._IEFilter) {
	var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
		myVBScript =
		cc.newElement("script");
	myVBScript.type = "text/vbscript";
	myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
	document.body.appendChild(myVBScript);
	cc._convertResponseBodyToText = function(a) {
		for(var c = {}, b = 0; 256 > b; b++)
			for(var d = 0; 256 > d; d++) c[String.fromCharCode(b + 256 * d)] = String.fromCharCode(b) + String.fromCharCode(d);
		b = IEBinaryToArray_ByteStr(a);
		a = IEBinaryToArray_ByteStr_Last(a);
		return b.replace(/[\s\S]/g, function(a) {
			return c[a]
		}) + a
	}
};
cc = cc || {};
cc._loadingImage = "";
cc._fpsImage = "";
cc._loaderImage = "/*链接首页启动图*/";
var cc = cc || {},
	ClassManager = {
		id: 0 | 998 * Math.random(),
		instanceId: 0 | 998 * Math.random(),
		compileSuper: function(a, c, b) {
			a = a.toString();
			var d = a.indexOf("("),
				e = a.indexOf(")"),
				d = a.substring(d + 1, e),
				d = d.trim(),
				e = a.indexOf("{"),
				f = a.lastIndexOf("}");
			for(a = a.substring(e + 1, f); - 1 !== a.indexOf("this._super");) {
				var e = a.indexOf("this._super"),
					f = a.indexOf("(", e),
					g = a.indexOf(")", f),
					g = a.substring(f + 1, g),
					g = (g = g.trim()) ? "," : "";
				a = a.substring(0, e) + "ClassManager[" + b + "]." + c + ".call(this" + g + a.substring(f + 1)
			}
			return Function(d, a)
		},
		getNewID: function() {
			return this.id++
		},
		getNewInstanceId: function() {
			return this.instanceId++
		}
	};
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
	var a = /\b_super\b/,
		c = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
	c && console.log("release Mode");
	cc.Class = function() {};
	cc.Class.extend = function(b) {
		function d() {
			this.__instanceId = ClassManager.getNewInstanceId();
			this.ctor && this.ctor.apply(this, arguments)
		}
		var e = this.prototype,
			f = Object.create(e),
			g = ClassManager.getNewID();
		ClassManager[g] = e;
		var h = {
			writable: !0,
			enumerable: !1,
			configurable: !0
		};
		f.__instanceId = null;
		d.id = g;
		h.value = g;
		Object.defineProperty(f, "__pid", h);
		d.prototype = f;
		h.value = d;
		Object.defineProperty(d.prototype, "constructor", h);
		this.__getters__ && (d.__getters__ = cc.clone(this.__getters__));
		this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
		for(var k = 0, m = arguments.length; k < m; ++k) {
			var n = arguments[k],
				p;
			for(p in n) {
				var s = "function" === typeof n[p],
					q = "function" === typeof e[p],
					t = a.test(n[p]);
				c && s && q && t ? (h.value = ClassManager.compileSuper(n[p], p, g), Object.defineProperty(f, p, h)) : s && q && t ? (h.value = function(a, c) {
					return function() {
						var b = this._super;
						this._super = e[a];
						var d = c.apply(this,
							arguments);
						this._super = b;
						return d
					}
				}(p, n[p]), Object.defineProperty(f, p, h)) : s ? (h.value = n[p], Object.defineProperty(f, p, h)) : f[p] = n[p];
				if(s) {
					var r, u;
					if(this.__getters__ && this.__getters__[p]) {
						var s = this.__getters__[p],
							v;
						for(v in this.__setters__)
							if(this.__setters__[v] === s) {
								u = v;
								break
							}
						cc.defineGetterSetter(f, s, n[p], n[u] ? n[u] : f[u], p, u)
					}
					if(this.__setters__ && this.__setters__[p]) {
						s = this.__setters__[p];
						for(v in this.__getters__)
							if(this.__getters__[v] === s) {
								r = v;
								break
							}
						cc.defineGetterSetter(f, s, n[r] ? n[r] : f[r], n[p],
							r, p)
					}
				}
			}
		}
		d.extend = cc.Class.extend;
		d.implement = function(a) {
			for(var c in a) f[c] = a[c]
		};
		return d
	}
})();
cc.defineGetterSetter = function(a, c, b, d, e, f) {
	if(a.__defineGetter__) b && a.__defineGetter__(c, b), d && a.__defineSetter__(c, d);
	else if(Object.defineProperty) {
		var g = {
			enumerable: !1,
			configurable: !0
		};
		b && (g.get = b);
		d && (g.set = d);
		Object.defineProperty(a, c, g)
	} else throw Error("browser does not support getters");
	if(!e && !f)
		for(var g = null != b, h = void 0 != d, k = Object.getOwnPropertyNames(a), m = 0; m < k.length; m++) {
			var n = k[m];
			if((a.__lookupGetter__ ? !a.__lookupGetter__(n) : !Object.getOwnPropertyDescriptor(a, n)) && "function" === typeof a[n]) {
				var p =
					a[n];
				if(g && p === b && (e = n, !h || f)) break;
				if(h && p === d && (f = n, !g || e)) break
			}
		}
	a = a.constructor;
	e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = c);
	f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = c)
};
cc.clone = function(a) {
	var c = a.constructor ? new a.constructor : {},
		b;
	for(b in a) {
		var d = a[b];
		c[b] = "object" !== typeof d || !d || d instanceof cc.Node || d instanceof HTMLElement ? d : cc.clone(d)
	}
	return c
};
cc.inject = function(a, c) {
	for(var b in a) c[b] = a[b]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, c) {};
cc.KEY = {
	none: 0,
	back: 6,
	menu: 18,
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	pause: 19,
	capslock: 20,
	escape: 27,
	space: 32,
	pageup: 33,
	pagedown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	select: 41,
	insert: 45,
	Delete: 46,
	0: 48,
	1: 49,
	2: 50,
	3: 51,
	4: 52,
	5: 53,
	6: 54,
	7: 55,
	8: 56,
	9: 57,
	a: 65,
	b: 66,
	c: 67,
	d: 68,
	e: 69,
	f: 70,
	g: 71,
	h: 72,
	i: 73,
	j: 74,
	k: 75,
	l: 76,
	m: 77,
	n: 78,
	o: 79,
	p: 80,
	q: 81,
	r: 82,
	s: 83,
	t: 84,
	u: 85,
	v: 86,
	w: 87,
	x: 88,
	y: 89,
	z: 90,
	num0: 96,
	num1: 97,
	num2: 98,
	num3: 99,
	num4: 100,
	num5: 101,
	num6: 102,
	num7: 103,
	num8: 104,
	num9: 105,
	"*": 106,
	"+": 107,
	"-": 109,
	numdel: 110,
	"/": 111,
	f1: 112,
	f2: 113,
	f3: 114,
	f4: 115,
	f5: 116,
	f6: 117,
	f7: 118,
	f8: 119,
	f9: 120,
	f10: 121,
	f11: 122,
	f12: 123,
	numlock: 144,
	scrolllock: 145,
	";": 186,
	semicolon: 186,
	equal: 187,
	"\x3d": 187,
	",": 188,
	comma: 188,
	dash: 189,
	".": 190,
	period: 190,
	forwardslash: 191,
	grave: 192,
	"[": 219,
	openbracket: 219,
	backslash: 220,
	"]": 221,
	closebracket: 221,
	quote: 222,
	dpadLeft: 1E3,
	dpadRight: 1001,
	dpadUp: 1003,
	dpadDown: 1004,
	dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
	return 8 < a.length && 137 === a[0] && 80 === a[1] && 78 === a[2] && 71 === a[3] && 13 === a[4] && 10 === a[5] && 26 === a[6] && 10 === a[7] ? cc.FMT_PNG : 2 < a.length && (73 === a[0] && 73 === a[1] || 77 === a[0] && 77 === a[1] || 255 === a[0] && 216 === a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, c) {
	function b() {}
	b.prototype = c.prototype;
	a.superClass_ = c.prototype;
	a.prototype = new b;
	a.prototype.constructor = a
};
cc.base = function(a, c, b) {
	var d = arguments.callee.caller;
	if(d.superClass_) return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
	for(var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
		if(g.prototype[c] === d) f = !0;
		else if(f) return g.prototype[c].apply(a, e);
	if(a[c] === d) return a.constructor.prototype[c].apply(a, e);
	throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, c) {
	this.x = a || 0;
	this.y = c || 0
};
cc.p = function(a, c) {
	return void 0 === a ? {
		x: 0,
		y: 0
	} : void 0 === c ? {
		x: a.x,
		y: a.y
	} : {
		x: a,
		y: c
	}
};
cc.pointEqualToPoint = function(a, c) {
	return a && c && a.x === c.x && a.y === c.y
};
cc.Size = function(a, c) {
	this.width = a || 0;
	this.height = c || 0
};
cc.size = function(a, c) {
	return void 0 === a ? {
		width: 0,
		height: 0
	} : void 0 === c ? {
		width: a.width,
		height: a.height
	} : {
		width: a,
		height: c
	}
};
cc.sizeEqualToSize = function(a, c) {
	return a && c && a.width === c.width && a.height === c.height
};
cc.Rect = function(a, c, b, d) {
	this.x = a || 0;
	this.y = c || 0;
	this.width = b || 0;
	this.height = d || 0
};
cc.rect = function(a, c, b, d) {
	return void 0 === a ? {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	} : void 0 === c ? {
		x: a.x,
		y: a.y,
		width: a.width,
		height: a.height
	} : {
		x: a,
		y: c,
		width: b,
		height: d
	}
};
cc.rectEqualToRect = function(a, c) {
	return a && c && a.x === c.x && a.y === c.y && a.width === c.width && a.height === c.height
};
cc._rectEqualToZero = function(a) {
	return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, c) {
	return a && c ? !(a.x >= c.x || a.y >= c.y || a.x + a.width <= c.x + c.width || a.y + a.height <= c.y + c.height) : !1
};
cc.rectGetMaxX = function(a) {
	return a.x + a.width
};
cc.rectGetMidX = function(a) {
	return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
	return a.x
};
cc.rectGetMaxY = function(a) {
	return a.y + a.height
};
cc.rectGetMidY = function(a) {
	return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
	return a.y
};
cc.rectContainsPoint = function(a, c) {
	return c.x >= cc.rectGetMinX(a) && c.x <= cc.rectGetMaxX(a) && c.y >= cc.rectGetMinY(a) && c.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, c) {
	var b = a.y + a.height,
		d = c.x + c.width,
		e = c.y + c.height;
	return !(a.x + a.width < c.x || d < a.x || b < c.y || e < a.y)
};
cc.rectOverlapsRect = function(a, c) {
	return !(a.x + a.width < c.x || c.x + c.width < a.x || a.y + a.height < c.y || c.y + c.height < a.y)
};
cc.rectUnion = function(a, c) {
	var b = cc.rect(0, 0, 0, 0);
	b.x = Math.min(a.x, c.x);
	b.y = Math.min(a.y, c.y);
	b.width = Math.max(a.x + a.width, c.x + c.width) - b.x;
	b.height = Math.max(a.y + a.height, c.y + c.height) - b.y;
	return b
};
cc.rectIntersection = function(a, c) {
	var b = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(c)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(c)), 0, 0);
	b.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(c)) - cc.rectGetMinX(b);
	b.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(c)) - cc.rectGetMinY(b);
	return b
};
cc.SAXParser = cc.Class.extend({
	_parser: null,
	_isSupportDOMParser: null,
	ctor: function() {
		window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
	},
	parse: function(a) {
		return this._parseXML(a)
	},
	_parseXML: function(a) {
		var c;
		this._isSupportDOMParser ? c = this._parser.parseFromString(a, "text/xml") : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(a));
		return c
	}
});
cc.PlistParser = cc.SAXParser.extend({
	parse: function(a) {
		a = this._parseXML(a).documentElement;
		if("plist" !== a.tagName) throw "Not a plist file!";
		for(var c = null, b = 0, d = a.childNodes.length; b < d && (c = a.childNodes[b], 1 !== c.nodeType); b++);
		return this._parseNode(c)
	},
	_parseNode: function(a) {
		var c = null,
			b = a.tagName;
		if("dict" === b) c = this._parseDict(a);
		else if("array" === b) c = this._parseArray(a);
		else if("string" === b)
			if(1 === a.childNodes.length) c = a.firstChild.nodeValue;
			else
				for(c = "", b = 0; b < a.childNodes.length; b++) c += a.childNodes[b].nodeValue;
		else "false" === b ? c = !1 : "true" === b ? c = !0 : "real" === b ? c = parseFloat(a.firstChild.nodeValue) : "integer" === b && (c = parseInt(a.firstChild.nodeValue, 10));
		return c
	},
	_parseArray: function(a) {
		for(var c = [], b = 0, d = a.childNodes.length; b < d; b++) {
			var e = a.childNodes[b];
			1 === e.nodeType && c.push(this._parseNode(e))
		}
		return c
	},
	_parseDict: function(a) {
		for(var c = {}, b = null, d = 0, e = a.childNodes.length; d < e; d++) {
			var f = a.childNodes[d];
			1 === f.nodeType && ("key" === f.tagName ? b = f.firstChild.nodeValue : c[b] = this._parseNode(f))
		}
		return c
	}
});
cc._txtLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadTxt(a, d)
	}
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadJson(a, d)
	}
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadJs(a, d)
	}
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
	load: function(a, c, b, d) {
		cc.loader.cache[c] = cc.loader.loadImg(a, function(a, b) {
			if(a) return d(a);
			cc.textureCache.handleLoadedTexture(c);
			d(null, b)
		})
	}
};
cc.loader.register("png jpg bmp jpeg gif ico tiff".split(" "), cc._imgLoader);
cc._serverImgLoader = {
	load: function(a, c, b, d) {
		cc.loader.cache[c] = cc.loader.loadImg(b.src, function(a, b) {
			if(a) return d(a);
			cc.textureCache.handleLoadedTexture(c);
			d(null, b)
		})
	}
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadTxt(a, function(a, c) {
			if(a) return d(a);
			d(null, cc.plistParser.parse(c))
		})
	}
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
	TYPE: {
		".eot": "embedded-opentype",
		".ttf": "truetype",
		".ttc": "truetype",
		".woff": "woff",
		".svg": "svg"
	},
	_loadFont: function(a, c, b) {
		var d = document,
			e = cc.path,
			f = this.TYPE,
			g = cc.newElement("style");
		g.type = "text/css";
		d.body.appendChild(g);
		var h = "",
			h = isNaN(a - 0) ? h + ("@font-face { font-family:" + a + "; src:") : h + ("@font-face { font-family:'" + a + "'; src:");
		if(c instanceof Array)
			for(var k = 0, m = c.length; k < m; k++) b = e.extname(c[k]).toLowerCase(), h += "url('" + c[k] + "') format('" + f[b] + "')", h += k === m - 1 ? ";" : ",";
		else b =
			b.toLowerCase(), h += "url('" + c + "') format('" + f[b] + "');";
		g.textContent += h + "}";
		c = cc.newElement("div");
		b = c.style;
		b.fontFamily = a;
		c.innerHTML = ".";
		b.position = "absolute";
		b.left = "-100px";
		b.top = "-100px";
		d.body.appendChild(c)
	},
	load: function(a, c, b, d) {
		c = b.type;
		a = b.name;
		c = b.srcs;
		cc.isString(b) ? (c = cc.path.extname(b), a = cc.path.basename(b, c), this._loadFont(a, b, c)) : this._loadFont(a, c);
		d(null, !0)
	}
};
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader);
cc._binaryLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadBinary(a, d)
	}
};
cc._csbLoader = {
	load: function(a, c, b, d) {
		cc.loader.loadCsb(a, d)
	}
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.7";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
	var c = this === cc ? document : this;
	if(a = a instanceof HTMLElement ? a : c.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
			return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
		}, a.addClass = a.addClass || function(a) {
			this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
			return this
		}, a.removeClass = a.removeClass || function(a) {
			this.hasClass(a) && (this.className = this.className.replace(a, ""));
			return this
		}, a.remove = a.remove || function() {
			this.parentNode &&
				this.parentNode.removeChild(this);
			return this
		}, a.appendTo = a.appendTo || function(a) {
			a.appendChild(this);
			return this
		}, a.prependTo = a.prependTo || function(a) {
			a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
			return this
		}, a.transforms = a.transforms || function() {
			this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
			return this
		}, a.position = a.position || {
			x: 0,
			y: 0
		}, a.rotation = a.rotation || 0, a.scale = a.scale || {
			x: 1,
			y: 1
		}, a.skew =
		a.skew || {
			x: 0,
			y: 0
		}, a.translates = function(a, c) {
			this.position.x = a;
			this.position.y = c;
			this.transforms();
			return this
		}, a.rotate = function(a) {
			this.rotation = a;
			this.transforms();
			return this
		}, a.resize = function(a, c) {
			this.scale.x = a;
			this.scale.y = c;
			this.transforms();
			return this
		}, a.setSkew = function(a, c) {
			this.skew.x = a;
			this.skew.y = c;
			this.transforms();
			return this
		};
	return a
};
switch(cc.sys.browserType) {
	case cc.sys.BROWSER_TYPE_FIREFOX:
		cc.$.pfx = "Moz";
		cc.$.hd = !0;
		break;
	case cc.sys.BROWSER_TYPE_CHROME:
	case cc.sys.BROWSER_TYPE_SAFARI:
		cc.$.pfx = "webkit";
		cc.$.hd = !0;
		break;
	case cc.sys.BROWSER_TYPE_OPERA:
		cc.$.pfx = "O";
		cc.$.hd = !1;
		break;
	case cc.sys.BROWSER_TYPE_IE:
		cc.$.pfx = "ms";
		cc.$.hd = !1;
		break;
	default:
		cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
	return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
	return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
	return "rotateZ(" + a + "deg) "
} : function(a) {
	return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
	return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
	return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
	return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
	var c = 0,
		b = 0;
	do c += a.offsetLeft, b += a.offsetTop; while (a = a.offsetParent);
	return {
		x: c,
		y: b
	}
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, c, b) {
	if(!cc.isObject(b) || cc.isUndefined(b.x) || cc.isUndefined(b.y)) cc.log(cc._LogInfos.swap);
	else {
		var d = b[a];
		b[a] = b[c];
		b[c] = d
	}
};
cc.lerp = function(a, c, b) {
	return a + (c - a) * b
};
cc.rand = function() {
	return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
	return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
	return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
	return a * cc.DEG
};
cc.radiansToDegress = function(a) {
	cc.log(cc._LogInfos.radiansToDegress);
	return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function(a) {
	a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
	cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
	return cc.director.getContentScaleFactor()
} : function() {
	return 1
};
cc.pointPointsToPixels = function(a) {
	var c = cc.contentScaleFactor();
	return cc.p(a.x * c, a.y * c)
};
cc.pointPixelsToPoints = function(a) {
	var c = cc.contentScaleFactor();
	return cc.p(a.x / c, a.y / c)
};
cc._pointPixelsToPointsOut = function(a, c) {
	var b = cc.contentScaleFactor();
	c.x = a.x / b;
	c.y = a.y / b
};
cc.sizePointsToPixels = function(a) {
	var c = cc.contentScaleFactor();
	return cc.size(a.width * c, a.height * c)
};
cc.sizePixelsToPoints = function(a) {
	var c = cc.contentScaleFactor();
	return cc.size(a.width / c, a.height / c)
};
cc._sizePixelsToPointsOut = function(a, c) {
	var b = cc.contentScaleFactor();
	c.width = a.width / b;
	c.height = a.height / b
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
	var c = cc.contentScaleFactor();
	return cc.rect(a.x / c, a.y / c, a.width / c, a.height / c)
} : function(a) {
	return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
	var c = cc.contentScaleFactor();
	return cc.rect(a.x * c, a.y * c, a.width * c, a.height * c)
} : function(a) {
	return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc._renderType === cc._RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? cc.ONE : cc.SRC_ALPHA;
cc.BLEND_DST = 771;
cc.checkGLErrorDebug = function() {
	if(cc.renderMode === cc._RENDER_TYPE_WEBGL) {
		var a = cc._renderContext.getError();
		a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
	}
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(a, c) {
	if(a && 0 < a.length)
		for(var b = 0; b < a.length; b++)
			if(!(a[b] instanceof c)) return cc.log("element type is wrong!"), !1;
	return !0
};
cc.arrayRemoveObject = function(a, c) {
	for(var b = 0, d = a.length; b < d; b++)
		if(a[b] === c) {
			a.splice(b, 1);
			break
		}
};
cc.arrayRemoveArray = function(a, c) {
	for(var b = 0, d = c.length; b < d; b++) cc.arrayRemoveObject(a, c[b])
};
cc.arrayAppendObjectsToIndex = function(a, c, b) {
	a.splice.apply(a, [b, 0].concat(c));
	return a
};
cc.copyArray = function(a) {
	var c, b = a.length,
		d = Array(b);
	for(c = 0; c < b; c += 1) d[c] = a[c];
	return d
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
	cc.color = function(a, b, d, e, f, g) {
		return void 0 === a ? new cc.Color(0, 0, 0, 255, f, g) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, b, d, e, f, g)
	};
	cc.Color = function(a, b, d, e, f, g) {
		this._arrayBuffer = f || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
		this._offset = g || 0;
		f = this._arrayBuffer;
		g = this._offset;
		var h = Uint8Array.BYTES_PER_ELEMENT;
		this._rU8 = new Uint8Array(f, g, 1);
		this._gU8 = new Uint8Array(f,
			g + h, 1);
		this._bU8 = new Uint8Array(f, g + 2 * h, 1);
		this._aU8 = new Uint8Array(f, g + 3 * h, 1);
		this._rU8[0] = a || 0;
		this._gU8[0] = b || 0;
		this._bU8[0] = d || 0;
		this._aU8[0] = null == e ? 255 : e;
		void 0 === e && (this.a_undefined = !0)
	};
	cc.Color.BYTES_PER_ELEMENT = 4;
	var a = cc.Color.prototype;
	a._getR = function() {
		return this._rU8[0]
	};
	a._setR = function(a) {
		this._rU8[0] = 0 > a ? 0 : a
	};
	a._getG = function() {
		return this._gU8[0]
	};
	a._setG = function(a) {
		this._gU8[0] = 0 > a ? 0 : a
	};
	a._getB = function() {
		return this._bU8[0]
	};
	a._setB = function(a) {
		this._bU8[0] = 0 > a ? 0 : a
	};
	a._getA =
		function() {
			return this._aU8[0]
		};
	a._setA = function(a) {
		this._aU8[0] = 0 > a ? 0 : a
	};
	cc.defineGetterSetter(a, "r", a._getR, a._setR);
	cc.defineGetterSetter(a, "g", a._getG, a._setG);
	cc.defineGetterSetter(a, "b", a._getB, a._setB);
	cc.defineGetterSetter(a, "a", a._getA, a._setA);
	cc.Vertex2F = function(a, b, d, e) {
		this._arrayBuffer = d || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
		this._offset = e || 0;
		this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._xF32[0] =
			a || 0;
		this._yF32[0] = b || 0
	};
	cc.Vertex2F.BYTES_PER_ELEMENT = 8;
	a = cc.Vertex2F.prototype;
	a._getX = function() {
		return this._xF32[0]
	};
	a._setX = function(a) {
		this._xF32[0] = a
	};
	a._getY = function() {
		return this._yF32[0]
	};
	a._setY = function(a) {
		this._yF32[0] = a
	};
	cc.defineGetterSetter(a, "x", a._getX, a._setX);
	cc.defineGetterSetter(a, "y", a._getY, a._setY);
	cc.Vertex3F = function(a, b, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		this._xF32 = new Float32Array(e,
			f, 1);
		this._xF32[0] = a || 0;
		this._yF32 = new Float32Array(e, f + Float32Array.BYTES_PER_ELEMENT, 1);
		this._yF32[0] = b || 0;
		this._zF32 = new Float32Array(e, f + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
		this._zF32[0] = d || 0
	};
	cc.Vertex3F.BYTES_PER_ELEMENT = 12;
	a = cc.Vertex3F.prototype;
	a._getX = function() {
		return this._xF32[0]
	};
	a._setX = function(a) {
		this._xF32[0] = a
	};
	a._getY = function() {
		return this._yF32[0]
	};
	a._setY = function(a) {
		this._yF32[0] = a
	};
	a._getZ = function() {
		return this._zF32[0]
	};
	a._setZ = function(a) {
		this._zF32[0] = a
	};
	cc.defineGetterSetter(a,
		"x", a._getX, a._setX);
	cc.defineGetterSetter(a, "y", a._getY, a._setY);
	cc.defineGetterSetter(a, "z", a._getZ, a._setZ);
	cc.Tex2F = function(a, b, d, e) {
		this._arrayBuffer = d || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
		this._offset = e || 0;
		this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._uF32[0] = a || 0;
		this._vF32[0] = b || 0
	};
	cc.Tex2F.BYTES_PER_ELEMENT = 8;
	a = cc.Tex2F.prototype;
	a._getU = function() {
		return this._uF32[0]
	};
	a._setU = function(a) {
		this._uF32[0] =
			a
	};
	a._getV = function() {
		return this._vF32[0]
	};
	a._setV = function(a) {
		this._vF32[0] = a
	};
	cc.defineGetterSetter(a, "u", a._getU, a._setU);
	cc.defineGetterSetter(a, "v", a._getV, a._setV);
	cc.Quad2 = function(a, b, d, e, f, g) {
		this._arrayBuffer = f || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
		this._offset = g || 0;
		f = this._arrayBuffer;
		g = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._tl = a ? new cc.Vertex2F(a.x, a.y, f, 0) : new cc.Vertex2F(0, 0, f, 0);
		this._tr = b ? new cc.Vertex2F(b.x, b.y, f, g) : new cc.Vertex2F(0, 0, f, g);
		this._bl = d ? new cc.Vertex2F(d.x, d.y,
			f, 2 * g) : new cc.Vertex2F(0, 0, f, 2 * g);
		this._br = e ? new cc.Vertex2F(e.x, e.y, f, 3 * g) : new cc.Vertex2F(0, 0, f, 3 * g)
	};
	cc.Quad2.BYTES_PER_ELEMENT = 32;
	a = cc.Quad2.prototype;
	a._getTL = function() {
		return this._tl
	};
	a._setTL = function(a) {
		this._tl.x = a.x;
		this._tl.y = a.y
	};
	a._getTR = function() {
		return this._tr
	};
	a._setTR = function(a) {
		this._tr.x = a.x;
		this._tr.y = a.y
	};
	a._getBL = function() {
		return this._bl
	};
	a._setBL = function(a) {
		this._bl.x = a.x;
		this._bl.y = a.y
	};
	a._getBR = function() {
		return this._br
	};
	a._setBR = function(a) {
		this._br.x = a.x;
		this._br.y =
			a.y
	};
	cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
	cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
	cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
	cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
	cc.Quad3 = function(a, b, d, e) {
		this.bl = a || new cc.Vertex3F(0, 0, 0);
		this.br = b || new cc.Vertex3F(0, 0, 0);
		this.tl = d || new cc.Vertex3F(0, 0, 0);
		this.tr = e || new cc.Vertex3F(0, 0, 0)
	};
	cc.V3F_C4B_T2F = function(a, b, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var g = cc.Vertex3F.BYTES_PER_ELEMENT;
		this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, e, f) : new cc.Vertex3F(0, 0, 0, e, f);
		this._colors = b ? cc.color(b.r, b.g, b.b, b.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
		this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
	a = cc.V3F_C4B_T2F.prototype;
	a._getVertices = function() {
		return this._vertices
	};
	a._setVertices = function(a) {
		var b = this._vertices;
		b.x = a.x;
		b.y = a.y;
		b.z =
			a.z
	};
	a._getColor = function() {
		return this._colors
	};
	a._setColor = function(a) {
		var b = this._colors;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		b.a = a.a
	};
	a._getTexCoords = function() {
		return this._texCoords
	};
	a._setTexCoords = function(a) {
		this._texCoords.u = a.u;
		this._texCoords.v = a.v
	};
	cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
	cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
	cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
	cc.V3F_C4B_T2F_Quad = function(a, b, d, e, f, g) {
		this._arrayBuffer =
			f || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
		this._offset = g || 0;
		f = this._arrayBuffer;
		g = this._offset;
		var h = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
		this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V3F_C4B_T2F(null, null, null, f, g);
		this._bl = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, f, g + h) : new cc.V3F_C4B_T2F(null, null, null, f, g + h);
		this._tr = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + 2 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 2 * h);
		this._br = e ? new cc.V3F_C4B_T2F(e.vertices,
			e.colors, e.texCoords, f, g + 3 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 3 * h)
	};
	cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
	a = cc.V3F_C4B_T2F_Quad.prototype;
	a._getTL = function() {
		return this._tl
	};
	a._setTL = function(a) {
		var b = this._tl;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getBL = function() {
		return this._bl
	};
	a._setBL = function(a) {
		var b = this._bl;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getTR = function() {
		return this._tr
	};
	a._setTR = function(a) {
		var b = this._tr;
		b.vertices =
			a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getBR = function() {
		return this._br
	};
	a._setBR = function(a) {
		var b = this._br;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getArrayBuffer = function() {
		return this._arrayBuffer
	};
	cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
	cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
	cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
	cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
	cc.defineGetterSetter(a, "arrayBuffer", a._getArrayBuffer, null);
	cc.V3F_C4B_T2F_QuadZero = function() {
		return new cc.V3F_C4B_T2F_Quad
	};
	cc.V3F_C4B_T2F_QuadCopy = function(a) {
		if(!a) return cc.V3F_C4B_T2F_QuadZero();
		var b = a.tl,
			d = a.bl,
			e = a.tr;
		a = a.br;
		return {
			tl: {
				vertices: {
					x: b.vertices.x,
					y: b.vertices.y,
					z: b.vertices.z
				},
				colors: {
					r: b.colors.r,
					g: b.colors.g,
					b: b.colors.b,
					a: b.colors.a
				},
				texCoords: {
					u: b.texCoords.u,
					v: b.texCoords.v
				}
			},
			bl: {
				vertices: {
					x: d.vertices.x,
					y: d.vertices.y,
					z: d.vertices.z
				},
				colors: {
					r: d.colors.r,
					g: d.colors.g,
					b: d.colors.b,
					a: d.colors.a
				},
				texCoords: {
					u: d.texCoords.u,
					v: d.texCoords.v
				}
			},
			tr: {
				vertices: {
					x: e.vertices.x,
					y: e.vertices.y,
					z: e.vertices.z
				},
				colors: {
					r: e.colors.r,
					g: e.colors.g,
					b: e.colors.b,
					a: e.colors.a
				},
				texCoords: {
					u: e.texCoords.u,
					v: e.texCoords.v
				}
			},
			br: {
				vertices: {
					x: a.vertices.x,
					y: a.vertices.y,
					z: a.vertices.z
				},
				colors: {
					r: a.colors.r,
					g: a.colors.g,
					b: a.colors.b,
					a: a.colors.a
				},
				texCoords: {
					u: a.texCoords.u,
					v: a.texCoords.v
				}
			}
		}
	};
	cc.V3F_C4B_T2F_QuadsCopy = function(a) {
		if(!a) return [];
		for(var b = [], d = 0; d < a.length; d++) b.push(cc.V3F_C4B_T2F_QuadCopy(a[d]));
		return b
	};
	cc.V2F_C4B_T2F = function(a, b, d, e, f) {
		this._arrayBuffer =
			e || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var g = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._vertices = a ? new cc.Vertex2F(a.x, a.y, e, f) : new cc.Vertex2F(0, 0, e, f);
		this._colors = b ? cc.color(b.r, b.g, b.b, b.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
		this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
	a = cc.V2F_C4B_T2F.prototype;
	a._getVertices = function() {
		return this._vertices
	};
	a._setVertices = function(a) {
		this._vertices.x = a.x;
		this._vertices.y = a.y
	};
	a._getColor = function() {
		return this._colors
	};
	a._setColor = function(a) {
		var b = this._colors;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		b.a = a.a
	};
	a._getTexCoords = function() {
		return this._texCoords
	};
	a._setTexCoords = function(a) {
		this._texCoords.u = a.u;
		this._texCoords.v = a.v
	};
	cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
	cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
	cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
	cc.V2F_C4B_T2F_Triangle = function(a, b, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var g = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
		this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V2F_C4B_T2F(null, null, null, e, f);
		this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, e, f + g) : new cc.V2F_C4B_T2F(null, null, null, e, f + g);
		this._c = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 2 * g) : new cc.V2F_C4B_T2F(null,
			null, null, e, f + 2 * g)
	};
	cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
	a = cc.V2F_C4B_T2F_Triangle.prototype;
	a._getA = function() {
		return this._a
	};
	a._setA = function(a) {
		var b = this._a;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getB = function() {
		return this._b
	};
	a._setB = function(a) {
		var b = this._b;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	a._getC = function() {
		return this._c
	};
	a._setC = function(a) {
		var b = this._c;
		b.vertices = a.vertices;
		b.colors = a.colors;
		b.texCoords = a.texCoords
	};
	cc.defineGetterSetter(a, "a", a._getA, a._setA);
	cc.defineGetterSetter(a, "b", a._getB, a._setB);
	cc.defineGetterSetter(a, "c", a._getC, a._setC)
};
cc._tmp.PrototypeColor = function() {
	var a = cc.color;
	a._getWhite = function() {
		return a(255, 255, 255)
	};
	a._getYellow = function() {
		return a(255, 255, 0)
	};
	a._getBlue = function() {
		return a(0, 0, 255)
	};
	a._getGreen = function() {
		return a(0, 255, 0)
	};
	a._getRed = function() {
		return a(255, 0, 0)
	};
	a._getMagenta = function() {
		return a(255, 0, 255)
	};
	a._getBlack = function() {
		return a(0, 0, 0)
	};
	a._getOrange = function() {
		return a(255, 127, 0)
	};
	a._getGray = function() {
		return a(166, 166, 166)
	};
	cc.defineGetterSetter(a, "WHITE", a._getWhite);
	cc.defineGetterSetter(a,
		"YELLOW", a._getYellow);
	cc.defineGetterSetter(a, "BLUE", a._getBlue);
	cc.defineGetterSetter(a, "GREEN", a._getGreen);
	cc.defineGetterSetter(a, "RED", a._getRed);
	cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
	cc.defineGetterSetter(a, "BLACK", a._getBlack);
	cc.defineGetterSetter(a, "ORANGE", a._getOrange);
	cc.defineGetterSetter(a, "GRAY", a._getGray);
	cc.BlendFunc._disable = function() {
		return new cc.BlendFunc(cc.ONE, cc.ZERO)
	};
	cc.BlendFunc._alphaPremultiplied = function() {
		return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._alphaNonPremultiplied = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._additive = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
	};
	cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, c, b, d) {
	this.r = a || 0;
	this.g = c || 0;
	this.b = b || 0;
	this.a = null == d ? 255 : d
};
cc.color = function(a, c, b, d) {
	return void 0 === a ? {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	} : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
		r: a.r,
		g: a.g,
		b: a.b,
		a: null == a.a ? 255 : a.a
	} : {
		r: a,
		g: c,
		b: b,
		a: null == d ? 255 : d
	}
};
cc.colorEqual = function(a, c) {
	return a.r === c.r && a.g === c.g && a.b === c.b
};
cc.Acceleration = function(a, c, b, d) {
	this.x = a || 0;
	this.y = c || 0;
	this.z = b || 0;
	this.timestamp = d || 0
};
cc.Vertex2F = function(a, c) {
	this.x = a || 0;
	this.y = c || 0
};
cc.vertex2 = function(a, c) {
	return new cc.Vertex2F(a, c)
};
cc.Vertex3F = function(a, c, b) {
	this.x = a || 0;
	this.y = c || 0;
	this.z = b || 0
};
cc.vertex3 = function(a, c, b) {
	return new cc.Vertex3F(a, c, b)
};
cc.Tex2F = function(a, c) {
	this.u = a || 0;
	this.v = c || 0
};
cc.tex2 = function(a, c) {
	return new cc.Tex2F(a, c)
};
cc.BlendFunc = function(a, c) {
	this.src = a;
	this.dst = c
};
cc.blendFuncDisable = function() {
	return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
	a = a.replace(/^#?/, "0x");
	a = parseInt(a);
	return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
	var c = a.r.toString(16),
		b = a.g.toString(16),
		d = a.b.toString(16);
	return "#" + (16 > a.r ? "0" + c : c) + (16 > a.g ? "0" + b : b) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
	_keyMapTb: null,
	_valueMapTb: null,
	__currId: 0,
	ctor: function() {
		this._keyMapTb = {};
		this._valueMapTb = {};
		this.__currId = 2 << (0 | 10 * Math.random())
	},
	__getKey: function() {
		this.__currId++;
		return "key_" + this.__currId
	},
	setObject: function(a, c) {
		if(null != c) {
			var b = this.__getKey();
			this._keyMapTb[b] = c;
			this._valueMapTb[b] = a
		}
	},
	objectForKey: function(a) {
		if(null == a) return null;
		var c = this._keyMapTb,
			b;
		for(b in c)
			if(c[b] === a) return this._valueMapTb[b];
		return null
	},
	valueForKey: function(a) {
		return this.objectForKey(a)
	},
	removeObjectForKey: function(a) {
		if(null != a) {
			var c = this._keyMapTb,
				b;
			for(b in c)
				if(c[b] === a) {
					delete this._valueMapTb[b];
					delete c[b];
					break
				}
		}
	},
	removeObjectsForKeys: function(a) {
		if(null != a)
			for(var c = 0; c < a.length; c++) this.removeObjectForKey(a[c])
	},
	allKeys: function() {
		var a = [],
			c = this._keyMapTb,
			b;
		for(b in c) a.push(c[b]);
		return a
	},
	removeAllObjects: function() {
		this._keyMapTb = {};
		this._valueMapTb = {}
	},
	count: function() {
		return this.allKeys().length
	}
});
cc.FontDefinition = function(a) {
	this.fontName = "Arial";
	this.fontSize = 12;
	this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
	this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
	this.fillStyle = cc.color(255, 255, 255, 255);
	this.boundingHeight = this.boundingWidth = 0;
	this.strokeEnabled = !1;
	this.strokeStyle = cc.color(255, 255, 255, 255);
	this.lineWidth = 1;
	this.fontWeight = this.fontStyle = this.lineHeight = "normal";
	this.shadowEnabled = !1;
	this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
	this.shadowOpacity = 1;
	if(a && a instanceof Object)
		for(var c in a) this[c] =
			a[c]
};
cc.FontDefinition.prototype._getCanvasFontStr = function() {
	return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (this.lineHeight.charAt ? this.lineHeight : this.lineHeight + "px") + " '" + this.fontName + "'"
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
	init: function() {
		this.html = document.getElementsByTagName("html")[0]
	},
	availWidth: function(a) {
		return a && a !== this.html ? a.clientWidth : window.innerWidth
	},
	availHeight: function(a) {
		return a && a !== this.html ? a.clientHeight : window.innerHeight
	},
	meta: {
		width: "device-width",
		"user-scalable": "no"
	},
	adaptationType: cc.sys.browserType
}; -
1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch(cc.__BrowserGetter.adaptationType) {
	case cc.sys.BROWSER_TYPE_SAFARI:
		cc.__BrowserGetter.meta["minimal-ui"] = "true";
		cc.__BrowserGetter.availWidth = function(a) {
			return a.clientWidth
		};
		cc.__BrowserGetter.availHeight = function(a) {
			return a.clientHeight
		};
		break;
	case cc.sys.BROWSER_TYPE_CHROME:
		cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
			return cc.view._targetDensityDPI
		});
	case cc.sys.BROWSER_TYPE_SOUGOU:
	case cc.sys.BROWSER_TYPE_UC:
		cc.__BrowserGetter.availWidth = function(a) {
			return a.clientWidth
		};
		cc.__BrowserGetter.availHeight = function(a) {
			return a.clientHeight
		};
		break;
	case cc.sys.BROWSER_TYPE_MIUI:
		cc.__BrowserGetter.init = function(a) {
			if(!a.__resizeWithBrowserSize) {
				var c = function() {
					a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy);
					window.removeEventListener("resize", c, !1)
				};
				window.addEventListener("resize", c, !1)
			}
		}
}
cc.EGLView = cc.Class.extend({
	_delegate: null,
	_frameSize: null,
	_designResolutionSize: null,
	_originalDesignResolutionSize: null,
	_viewPortRect: null,
	_visibleRect: null,
	_retinaEnabled: !1,
	_autoFullScreen: !0,
	_devicePixelRatio: 1,
	_viewName: "",
	_resizeCallback: null,
	_scaleX: 1,
	_originalScaleX: 1,
	_scaleY: 1,
	_originalScaleY: 1,
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_resolutionPolicy: null,
	_rpExactFit: null,
	_rpShowAll: null,
	_rpNoBorder: null,
	_rpFixedHeight: null,
	_rpFixedWidth: null,
	_initialized: !1,
	_captured: !1,
	_wnd: null,
	_hDC: null,
	_hRC: null,
	_supportTouch: !1,
	_contentTranslateLeftTop: null,
	_frame: null,
	_frameZoomFactor: 1,
	__resizeWithBrowserSize: !1,
	_isAdjustViewPort: !0,
	_targetDensityDPI: null,
	ctor: function() {
		var a = document,
			c = cc.ContainerStrategy,
			b = cc.ContentStrategy;
		cc.__BrowserGetter.init(this);
		this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
		this._frameSize = cc.size(0, 0);
		this._initFrameSize();
		var a = cc._canvas.width,
			d = cc._canvas.height;
		this._designResolutionSize = cc.size(a, d);
		this._originalDesignResolutionSize =
			cc.size(a, d);
		this._viewPortRect = cc.rect(0, 0, a, d);
		this._visibleRect = cc.rect(0, 0, a, d);
		this._contentTranslateLeftTop = {
			left: 0,
			top: 0
		};
		this._viewName = "Cocos2dHTML5";
		a = cc.sys;
		this.enableRetina(a.os === a.OS_IOS || a.os === a.OS_OSX);
		cc.visibleRect && cc.visibleRect.init(this._visibleRect);
		this._rpExactFit = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, b.EXACT_FIT);
		this._rpShowAll = new cc.ResolutionPolicy(c.PROPORTION_TO_FRAME, b.SHOW_ALL);
		this._rpNoBorder = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, b.NO_BORDER);
		this._rpFixedHeight =
			new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, b.FIXED_HEIGHT);
		this._rpFixedWidth = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, b.FIXED_WIDTH);
		this._hDC = cc._canvas;
		this._hRC = cc._renderContext;
		this._targetDensityDPI = cc.DENSITYDPI_HIGH
	},
	_resizeEvent: function() {
		var a;
		a = this.setDesignResolutionSize ? this : cc.view;
		var c = a._frameSize.width,
			b = a._frameSize.height;
		a._initFrameSize();
		if(a._frameSize.width !== c || a._frameSize.height !== b) a._resizeCallback && a._resizeCallback.call(), c = a._originalDesignResolutionSize.width, b =
			a._originalDesignResolutionSize.height, 0 < c && a.setDesignResolutionSize(c, b, a._resolutionPolicy)
	},
	setTargetDensityDPI: function(a) {
		this._targetDensityDPI = a;
		this._setViewPortMeta()
	},
	getTargetDensityDPI: function() {
		return this._targetDensityDPI
	},
	resizeWithBrowserSize: function(a) {
		a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, cc._addEventListener(window, "resize", this._resizeEvent), cc._addEventListener(window, "orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent))
	},
	setResizeCallback: function(a) {
		if(cc.isFunction(a) || null == a) this._resizeCallback = a
	},
	_initFrameSize: function() {
		var a = this._frameSize;
		a.width = cc.__BrowserGetter.availWidth(this._frame);
		a.height = cc.__BrowserGetter.availHeight(this._frame)
	},
	_adjustSizeKeepCanvasSize: function() {
		var a = this._originalDesignResolutionSize.width,
			c = this._originalDesignResolutionSize.height;
		0 < a && this.setDesignResolutionSize(a,
			c, this._resolutionPolicy)
	},
	_setViewPortMeta: function() {
		if(this._isAdjustViewPort) {
			var a = document.getElementById("cocosMetaElement");
			a && document.head.removeChild(a);
			var c, b = (a = document.getElementsByName("viewport")) ? a[0] : null,
				d, a = cc.newElement("meta");
			a.id = "cocosMetaElement";
			a.name = "viewport";
			a.content = "";
			c = cc.__BrowserGetter.meta;
			d = b ? b.content : "";
			for(var e in c) RegExp(e).test(d) || (d += "," + e + "\x3d" + c[e]);
			/^,/.test(d) && (d = d.substr(1));
			a.content = d;
			b && (b.content = d);
			document.head.appendChild(a)
		}
	},
	_setScaleXYForRenderTexture: function() {
		var a =
			cc.contentScaleFactor();
		this._scaleY = this._scaleX = a
	},
	_resetScale: function() {
		this._scaleX = this._originalScaleX;
		this._scaleY = this._originalScaleY
	},
	_adjustSizeToBrowser: function() {},
	initialize: function() {
		this._initialized = !0
	},
	adjustViewPort: function(a) {
		this._isAdjustViewPort = a
	},
	enableRetina: function(a) {
		this._retinaEnabled = a ? !0 : !1
	},
	isRetinaEnabled: function() {
		return this._retinaEnabled
	},
	enableAutoFullScreen: function(a) {
		this._autoFullScreen = a ? !0 : !1
	},
	isAutoFullScreenEnabled: function() {
		return this._autoFullScreen
	},
	end: function() {},
	isOpenGLReady: function() {
		return null !== this._hDC && null !== this._hRC
	},
	setFrameZoomFactor: function(a) {
		this._frameZoomFactor = a;
		this.centerWindow();
		cc.director.setProjection(cc.director.getProjection())
	},
	swapBuffers: function() {},
	setIMEKeyboardState: function(a) {},
	setContentTranslateLeftTop: function(a, c) {
		this._contentTranslateLeftTop = {
			left: a,
			top: c
		}
	},
	getContentTranslateLeftTop: function() {
		return this._contentTranslateLeftTop
	},
	getFrameSize: function() {
		return cc.size(this._frameSize.width, this._frameSize.height)
	},
	setFrameSize: function(a, c) {
		this._frameSize.width = a;
		this._frameSize.height = c;
		this._frame.style.width = a + "px";
		this._frame.style.height = c + "px";
		this._resizeEvent();
		cc.director.setProjection(cc.director.getProjection())
	},
	centerWindow: function() {},
	getVisibleSize: function() {
		return cc.size(this._visibleRect.width, this._visibleRect.height)
	},
	getVisibleOrigin: function() {
		return cc.p(this._visibleRect.x, this._visibleRect.y)
	},
	canSetContentScaleFactor: function() {
		return !0
	},
	getResolutionPolicy: function() {
		return this._resolutionPolicy
	},
	setResolutionPolicy: function(a) {
		if(a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
		else {
			var c = cc.ResolutionPolicy;
			a === c.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
			a === c.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
			a === c.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
			a === c.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
			a === c.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
		}
	},
	setDesignResolutionSize: function(a, c, b) {
		if(0 < a || 0 < c)
			if(this.setResolutionPolicy(b),
				b = this._resolutionPolicy) {
				b.preApply(this);
				cc.sys.isMobile && this._setViewPortMeta();
				this._initFrameSize();
				this._originalDesignResolutionSize.width = this._designResolutionSize.width = a;
				this._originalDesignResolutionSize.height = this._designResolutionSize.height = c;
				var d = b.apply(this, this._designResolutionSize);
				d.scale && 2 === d.scale.length && (this._scaleX = d.scale[0], this._scaleY = d.scale[1]);
				d.viewport && (a = this._viewPortRect, c = this._visibleRect, d = d.viewport, a.x = d.x, a.y = d.y, a.width = d.width, a.height = d.height,
					c.x = -a.x / this._scaleX, c.y = -a.y / this._scaleY, c.width = cc._canvas.width / this._scaleX, c.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(a.x, -a.y));
				a = cc.director;
				a._winSizeInPoints.width = this._designResolutionSize.width;
				a._winSizeInPoints.height = this._designResolutionSize.height;
				b.postApply(this);
				cc.winSize.width = a._winSizeInPoints.width;
				cc.winSize.height = a._winSizeInPoints.height;
				cc._renderType === cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues());
				this._originalScaleX = this._scaleX;
				this._originalScaleY = this._scaleY;
				cc.DOM && cc.DOM._resetEGLViewDiv();
				cc.visibleRect && cc.visibleRect.init(this._visibleRect)
			} else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
		else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
	},
	getDesignResolutionSize: function() {
		return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
	},
	setViewPortInPoints: function(a, c, b, d) {
		var e = this._frameZoomFactor,
			f = this._scaleX,
			g = this._scaleY;
		cc._renderContext.viewport(a *
			f * e + this._viewPortRect.x * e, c * g * e + this._viewPortRect.y * e, b * f * e, d * g * e)
	},
	setScissorInPoints: function(a, c, b, d) {
		var e = this._frameZoomFactor,
			f = this._scaleX,
			g = this._scaleY;
		cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, c * g * e + this._viewPortRect.y * e, b * f * e, d * g * e)
	},
	isScissorEnabled: function() {
		var a = cc._renderContext;
		return a.isEnabled(a.SCISSOR_TEST)
	},
	getScissorRect: function() {
		var a = cc._renderContext,
			c = this._scaleX,
			b = this._scaleY,
			a = a.getParameter(a.SCISSOR_BOX);
		return cc.rect((a[0] - this._viewPortRect.x) /
			c, (a[1] - this._viewPortRect.y) / b, a[2] / c, a[3] / b)
	},
	setViewName: function(a) {
		null != a && 0 < a.length && (this._viewName = a)
	},
	getViewName: function() {
		return this._viewName
	},
	getViewPortRect: function() {
		return this._viewPortRect
	},
	getScaleX: function() {
		return this._scaleX
	},
	getScaleY: function() {
		return this._scaleY
	},
	getDevicePixelRatio: function() {
		return this._devicePixelRatio
	},
	convertToLocationInView: function(a, c, b) {
		return {
			x: this._devicePixelRatio * (a - b.left),
			y: this._devicePixelRatio * (b.top + b.height - c)
		}
	},
	_convertMouseToLocationInView: function(a,
		c) {
		var b = this._viewPortRect;
		a.x = (this._devicePixelRatio * (a.x - c.left) - b.x) / this._scaleX;
		a.y = (this._devicePixelRatio * (c.top + c.height - a.y) - b.y) / this._scaleY
	},
	_convertTouchesWithScale: function(a) {
		for(var c = this._viewPortRect, b = this._scaleX, d = this._scaleY, e, f, g, h = 0; h < a.length; h++) e = a[h], f = e._point, g = e._prevPoint, e._setPoint((f.x - c.x) / b, (f.y - c.y) / d), e._setPrevPoint((g.x - c.x) / b, (g.y - c.y) / d)
	}
});
cc.EGLView._getInstance = function() {
	this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
	return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
	preApply: function(a) {},
	apply: function(a, c) {},
	postApply: function(a) {},
	_setupContainer: function(a, c, b) {
		var d = a._frame;
		cc.view._autoFullScreen && cc.sys.isMobile && d === document.documentElement && cc.screen.autoFullScreen(d);
		var d = cc._canvas,
			e = cc.container;
		e.style.width = d.style.width = c + "px";
		e.style.height = d.style.height = b + "px";
		a._devicePixelRatio = 1;
		a.isRetinaEnabled() && (a._devicePixelRatio = window.devicePixelRatio || 1);
		d.width = 640;
		d.height = b / c * 640;
		a._devicePixelRatio = 640 /
			c;
		cc._renderContext.resetCache && cc._renderContext.resetCache();
		a = document.body;
		var f;
		a && (f = a.style) && (f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft ||
			"0px")
	},
	_fixContainer: function() {
		document.body.insertBefore(cc.container, document.body.firstChild);
		var a = document.body.style;
		a.width = window.innerWidth + "px";
		a.height = window.innerHeight + "px";
		a.overflow = "hidden";
		a = cc.container.style;
		a.position = "fixed";
		a.left = a.top = "0px";
		document.body.scrollTop = 0
	}
});
cc.ContentStrategy = cc.Class.extend({
	_result: {
		scale: [1, 1],
		viewport: null
	},
	_buildResult: function(a, c, b, d, e, f) {
		2 > Math.abs(a - b) && (b = a);
		2 > Math.abs(c - d) && (d = c);
		a = cc.rect(Math.round((a - b) / 2), Math.round((c - d) / 2), b, d);
		this._result.scale = [e, f];
		this._result.viewport = a;
		return this._result
	},
	preApply: function(a) {},
	apply: function(a, c) {
		return {
			scale: [1, 1]
		}
	},
	postApply: function(a) {}
});
(function() {
	var a = cc.ContainerStrategy.extend({
			apply: function(a) {
				this._setupContainer(a, a._frameSize.width, a._frameSize.height)
			}
		}),
		c = cc.ContainerStrategy.extend({
			apply: function(a, c) {
				var b = a._frameSize.width,
					d = a._frameSize.height,
					e = cc.container.style,
					n = c.width,
					p = c.height,
					s = b / n,
					q = d / p,
					t, r;
				s < q ? (t = b, r = p * s) : (t = n * q, r = d);
				n = Math.round((b - t) / 2);
				r = Math.round((d - r) / 2);
				this._setupContainer(a, b - 2 * n, d - 2 * r);
				e.marginLeft = n + "px";
				e.marginRight = n + "px";
				e.marginTop = r + "px";
				e.marginBottom = r + "px"
			}
		});
	a.extend({
		preApply: function(a) {
			this._super(a);
			a._frame = document.documentElement
		},
		apply: function(a) {
			this._super(a);
			this._fixContainer()
		}
	});
	c.extend({
		preApply: function(a) {
			this._super(a);
			a._frame = document.documentElement
		},
		apply: function(a, c) {
			this._super(a, c);
			this._fixContainer()
		}
	});
	var b = cc.ContainerStrategy.extend({
		apply: function(a) {
			this._setupContainer(a, cc._canvas.width, cc._canvas.height)
		}
	});
	cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
	cc.ContainerStrategy.PROPORTION_TO_FRAME = new c;
	cc.ContainerStrategy.ORIGINAL_CONTAINER = new b;
	var a = cc.ContentStrategy.extend({
			apply: function(a,
				c) {
				var b = cc._canvas.width,
					d = cc._canvas.height;
				return this._buildResult(b, d, b, d, b / c.width, d / c.height)
			}
		}),
		c = cc.ContentStrategy.extend({
			apply: function(a, c) {
				var b = cc._canvas.width,
					d = cc._canvas.height,
					e = c.width,
					n = c.height,
					p = b / e,
					s = d / n,
					q = 0,
					t, r;
				p < s ? (q = p, t = b, r = n * q) : (q = s, t = e * q, r = d);
				return this._buildResult(b, d, t, r, q, q)
			}
		}),
		b = cc.ContentStrategy.extend({
			apply: function(a, c) {
				var b = cc._canvas.width,
					d = cc._canvas.height,
					e = c.width,
					n = c.height,
					p = b / e,
					s = d / n,
					q, t, r;
				p < s ? (q = s, t = e * q, r = d) : (q = p, t = b, r = n * q);
				return this._buildResult(b,
					d, t, r, q, q)
			}
		}),
		d = cc.ContentStrategy.extend({
			apply: function(a, c) {
				var b = cc._canvas.width,
					d = cc._canvas.height,
					e = d / c.height;
				return this._buildResult(b, d, b, d, e, e)
			},
			postApply: function(a) {
				cc.director._winSizeInPoints = a.getVisibleSize()
			}
		}),
		e = cc.ContentStrategy.extend({
			apply: function(a, c) {
				var b = cc._canvas.width,
					d = cc._canvas.height,
					e = b / c.width;
				return this._buildResult(b, d, b, d, e, e)
			},
			postApply: function(a) {
				cc.director._winSizeInPoints = a.getVisibleSize()
			}
		});
	cc.ContentStrategy.EXACT_FIT = new a;
	cc.ContentStrategy.SHOW_ALL =
		new c;
	cc.ContentStrategy.NO_BORDER = new b;
	cc.ContentStrategy.FIXED_HEIGHT = new d;
	cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({
	_containerStrategy: null,
	_contentStrategy: null,
	ctor: function(a, c) {
		this.setContainerStrategy(a);
		this.setContentStrategy(c)
	},
	preApply: function(a) {
		this._containerStrategy.preApply(a);
		this._contentStrategy.preApply(a)
	},
	apply: function(a, c) {
		this._containerStrategy.apply(a, c);
		return this._contentStrategy.apply(a, c)
	},
	postApply: function(a) {
		this._containerStrategy.postApply(a);
		this._contentStrategy.postApply(a)
	},
	setContainerStrategy: function(a) {
		a instanceof cc.ContainerStrategy &&
			(this._containerStrategy = a)
	},
	setContentStrategy: function(a) {
		a instanceof cc.ContentStrategy && (this._contentStrategy = a)
	}
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
	_supportsFullScreen: !1,
	_preOnFullScreenChange: null,
	_touchEvent: "",
	_fn: null,
	_fnMap: [
		["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
		["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
		["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
		["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
			"mozFullScreenElement"
		],
		["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
	],
	init: function() {
		this._fn = {};
		var a, c, b = this._fnMap,
			d;
		a = 0;
		for(l = b.length; a < l; a++)
			if((c = b[a]) && c[1] in document) {
				a = 0;
				for(d = c.length; a < d; a++) this._fn[b[0][a]] = c[a];
				break
			}
		this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
		this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
	},
	fullScreen: function() {
		return this._supportsFullScreen && document[this._fn.fullscreenElement]
	},
	requestFullScreen: function(a, c) {
		if(this._supportsFullScreen) {
			a = a || document.documentElement;
			if(c) {
				var b = this._fn.fullscreenchange;
				this._preOnFullScreenChange && document.removeEventListener(b, this._preOnFullScreenChange);
				this._preOnFullScreenChange = c;
				cc._addEventListener(document, b, c, !1)
			}
			return a[this._fn.requestFullscreen]()
		}
	},
	exitFullScreen: function() {
		return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
	},
	autoFullScreen: function(a, c) {
		function b() {
			e.requestFullScreen(a, c);
			d.removeEventListener(e._touchEvent,
				b)
		}
		a = a || document.body;
		var d = cc._canvas || a,
			e = this;
		this.requestFullScreen(a, c);
		cc._addEventListener(d, this._touchEvent, b)
	}
};
cc.screen.init();
cc.visibleRect = {
	topLeft: cc.p(0, 0),
	topRight: cc.p(0, 0),
	top: cc.p(0, 0),
	bottomLeft: cc.p(0, 0),
	bottomRight: cc.p(0, 0),
	bottom: cc.p(0, 0),
	center: cc.p(0, 0),
	left: cc.p(0, 0),
	right: cc.p(0, 0),
	width: 0,
	height: 0,
	init: function(a) {
		var c = this.width = a.width,
			b = this.height = a.height,
			d = a.x;
		a = a.y;
		var e = a + b,
			f = d + c;
		this.topLeft.x = d;
		this.topLeft.y = e;
		this.topRight.x = f;
		this.topRight.y = e;
		this.top.x = d + c / 2;
		this.top.y = e;
		this.bottomLeft.x = d;
		this.bottomLeft.y = a;
		this.bottomRight.x = f;
		this.bottomRight.y = a;
		this.bottom.x = d + c / 2;
		this.bottom.y =
			a;
		this.center.x = d + c / 2;
		this.center.y = a + b / 2;
		this.left.x = d;
		this.left.y = a + b / 2;
		this.right.x = f;
		this.right.y = a + b / 2
	}
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
	_mousePressed: !1,
	_isRegisterEvent: !1,
	_preTouchPoint: cc.p(0, 0),
	_prevMousePoint: cc.p(0, 0),
	_preTouchPool: [],
	_preTouchPoolPointer: 0,
	_touches: [],
	_touchesIntegerDict: {},
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_accelEnabled: !1,
	_accelInterval: 1 / 30,
	_accelMinus: 1,
	_accelCurTime: 0,
	_acceleration: null,
	_accelDeviceEvent: null,
	_getUnUsedIndex: function() {
		for(var a = this._indexBitsUsed, c = 0; c < this._maxTouches; c++) {
			if(!(a & 1)) return this._indexBitsUsed |= 1 << c, c;
			a >>= 1
		}
		return -1
	},
	_removeUsedIndexBit: function(a) {
		0 > a ||
			a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
	},
	_glView: null,
	handleTouchesBegin: function(a) {
		for(var c, b, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; g < h; g++)
			if(c = a[g], d = c.getID(), b = f[d], null == b) {
				var k = this._getUnUsedIndex(); - 1 === k ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, k) : (b = this._touches[k] = new cc.Touch(c._point.x, c._point.y, c.getID()), b._setPrevPoint(c._prevPoint), f[d] = k, e.push(b))
			}
		0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode =
			cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesMove: function(a) {
		for(var c, b, d = [], e = this._touches, f = 0, g = a.length; f < g; f++) c = a[f], b = c.getID(), b = this._touchesIntegerDict[b], null != b && e[b] && (e[b]._setPoint(c._point), e[b]._setPrevPoint(c._prevPoint), d.push(e[b]));
		0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesEnd: function(a) {
		a = this.getSetOfTouchesEndOrCancel(a);
		0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesCancel: function(a) {
		a = this.getSetOfTouchesEndOrCancel(a);
		0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
	},
	getSetOfTouchesEndOrCancel: function(a) {
		for(var c, b, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, k = a.length; h <
			k; h++) c = a[h], d = c.getID(), b = g[d], null != b && f[b] && (f[b]._setPoint(c._point), f[b]._setPrevPoint(c._prevPoint), e.push(f[b]), this._removeUsedIndexBit(b), delete g[d]);
		return e
	},
	getHTMLElementPosition: function(a) {
		var c = document.documentElement,
			b = window,
			d = null,
			d = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
				left: 0,
				top: 0,
				width: a.width,
				height: a.height
			} : {
				left: 0,
				top: 0,
				width: parseInt(a.style.width),
				height: parseInt(a.style.height)
			};
		return {
			left: d.left + b.pageXOffset -
				c.clientLeft,
			top: d.top + b.pageYOffset - c.clientTop,
			width: d.width,
			height: d.height
		}
	},
	getPreTouch: function(a) {
		for(var c = null, b = this._preTouchPool, d = a.getID(), e = b.length - 1; 0 <= e; e--)
			if(b[e].getID() === d) {
				c = b[e];
				break
			}
		c || (c = a);
		return c
	},
	setPreTouch: function(a) {
		for(var c = !1, b = this._preTouchPool, d = a.getID(), e = b.length - 1; 0 <= e; e--)
			if(b[e].getID() === d) {
				b[e] = a;
				c = !0;
				break
			}
		c || (50 >= b.length ? b.push(a) : (b[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
	},
	getTouchByXY: function(a,
		c, b) {
		var d = this._preTouchPoint;
		a = this._glView.convertToLocationInView(a, c, b);
		c = new cc.Touch(a.x, a.y);
		c._setPrevPoint(d.x, d.y);
		d.x = a.x;
		d.y = a.y;
		return c
	},
	getMouseEvent: function(a, c, b) {
		var d = this._prevMousePoint;
		this._glView._convertMouseToLocationInView(a, c);
		c = new cc.EventMouse(b);
		c.setLocation(a.x, a.y);
		c._setPrevCursor(d.x, d.y);
		d.x = a.x;
		d.y = a.y;
		return c
	},
	getPointByEvent: function(a, c) {
		if(null != a.pageX) return {
			x: a.pageX,
			y: a.pageY
		};
		c.left -= document.body.scrollLeft;
		c.top -= document.body.scrollTop;
		return {
			x: a.clientX,
			y: a.clientY
		}
	},
	getTouchesByEvent: function(a, c) {
		for(var b = [], d = this._glView, e, f, g = this._preTouchPoint, h = a.changedTouches.length, k = 0; k < h; k++)
			if(e = a.changedTouches[k]) {
				var m;
				m = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? d.convertToLocationInView(e.pageX, e.pageY, c) : d.convertToLocationInView(e.clientX, e.clientY, c);
				null != e.identifier ? (e = new cc.Touch(m.x, m.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(m.x, m.y), e._setPrevPoint(g.x, g.y));
				g.x = m.x;
				g.y = m.y;
				b.push(e)
			}
		return b
	},
	registerSystemEvent: function(a) {
		if(!this._isRegisterEvent) {
			this._glView = cc.view;
			var c = this,
				b = "mouse" in cc.sys.capabilities,
				d = "touches" in cc.sys.capabilities,
				e = !1;
			cc.sys.isMobile && (e = !0);
			b && (cc._addEventListener(window, "mousedown", function() {
				c._mousePressed = !0
			}, !1), cc._addEventListener(window, "mouseup", function(b) {
				if(!e) {
					var d = c._mousePressed;
					c._mousePressed = !1;
					if(d) {
						var d = c.getHTMLElementPosition(a),
							f = c.getPointByEvent(b, d);
						cc.rectContainsPoint(new cc.Rect(d.left,
							d.top, d.width, d.height), f) || (c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, d)]), d = c.getMouseEvent(f, d, cc.EventMouse.UP), d.setButton(b.button), cc.eventManager.dispatchEvent(d))
					}
				}
			}, !1), cc._addEventListener(a, "mousedown", function(b) {
				if(!e) {
					c._mousePressed = !0;
					var d = c.getHTMLElementPosition(a),
						f = c.getPointByEvent(b, d);
					c.handleTouchesBegin([c.getTouchByXY(f.x, f.y, d)]);
					d = c.getMouseEvent(f, d, cc.EventMouse.DOWN);
					d.setButton(b.button);
					cc.eventManager.dispatchEvent(d);
					a.focus()
				}
			}, !1), cc._addEventListener(a, "mouseup",
				function(b) {
					if(!e) {
						c._mousePressed = !1;
						var d = c.getHTMLElementPosition(a),
							f = c.getPointByEvent(b, d);
						c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, d)]);
						d = c.getMouseEvent(f, d, cc.EventMouse.UP);
						d.setButton(b.button);
						cc.eventManager.dispatchEvent(d);
						b.stopPropagation();
						b.preventDefault()
					}
				}, !1), cc._addEventListener(a, "mousemove", function(b) {
				if(!e) {
					var d = c.getHTMLElementPosition(a),
						f = c.getPointByEvent(b, d);
					c.handleTouchesMove([c.getTouchByXY(f.x, f.y, d)]);
					d = c.getMouseEvent(f, d, cc.EventMouse.MOVE);
					c._mousePressed ?
						d.setButton(b.button) : d.setButton(null);
					cc.eventManager.dispatchEvent(d);
					b.stopPropagation();
					b.preventDefault()
				}
			}, !1), cc._addEventListener(a, "mousewheel", function(b) {
				var d = c.getHTMLElementPosition(a),
					e = c.getPointByEvent(b, d),
					d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
				d.setButton(b.button);
				d.setScrollData(0, b.wheelDelta);
				cc.eventManager.dispatchEvent(d);
				b.stopPropagation();
				b.preventDefault()
			}, !1), cc._addEventListener(a, "DOMMouseScroll", function(b) {
				var d = c.getHTMLElementPosition(a),
					e = c.getPointByEvent(b,
						d),
					d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
				d.setButton(b.button);
				d.setScrollData(0, -120 * b.detail);
				cc.eventManager.dispatchEvent(d);
				b.stopPropagation();
				b.preventDefault()
			}, !1));
			if(window.navigator.msPointerEnabled) {
				var b = {
						MSPointerDown: c.handleTouchesBegin,
						MSPointerMove: c.handleTouchesMove,
						MSPointerUp: c.handleTouchesEnd,
						MSPointerCancel: c.handleTouchesCancel
					},
					f;
				for(f in b)(function(b, d) {
					cc._addEventListener(a, b, function(b) {
						var e = c.getHTMLElementPosition(a);
						e.left -= document.documentElement.scrollLeft;
						e.top -= document.documentElement.scrollTop;
						d.call(c, [c.getTouchByXY(b.clientX, b.clientY, e)]);
						b.stopPropagation()
					}, !1)
				})(f, b[f])
			}
			d && (cc._addEventListener(a, "touchstart", function(b) {
				if(b.changedTouches) {
					var d = c.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					c.handleTouchesBegin(c.getTouchesByEvent(b, d));
					b.stopPropagation();
					b.preventDefault();
					a.focus()
				}
			}, !1), cc._addEventListener(a, "touchmove", function(b) {
				if(b.changedTouches) {
					var d = c.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					c.handleTouchesMove(c.getTouchesByEvent(b, d));
					b.stopPropagation();
					b.preventDefault()
				}
			}, !1), cc._addEventListener(a, "touchend", function(b) {
				if(b.changedTouches) {
					var d = c.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					c.handleTouchesEnd(c.getTouchesByEvent(b, d));
					b.stopPropagation();
					b.preventDefault()
				}
			}, !1), cc._addEventListener(a, "touchcancel", function(b) {
				if(b.changedTouches) {
					var d = c.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					c.handleTouchesCancel(c.getTouchesByEvent(b, d));
					b.stopPropagation();
					b.preventDefault()
				}
			}, !1));
			this._registerKeyboardEvent();
			this._registerAccelerometerEvent();
			this._isRegisterEvent = !0
		}
	},
	_registerKeyboardEvent: function() {},
	_registerAccelerometerEvent: function() {},
	update: function(a) {
		this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
		this._accelCurTime += a
	}
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
	this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelCurTime = 0, a.scheduleUpdate(this))
};
_p.setAccelerometerInterval = function(a) {
	this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
	cc._addEventListener(cc._canvas, "keydown", function(a) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
		a.stopPropagation();
		a.preventDefault()
	}, !1);
	cc._addEventListener(cc._canvas, "keyup", function(a) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
		a.stopPropagation();
		a.preventDefault()
	}, !1)
};
_p._registerAccelerometerEvent = function() {
	var a = window;
	this._acceleration = new cc.Acceleration;
	this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
	cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
	var c = this._accelDeviceEvent === a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
		b = navigator.userAgent;
	if(/Android/.test(b) || /Adr/.test(b) && cc.sys.browserType === cc.BROWSER_TYPE_UC) this._minus = -1;
	cc._addEventListener(a, c, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
	var c = window;
	if(this._accelEnabled) {
		var b = this._acceleration,
			d, e, f;
		this._accelDeviceEvent === window.DeviceMotionEvent ? (f = a.accelerationIncludingGravity, d = this._accelMinus * f.x * 0.1, e = this._accelMinus * f.y * 0.1, f = 0.1 * f.z) : (d = a.gamma / 90 * 0.981, e = 0.981 * -(a.beta / 90), f = a.alpha / 90 * 0.981);
		cc.sys.os === cc.sys.OS_ANDROID ? (b.x = -d, b.y = -e) : (b.x = d, b.y = e);
		b.z = f;
		b.timestamp = a.timeStamp || Date.now();
		a = b.x;
		c.orientation === cc.UIInterfaceOrientationLandscapeRight ? (b.x = -b.y, b.y = a) : c.orientation === cc.UIInterfaceOrientationLandscapeLeft ?
			(b.x = b.y, b.y = -a) : c.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (b.x = -b.x, b.y = -b.y)
	}
};
delete _p;
cc.AffineTransform = function(a, c, b, d, e, f) {
	this.a = a;
	this.b = c;
	this.c = b;
	this.d = d;
	this.tx = e;
	this.ty = f
};
cc.affineTransformMake = function(a, c, b, d, e, f) {
	return {
		a: a,
		b: c,
		c: b,
		d: d,
		tx: e,
		ty: f
	}
};
cc.pointApplyAffineTransform = function(a, c, b) {
	var d;
	void 0 === b ? (b = c, d = a.x, a = a.y) : (d = a, a = c);
	return {
		x: b.a * d + b.c * a + b.tx,
		y: b.b * d + b.d * a + b.ty
	}
};
cc._pointApplyAffineTransform = function(a, c, b) {
	return cc.pointApplyAffineTransform(a, c, b)
};
cc.sizeApplyAffineTransform = function(a, c) {
	return {
		width: c.a * a.width + c.c * a.height,
		height: c.b * a.width + c.d * a.height
	}
};
cc.affineTransformMakeIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.affineTransformIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.rectApplyAffineTransform = function(a, c) {
	var b = cc.rectGetMinY(a),
		d = cc.rectGetMinX(a),
		e = cc.rectGetMaxX(a),
		f = cc.rectGetMaxY(a),
		g = cc.pointApplyAffineTransform(d, b, c),
		b = cc.pointApplyAffineTransform(e, b, c),
		d = cc.pointApplyAffineTransform(d, f, c),
		h = cc.pointApplyAffineTransform(e, f, c),
		e = Math.min(g.x, b.x, d.x, h.x),
		f = Math.max(g.x, b.x, d.x, h.x),
		k = Math.min(g.y, b.y, d.y, h.y),
		g = Math.max(g.y, b.y, d.y, h.y);
	return cc.rect(e, k, f - e, g - k)
};
cc._rectApplyAffineTransformIn = function(a, c) {
	var b = cc.rectGetMinY(a),
		d = cc.rectGetMinX(a),
		e = cc.rectGetMaxX(a),
		f = cc.rectGetMaxY(a),
		g = cc.pointApplyAffineTransform(d, b, c),
		b = cc.pointApplyAffineTransform(e, b, c),
		d = cc.pointApplyAffineTransform(d, f, c),
		h = cc.pointApplyAffineTransform(e, f, c),
		e = Math.min(g.x, b.x, d.x, h.x),
		f = Math.max(g.x, b.x, d.x, h.x),
		k = Math.min(g.y, b.y, d.y, h.y),
		g = Math.max(g.y, b.y, d.y, h.y);
	a.x = e;
	a.y = k;
	a.width = f - e;
	a.height = g - k;
	return a
};
cc.affineTransformTranslate = function(a, c, b) {
	return {
		a: a.a,
		b: a.b,
		c: a.c,
		d: a.d,
		tx: a.tx + a.a * c + a.c * b,
		ty: a.ty + a.b * c + a.d * b
	}
};
cc.affineTransformScale = function(a, c, b) {
	return {
		a: a.a * c,
		b: a.b * c,
		c: a.c * b,
		d: a.d * b,
		tx: a.tx,
		ty: a.ty
	}
};
cc.affineTransformRotate = function(a, c) {
	var b = Math.sin(c),
		d = Math.cos(c);
	return {
		a: a.a * d + a.c * b,
		b: a.b * d + a.d * b,
		c: a.c * d - a.a * b,
		d: a.d * d - a.b * b,
		tx: a.tx,
		ty: a.ty
	}
};
cc.affineTransformConcat = function(a, c) {
	return {
		a: a.a * c.a + a.b * c.c,
		b: a.a * c.b + a.b * c.d,
		c: a.c * c.a + a.d * c.c,
		d: a.c * c.b + a.d * c.d,
		tx: a.tx * c.a + a.ty * c.c + c.tx,
		ty: a.tx * c.b + a.ty * c.d + c.ty
	}
};
cc.affineTransformEqualToTransform = function(a, c) {
	return a.a === c.a && a.b === c.b && a.c === c.c && a.d === c.d && a.tx === c.tx && a.ty === c.ty
};
cc.affineTransformInvert = function(a) {
	var c = 1 / (a.a * a.d - a.b * a.c);
	return {
		a: c * a.d,
		b: -c * a.b,
		c: -c * a.c,
		d: c * a.a,
		tx: c * (a.c * a.ty - a.d * a.tx),
		ty: c * (a.b * a.tx - a.a * a.ty)
	}
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
	return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, c) {
	return cc.p(a.x + c.x, a.y + c.y)
};
cc.pSub = function(a, c) {
	return cc.p(a.x - c.x, a.y - c.y)
};
cc.pMult = function(a, c) {
	return cc.p(a.x * c, a.y * c)
};
cc.pMidpoint = function(a, c) {
	return cc.pMult(cc.pAdd(a, c), 0.5)
};
cc.pDot = function(a, c) {
	return a.x * c.x + a.y * c.y
};
cc.pCross = function(a, c) {
	return a.x * c.y - a.y * c.x
};
cc.pPerp = function(a) {
	return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
	return cc.p(a.y, -a.x)
};
cc.pProject = function(a, c) {
	return cc.pMult(c, cc.pDot(a, c) / cc.pDot(c, c))
};
cc.pRotate = function(a, c) {
	return cc.p(a.x * c.x - a.y * c.y, a.x * c.y + a.y * c.x)
};
cc.pUnrotate = function(a, c) {
	return cc.p(a.x * c.x + a.y * c.y, a.y * c.x - a.x * c.y)
};
cc.pLengthSQ = function(a) {
	return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, c) {
	return cc.pLengthSQ(cc.pSub(a, c))
};
cc.pLength = function(a) {
	return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, c) {
	return cc.pLength(cc.pSub(a, c))
};
cc.pNormalize = function(a) {
	var c = cc.pLength(a);
	return 0 === c ? cc.p(a) : cc.pMult(a, 1 / c)
};
cc.pForAngle = function(a) {
	return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
	return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, c, b) {
	if(c > b) {
		var d = c;
		c = b;
		b = d
	}
	return a < c ? c : a < b ? a : b
};
cc.pClamp = function(a, c, b) {
	return cc.p(cc.clampf(a.x, c.x, b.x), cc.clampf(a.y, c.y, b.y))
};
cc.pFromSize = function(a) {
	return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, c) {
	return cc.p(c(a.x), c(a.y))
};
cc.pLerp = function(a, c, b) {
	return cc.pAdd(cc.pMult(a, 1 - b), cc.pMult(c, b))
};
cc.pFuzzyEqual = function(a, c, b) {
	return a.x - b <= c.x && c.x <= a.x + b && a.y - b <= c.y && c.y <= a.y + b ? !0 : !1
};
cc.pCompMult = function(a, c) {
	return cc.p(a.x * c.x, a.y * c.y)
};
cc.pAngleSigned = function(a, c) {
	var b = cc.pNormalize(a),
		d = cc.pNormalize(c),
		b = Math.atan2(b.x * d.y - b.y * d.x, cc.pDot(b, d));
	return Math.abs(b) < cc.POINT_EPSILON ? 0 : b
};
cc.pAngle = function(a, c) {
	var b = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(c)));
	return Math.abs(b) < cc.POINT_EPSILON ? 0 : b
};
cc.pRotateByAngle = function(a, c, b) {
	a = cc.pSub(a, c);
	var d = Math.cos(b);
	b = Math.sin(b);
	var e = a.x;
	a.x = e * d - a.y * b + c.x;
	a.y = e * b + a.y * d + c.y;
	return a
};
cc.pLineIntersect = function(a, c, b, d, e) {
	if(a.x === c.x && a.y === c.y || b.x === d.x && b.y === d.y) return !1;
	var f = c.x - a.x;
	c = c.y - a.y;
	var g = d.x - b.x;
	d = d.y - b.y;
	var h = a.x - b.x;
	a = a.y - b.y;
	b = d * f - g * c;
	e.x = g * a - d * h;
	e.y = f * a - c * h;
	if(0 === b) return 0 === e.x || 0 === e.y ? !0 : !1;
	e.x /= b;
	e.y /= b;
	return !0
};
cc.pSegmentIntersect = function(a, c, b, d) {
	var e = cc.p(0, 0);
	return cc.pLineIntersect(a, c, b, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function(a, c, b, d) {
	var e = cc.p(0, 0);
	return cc.pLineIntersect(a, c, b, d, e) ? (b = cc.p(0, 0), b.x = a.x + e.x * (c.x - a.x), b.y = a.y + e.x * (c.y - a.y), b) : cc.p(0, 0)
};
cc.pSameAs = function(a, c) {
	return null != a && null != c ? a.x === c.x && a.y === c.y : !1
};
cc.pZeroIn = function(a) {
	a.x = 0;
	a.y = 0
};
cc.pIn = function(a, c) {
	a.x = c.x;
	a.y = c.y
};
cc.pMultIn = function(a, c) {
	a.x *= c;
	a.y *= c
};
cc.pSubIn = function(a, c) {
	a.x -= c.x;
	a.y -= c.y
};
cc.pAddIn = function(a, c) {
	a.x += c.x;
	a.y += c.y
};
cc.pNormalizeIn = function(a) {
	cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, c, b, d, e) {
	e += d;
	if(!(1 >= e)) {
		c *= 0.5;
		for(var f, g = e - 1, h = d; h < e; h++) {
			f = 2 * h;
			var k = cc.p(a[2 * h], a[2 * h + 1]),
				m;
			if(0 === h) m = cc.pPerp(cc.pNormalize(cc.pSub(k, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
			else if(h === g) m = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), k)));
			else {
				m = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
				var n = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
					p = cc.pNormalize(cc.pSub(n, k)),
					s = cc.pNormalize(cc.pSub(m, k)),
					q = Math.acos(cc.pDot(p, s));
				m = q < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(p,
					s))) : q < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(p, s)) : cc.pPerp(cc.pNormalize(cc.pSub(n, m)))
			}
			m = cc.pMult(m, c);
			b[2 * f] = k.x + m.x;
			b[2 * f + 1] = k.y + m.y;
			b[2 * (f + 1)] = k.x - m.x;
			b[2 * (f + 1) + 1] = k.y - m.y
		}
		for(h = 0 === d ? 0 : d - 1; h < g; h++) f = 2 * h, a = f + 2, c = cc.vertex2(b[2 * f], b[2 * f + 1]), e = cc.vertex2(b[2 * (f + 1)], b[2 * (f + 1) + 1]), f = cc.vertex2(b[2 * a], b[2 * a]), d = cc.vertex2(b[2 * (a + 1)], b[2 * (a + 1) + 1]), c = !cc.vertexLineIntersect(c.x, c.y, d.x, d.y, e.x, e.y, f.x, f.y), !c.isSuccess && (0 > c.value || 1 < c.value) && (c.isSuccess = !0), c.isSuccess && (b[2 * a] = d.x,
			b[2 * a + 1] = d.y, b[2 * (a + 1)] = f.x, b[2 * (a + 1) + 1] = f.y)
	}
};
cc.vertexLineIntersect = function(a, c, b, d, e, f, g, h) {
	if(a === b && c === d || e === g && f === h) return {
		isSuccess: !1,
		value: 0
	};
	b -= a;
	d -= c;
	e -= a;
	f -= c;
	g -= a;
	h -= c;
	a = Math.sqrt(b * b + d * d);
	b /= a;
	d /= a;
	c = e * b + f * d;
	f = f * b - e * d;
	e = c;
	c = g * b + h * d;
	h = h * b - g * d;
	g = c;
	return f === h ? {
		isSuccess: !1,
		value: 0
	} : {
		isSuccess: !0,
		value: (g + (e - g) * h / (h - f)) / a
	}
};
cc.vertexListIsClockwise = function(a) {
	for(var c = 0, b = a.length; c < b; c++) {
		var d = a[(c + 1) % b],
			e = a[(c + 2) % b];
		if(0 < cc.pCross(cc.pSub(d, a[c]), cc.pSub(e, d))) return !1
	}
	return !0
};
cc.CGAffineToGL = function(a, c) {
	c[2] = c[3] = c[6] = c[7] = c[8] = c[9] = c[11] = c[14] = 0;
	c[10] = c[15] = 1;
	c[0] = a.a;
	c[4] = a.c;
	c[12] = a.tx;
	c[1] = a.b;
	c[5] = a.d;
	c[13] = a.ty
};
cc.GLToCGAffine = function(a, c) {
	c.a = a[0];
	c.c = a[4];
	c.tx = a[12];
	c.b = a[1];
	c.d = a[5];
	c.ty = a[13]
};
cc.Touch = cc.Class.extend({
	_point: null,
	_prevPoint: null,
	_id: 0,
	_startPointCaptured: !1,
	_startPoint: null,
	ctor: function(a, c, b) {
		this._point = cc.p(a || 0, c || 0);
		this._id = b || 0
	},
	getLocation: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getLocationX: function() {
		return this._point.x
	},
	getLocationY: function() {
		return this._point.y
	},
	getPreviousLocation: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocation: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getDelta: function() {
		return cc.pSub(this._point,
			this._prevPoint)
	},
	getLocationInView: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getPreviousLocationInView: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocationInView: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getID: function() {
		return this._id
	},
	getId: function() {
		cc.log("getId is deprecated. Please use getID instead.");
		return this._id
	},
	setTouchInfo: function(a, c, b) {
		this._prevPoint = this._point;
		this._point = cc.p(c || 0, b || 0);
		this._id = a;
		this._startPointCaptured ||
			(this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
	},
	_setPoint: function(a, c) {
		void 0 === c ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = c)
	},
	_setPrevPoint: function(a, c) {
		this._prevPoint = void 0 === c ? cc.p(a.x, a.y) : cc.p(a || 0, c || 0)
	}
});
cc.Event = cc.Class.extend({
	_type: 0,
	_isStopped: !1,
	_currentTarget: null,
	_setCurrentTarget: function(a) {
		this._currentTarget = a
	},
	ctor: function(a) {
		this._type = a
	},
	getType: function() {
		return this._type
	},
	stopPropagation: function() {
		this._isStopped = !0
	},
	isStopped: function() {
		return this._isStopped
	},
	getCurrentTarget: function() {
		return this._currentTarget
	}
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
	_eventName: null,
	_userData: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
		this._eventName = a
	},
	setUserData: function(a) {
		this._userData = a
	},
	getUserData: function() {
		return this._userData
	},
	getEventName: function() {
		return this._eventName
	}
});
cc.EventMouse = cc.Event.extend({
	_eventType: 0,
	_button: 0,
	_x: 0,
	_y: 0,
	_prevX: 0,
	_prevY: 0,
	_scrollX: 0,
	_scrollY: 0,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
		this._eventType = a
	},
	setScrollData: function(a, c) {
		this._scrollX = a;
		this._scrollY = c
	},
	getScrollX: function() {
		return this._scrollX
	},
	getScrollY: function() {
		return this._scrollY
	},
	setLocation: function(a, c) {
		this._x = a;
		this._y = c
	},
	getLocation: function() {
		return {
			x: this._x,
			y: this._y
		}
	},
	getLocationInView: function() {
		return {
			x: this._x,
			y: cc.view._designResolutionSize.height -
				this._y
		}
	},
	_setPrevCursor: function(a, c) {
		this._prevX = a;
		this._prevY = c
	},
	getDelta: function() {
		return {
			x: this._x - this._prevX,
			y: this._y - this._prevY
		}
	},
	getDeltaX: function() {
		return this._x - this._prevX
	},
	getDeltaY: function() {
		return this._y - this._prevY
	},
	setButton: function(a) {
		this._button = a
	},
	getButton: function() {
		return this._button
	},
	getLocationX: function() {
		return this._x
	},
	getLocationY: function() {
		return this._y
	}
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
	_eventCode: 0,
	_touches: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
		this._touches = a || []
	},
	getEventCode: function() {
		return this._eventCode
	},
	getTouches: function() {
		return this._touches
	},
	_setEventCode: function(a) {
		this._eventCode = a
	},
	_setTouches: function(a) {
		this._touches = a
	}
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
	BEGAN: 0,
	MOVED: 1,
	ENDED: 2,
	CANCELLED: 3
};
cc.EventFocus = cc.Event.extend({
	_widgetGetFocus: null,
	_widgetLoseFocus: null,
	ctor: function(a, c) {
		cc.Event.prototype.ctor.call(this, cc.Event.FOCUS);
		this._widgetGetFocus = c;
		this._widgetLoseFocus = a
	}
});
cc.EventListener = cc.Class.extend({
	_onEvent: null,
	_type: 0,
	_listenerID: null,
	_registered: !1,
	_fixedPriority: 0,
	_node: null,
	_paused: !0,
	_isEnabled: !0,
	ctor: function(a, c, b) {
		this._onEvent = b;
		this._type = a || 0;
		this._listenerID = c || ""
	},
	_setPaused: function(a) {
		this._paused = a
	},
	_isPaused: function() {
		return this._paused
	},
	_setRegistered: function(a) {
		this._registered = a
	},
	_isRegistered: function() {
		return this._registered
	},
	_getType: function() {
		return this._type
	},
	_getListenerID: function() {
		return this._listenerID
	},
	_setFixedPriority: function(a) {
		this._fixedPriority =
			a
	},
	_getFixedPriority: function() {
		return this._fixedPriority
	},
	_setSceneGraphPriority: function(a) {
		this._node = a
	},
	_getSceneGraphPriority: function() {
		return this._node
	},
	checkAvailable: function() {
		return null !== this._onEvent
	},
	clone: function() {
		return null
	},
	setEnabled: function(a) {
		this._isEnabled = a
	},
	isEnabled: function() {
		return this._isEnabled
	},
	retain: function() {},
	release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.CUSTOM = 8;
cc.EventListener.FOCUS = 7;
cc._EventListenerCustom = cc.EventListener.extend({
	_onCustomEvent: null,
	ctor: function(a, c) {
		this._onCustomEvent = c;
		var b = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
			null !== b._onCustomEvent && b._onCustomEvent(a)
		})
	},
	checkAvailable: function() {
		return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
	},
	clone: function() {
		return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
	}
});
cc._EventListenerCustom.create = function(a, c) {
	return new cc._EventListenerCustom(a, c)
};
cc._EventListenerMouse = cc.EventListener.extend({
	onMouseDown: null,
	onMouseUp: null,
	onMouseMove: null,
	onMouseScroll: null,
	ctor: function() {
		var a = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(c) {
			var b = cc.EventMouse;
			switch(c._eventType) {
				case b.DOWN:
					if(a.onMouseDown) a.onMouseDown(c);
					break;
				case b.UP:
					if(a.onMouseUp) a.onMouseUp(c);
					break;
				case b.MOVE:
					if(a.onMouseMove) a.onMouseMove(c);
					break;
				case b.SCROLL:
					if(a.onMouseScroll) a.onMouseScroll(c)
			}
		})
	},
	clone: function() {
		var a = new cc._EventListenerMouse;
		a.onMouseDown = this.onMouseDown;
		a.onMouseUp = this.onMouseUp;
		a.onMouseMove = this.onMouseMove;
		a.onMouseScroll = this.onMouseScroll;
		return a
	},
	checkAvailable: function() {
		return !0
	}
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
	return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
	_claimedTouches: null,
	swallowTouches: !1,
	onTouchBegan: null,
	onTouchMoved: null,
	onTouchEnded: null,
	onTouchCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
		this._claimedTouches = []
	},
	setSwallowTouches: function(a) {
		this.swallowTouches = a
	},
	isSwallowTouches: function() {
		return this.swallowTouches
	},
	clone: function() {
		var a = new cc._EventListenerTouchOneByOne;
		a.onTouchBegan = this.onTouchBegan;
		a.onTouchMoved = this.onTouchMoved;
		a.onTouchEnded = this.onTouchEnded;
		a.onTouchCancelled = this.onTouchCancelled;
		a.swallowTouches = this.swallowTouches;
		return a
	},
	checkAvailable: function() {
		return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
	}
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
	return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
	onTouchesBegan: null,
	onTouchesMoved: null,
	onTouchesEnded: null,
	onTouchesCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
	},
	clone: function() {
		var a = new cc._EventListenerTouchAllAtOnce;
		a.onTouchesBegan = this.onTouchesBegan;
		a.onTouchesMoved = this.onTouchesMoved;
		a.onTouchesEnded = this.onTouchesEnded;
		a.onTouchesCancelled = this.onTouchesCancelled;
		return a
	},
	checkAvailable: function() {
		return null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
	}
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
	return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
	cc.assert(a && a.event, cc._LogInfos.EventListener_create);
	var c = a.event;
	delete a.event;
	var b = null;
	c === cc.EventListener.TOUCH_ONE_BY_ONE ? b = new cc._EventListenerTouchOneByOne : c === cc.EventListener.TOUCH_ALL_AT_ONCE ? b = new cc._EventListenerTouchAllAtOnce : c === cc.EventListener.MOUSE ? b = new cc._EventListenerMouse : c === cc.EventListener.CUSTOM ? (b = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : c === cc.EventListener.KEYBOARD ? b = new cc._EventListenerKeyboard :
		c === cc.EventListener.ACCELERATION ? (b = new cc._EventListenerAcceleration(a.callback), delete a.callback) : c === cc.EventListener.FOCUS && (b = new cc._EventListenerFocus);
	for(var d in a) b[d] = a[d];
	return b
};
cc._EventListenerFocus = cc.EventListener.extend({
	clone: function() {
		var a = new cc._EventListenerFocus;
		a.onFocusChanged = this.onFocusChanged;
		return a
	},
	checkAvailable: function() {
		return this.onFocusChanged ? !0 : (cc.log("Invalid EventListenerFocus!"), !1)
	},
	onFocusChanged: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function(a) {
			if(this.onFocusChanged) this.onFocusChanged(a._widgetLoseFocus, a._widgetGetFocus)
		})
	}
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
	_fixedListeners: null,
	_sceneGraphListeners: null,
	gt0Index: 0,
	ctor: function() {
		this._fixedListeners = [];
		this._sceneGraphListeners = []
	},
	size: function() {
		return this._fixedListeners.length + this._sceneGraphListeners.length
	},
	empty: function() {
		return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
	},
	push: function(a) {
		0 === a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
	},
	clearSceneGraphListeners: function() {
		this._sceneGraphListeners.length =
			0
	},
	clearFixedListeners: function() {
		this._fixedListeners.length = 0
	},
	clear: function() {
		this._sceneGraphListeners.length = 0;
		this._fixedListeners.length = 0
	},
	getFixedPriorityListeners: function() {
		return this._fixedListeners
	},
	getSceneGraphPriorityListeners: function() {
		return this._sceneGraphListeners
	}
});
cc.__getListenerID = function(a) {
	var c = cc.Event,
		b = a.getType();
	if(b === c.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
	if(b === c.CUSTOM) return a.getEventName();
	if(b === c.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
	if(b === c.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
	if(b === c.FOCUS) return cc._EventListenerFocus.LISTENER_ID;
	b === c.TOUCH && cc.log(cc._LogInfos.__getListenerID);
	return ""
};
cc.eventManager = {
	DIRTY_NONE: 0,
	DIRTY_FIXED_PRIORITY: 1,
	DIRTY_SCENE_GRAPH_PRIORITY: 2,
	DIRTY_ALL: 3,
	_listenersMap: {},
	_priorityDirtyFlagMap: {},
	_nodeListenersMap: {},
	_nodePriorityMap: {},
	_globalZOrderNodeMap: {},
	_toAddedListeners: [],
	_dirtyNodes: [],
	_inDispatch: 0,
	_isEnabled: !1,
	_nodePriorityIndex: 0,
	_internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
	_setDirtyForNode: function(a) {
		null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
		a = a.getChildren();
		for(var c = 0, b = a.length; c < b; c++) this._setDirtyForNode(a[c])
	},
	pauseTarget: function(a, c) {
		var b = this._nodeListenersMap[a.__instanceId],
			d, e;
		if(b)
			for(d = 0, e = b.length; d < e; d++) b[d]._setPaused(!0);
		if(!0 === c)
			for(b = a.getChildren(), d = 0, e = b.length; d < e; d++) this.pauseTarget(b[d], !0)
	},
	resumeTarget: function(a, c) {
		var b = this._nodeListenersMap[a.__instanceId],
			d, e;
		if(b)
			for(d = 0, e = b.length; d < e; d++) b[d]._setPaused(!1);
		this._setDirtyForNode(a);
		if(!0 === c)
			for(b = a.getChildren(), d = 0, e = b.length; d < e; d++) this.resumeTarget(b[d], !0)
	},
	_addListener: function(a) {
		0 === this._inDispatch ? this._forceAddEventListener(a) :
			this._toAddedListeners.push(a)
	},
	_forceAddEventListener: function(a) {
		var c = a._getListenerID(),
			b = this._listenersMap[c];
		b || (b = new cc._EventListenerVector, this._listenersMap[c] = b);
		b.push(a);
		0 === a._getFixedPriority() ? (this._setDirty(c, this.DIRTY_SCENE_GRAPH_PRIORITY), c = a._getSceneGraphPriority(), null === c && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(c, a), c.isRunning() && this.resumeTarget(c)) : this._setDirty(c, this.DIRTY_FIXED_PRIORITY)
	},
	_getListeners: function(a) {
		return this._listenersMap[a]
	},
	_updateDirtyFlagForSceneGraph: function() {
		if(0 !== this._dirtyNodes.length) {
			for(var a = this._dirtyNodes, c, b, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)
				if(c = d[a[e].__instanceId])
					for(var g = 0, h = c.length; g < h; g++)(b = c[g]) && this._setDirty(b._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
			this._dirtyNodes.length = 0
		}
	},
	_removeAllListenersInVector: function(a) {
		if(a)
			for(var c, b = 0; b < a.length;) c = a[b], c._setRegistered(!1), null != c._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(c._getSceneGraphPriority(),
				c), c._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, c) : ++b
	},
	_removeListenersForListenerID: function(a) {
		var c = this._listenersMap[a];
		if(c) {
			var b = c.getFixedPriorityListeners(),
				d = c.getSceneGraphPriorityListeners();
			this._removeAllListenersInVector(d);
			this._removeAllListenersInVector(b);
			delete this._priorityDirtyFlagMap[a];
			this._inDispatch || (c.clear(), delete this._listenersMap[a])
		}
		b = this._toAddedListeners;
		for(c = 0; c < b.length;)(d = b[c]) && d._getListenerID() === a ? cc.arrayRemoveObject(b,
			d) : ++c
	},
	_sortEventListeners: function(a) {
		var c = this.DIRTY_NONE,
			b = this._priorityDirtyFlagMap;
		b[a] && (c = b[a]);
		c !== this.DIRTY_NONE && (b[a] = this.DIRTY_NONE, c & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), c & this.DIRTY_SCENE_GRAPH_PRIORITY && ((c = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, c) : b[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
	},
	_sortListenersOfSceneGraphPriority: function(a, c) {
		var b = this._getListeners(a);
		if(b) {
			var d = b.getSceneGraphPriorityListeners();
			d && 0 !==
				d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(c, !0), b.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
		}
	},
	_sortEventListenersOfSceneGraphPriorityDes: function(a, c) {
		var b = cc.eventManager._nodePriorityMap,
			d = a._getSceneGraphPriority(),
			e = c._getSceneGraphPriority();
		return c && e && b[e.__instanceId] ? a && d && b[d.__instanceId] ? b[c._getSceneGraphPriority().__instanceId] - b[a._getSceneGraphPriority().__instanceId] : 1 : -1
	},
	_sortListenersOfFixedPriority: function(a) {
		if(a =
			this._listenersMap[a]) {
			var c = a.getFixedPriorityListeners();
			if(c && 0 !== c.length) {
				c.sort(this._sortListenersOfFixedPriorityAsc);
				for(var b = 0, d = c.length; b < d && !(0 <= c[b]._getFixedPriority());) ++b;
				a.gt0Index = b
			}
		}
	},
	_sortListenersOfFixedPriorityAsc: function(a, c) {
		return a._getFixedPriority() - c._getFixedPriority()
	},
	_onUpdateListeners: function(a) {
		if(a = this._listenersMap[a]) {
			var c = a.getFixedPriorityListeners(),
				b = a.getSceneGraphPriorityListeners(),
				d, e;
			if(b)
				for(d = 0; d < b.length;) e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b,
					e);
			if(c)
				for(d = 0; d < c.length;) e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c, e);
			b && 0 === b.length && a.clearSceneGraphListeners();
			c && 0 === c.length && a.clearFixedListeners()
		}
	},
	_updateListeners: function(a) {
		var c = this._inDispatch;
		cc.assert(0 < c, cc._LogInfos.EventManager__updateListeners);
		if(!(1 < c)) {
			a.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
			cc.assert(1 === c, cc._LogInfos.EventManager__updateListeners_2);
			a = this._listenersMap;
			var c = this._priorityDirtyFlagMap,
				b;
			for(b in a) a[b].empty() && (delete c[b], delete a[b]);
			b = this._toAddedListeners;
			if(0 !== b.length) {
				a = 0;
				for(c = b.length; a < c; a++) this._forceAddEventListener(b[a]);
				this._toAddedListeners.length = 0
			}
		}
	},
	_onTouchEventCallback: function(a, c) {
		if(!a._isRegistered) return !1;
		var b = c.event,
			d = c.selTouch;
		b._setCurrentTarget(a._node);
		var e = !1,
			f, g = b.getEventCode(),
			h = cc.EventTouch.EventCode;
		if(g === h.BEGAN) a.onTouchBegan &&
			(e = a.onTouchBegan(d, b)) && a._registered && a._claimedTouches.push(d);
		else if(0 < a._claimedTouches.length && -1 !== (f = a._claimedTouches.indexOf(d)))
			if(e = !0, g === h.MOVED && a.onTouchMoved) a.onTouchMoved(d, b);
			else if(g === h.ENDED) {
			if(a.onTouchEnded) a.onTouchEnded(d, b);
			a._registered && a._claimedTouches.splice(f, 1)
		} else if(g === h.CANCELLED) {
			if(a.onTouchCancelled) a.onTouchCancelled(d, b);
			a._registered && a._claimedTouches.splice(f, 1)
		}
		return b.isStopped() ? (cc.eventManager._updateListeners(b), !0) : e && a._registered && a.swallowTouches ?
			(c.needsMutableSet && c.touches.splice(d, 1), !0) : !1
	},
	_dispatchTouchEvent: function(a) {
		this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
		this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		var c = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
			b = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		if(null !== c || null !== b) {
			var d = a.getTouches(),
				e = cc.copyArray(d),
				f = {
					event: a,
					needsMutableSet: c && b,
					touches: e,
					selTouch: null
				};
			if(c)
				for(var g = 0; g < d.length; g++)
					if(f.selTouch =
						d[g], this._dispatchEventToListeners(c, this._onTouchEventCallback, f), a.isStopped()) return;
			if(b && 0 < e.length && (this._dispatchEventToListeners(b, this._onTouchesEventCallback, {
					event: a,
					touches: e
				}), a.isStopped())) return;
			this._updateListeners(a)
		}
	},
	_onTouchesEventCallback: function(a, c) {
		if(!a._registered) return !1;
		var b = cc.EventTouch.EventCode,
			d = c.event,
			e = c.touches,
			f = d.getEventCode();
		d._setCurrentTarget(a._node);
		if(f === b.BEGAN && a.onTouchesBegan) a.onTouchesBegan(e, d);
		else if(f === b.MOVED && a.onTouchesMoved) a.onTouchesMoved(e,
			d);
		else if(f === b.ENDED && a.onTouchesEnded) a.onTouchesEnded(e, d);
		else if(f === b.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(e, d);
		return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
	},
	_associateNodeAndEventListener: function(a, c) {
		var b = this._nodeListenersMap[a.__instanceId];
		b || (b = [], this._nodeListenersMap[a.__instanceId] = b);
		b.push(c)
	},
	_dissociateNodeAndEventListener: function(a, c) {
		var b = this._nodeListenersMap[a.__instanceId];
		b && (cc.arrayRemoveObject(b, c), 0 === b.length && delete this._nodeListenersMap[a.__instanceId])
	},
	_dispatchEventToListeners: function(a, c, b) {
		var d = !1,
			e = a.getFixedPriorityListeners(),
			f = a.getSceneGraphPriorityListeners(),
			g = 0,
			h;
		if(e && 0 !== e.length)
			for(; g < a.gt0Index; ++g)
				if(h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && c(h, b)) {
					d = !0;
					break
				}
		if(f && !d)
			for(a = 0; a < f.length; a++)
				if(h = f[a], h.isEnabled() && !h._isPaused() && h._isRegistered() && c(h, b)) {
					d = !0;
					break
				}
		if(e && !d)
			for(; g < e.length && (h = e[g], !h.isEnabled() || h._isPaused() || !h._isRegistered() || !c(h, b)); ++g);
	},
	_setDirty: function(a, c) {
		var b = this._priorityDirtyFlagMap;
		b[a] = null == b[a] ? c : c | b[a]
	},
	_visitTarget: function(a, c) {
		var b = a.getChildren(),
			d = 0,
			e = b.length,
			f = this._globalZOrderNodeMap,
			g = this._nodeListenersMap;
		if(0 < e) {
			for(var h; d < e; d++)
				if((h = b[d]) && 0 > h.getLocalZOrder()) this._visitTarget(h, !1);
				else break;
			null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
			for(; d < e; d++)(h = b[d]) && this._visitTarget(h, !1)
		} else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
		if(c) {
			var b = [],
				k;
			for(k in f) b.push(k);
			b.sort(this._sortNumberAsc);
			k = b.length;
			h = this._nodePriorityMap;
			for(d = 0; d < k; d++)
				for(e = f[b[d]], g = 0; g < e.length; g++) h[e[g]] = ++this._nodePriorityIndex;
			this._globalZOrderNodeMap = {}
		}
	},
	_sortNumberAsc: function(a, c) {
		return a - c
	},
	addListener: function(a, c) {
		cc.assert(a && c, cc._LogInfos.eventManager_addListener_2);
		if(!(a instanceof cc.EventListener)) cc.assert(!cc.isNumber(c), cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
		else if(a._isRegistered()) {
			cc.log(cc._LogInfos.eventManager_addListener_4);
			return
		}
		if(a.checkAvailable()) {
			if(cc.isNumber(c)) {
				if(0 === c) {
					cc.log(cc._LogInfos.eventManager_addListener);
					return
				}
				a._setSceneGraphPriority(null);
				a._setFixedPriority(c);
				a._setRegistered(!0);
				a._setPaused(!1)
			} else a._setSceneGraphPriority(c), a._setFixedPriority(0), a._setRegistered(!0);
			this._addListener(a);
			return a
		}
	},
	addCustomListener: function(a, c) {
		var b = new cc._EventListenerCustom(a, c);
		this.addListener(b, 1);
		return b
	},
	removeListener: function(a) {
		if(null != a) {
			var c, b = this._listenersMap,
				d;
			for(d in b) {
				var e =
					b[d],
					f = e.getFixedPriorityListeners();
				c = e.getSceneGraphPriorityListeners();
				(c = this._removeListenerInVector(c, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY): (c = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
				e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete b[d]);
				if(c) break
			}
			if(!c)
				for(b = this._toAddedListeners, d = 0, e = b.length; d < e; d++)
					if(f = b[d], f === a) {
						cc.arrayRemoveObject(b, f);
						f._setRegistered(!1);
						break
					}
		}
	},
	_removeListenerInCallback: function(a,
		c) {
		if(null == a) return !1;
		for(var b = 0, d = a.length; b < d; b++) {
			var e = a[b];
			if(e._onCustomEvent === c || e._onEvent === c) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
		}
		return !1
	},
	_removeListenerInVector: function(a, c) {
		if(null == a) return !1;
		for(var b = 0, d = a.length; b < d; b++) {
			var e = a[b];
			if(e === c) return e._setRegistered(!1), null != e._getSceneGraphPriority() &&
				(this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
		}
		return !1
	},
	removeListeners: function(a, c) {
		if(a instanceof cc.Node) {
			delete this._nodePriorityMap[a.__instanceId];
			cc.arrayRemoveObject(this._dirtyNodes, a);
			var b = this._nodeListenersMap[a.__instanceId];
			if(b) {
				for(var d = cc.copyArray(b), b = 0; b < d.length; b++) this.removeListener(d[b]);
				d.length = 0
			}
			d = this._toAddedListeners;
			for(b = 0; b < d.length;) {
				var e = d[b];
				e._getSceneGraphPriority() ===
					a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(b, 1)) : ++b
			}
			if(!0 === c)
				for(d = a.getChildren(), b = 0, e = d.length; b < e; b++) this.removeListeners(d[b], !0)
		} else a === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a ===
			cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
	},
	removeCustomListeners: function(a) {
		this._removeListenersForListenerID(a)
	},
	removeAllListeners: function() {
		var a = this._listenersMap,
			c = this._internalCustomListenerIDs,
			b;
		for(b in a) - 1 === c.indexOf(b) && this._removeListenersForListenerID(b)
	},
	setPriority: function(a,
		c) {
		if(null != a) {
			var b = this._listenersMap,
				d;
			for(d in b) {
				var e = b[d].getFixedPriorityListeners();
				if(e && -1 !== e.indexOf(a)) {
					null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
					a._getFixedPriority() !== c && (a._setFixedPriority(c), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
					break
				}
			}
		}
	},
	setEnabled: function(a) {
		this._isEnabled = a
	},
	isEnabled: function() {
		return this._isEnabled
	},
	dispatchEvent: function(a) {
		if(this._isEnabled) {
			this._updateDirtyFlagForSceneGraph();
			this._inDispatch++;
			if(!a || !a.getType) throw "event is undefined";
			if(a.getType() === cc.Event.TOUCH) this._dispatchTouchEvent(a);
			else {
				var c = cc.__getListenerID(a);
				this._sortEventListeners(c);
				c = this._listenersMap[c];
				null != c && this._dispatchEventToListeners(c, this._onListenerCallback, a);
				this._updateListeners(a)
			}
			this._inDispatch--
		}
	},
	_onListenerCallback: function(a, c) {
		c._setCurrentTarget(a._getSceneGraphPriority());
		a._onEvent(c);
		return c.isStopped()
	},
	dispatchCustomEvent: function(a, c) {
		var b = new cc.EventCustom(a);
		b.setUserData(c);
		this.dispatchEvent(b)
	}
};
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
	constructor: cc.EventHelper,
	apply: function(a) {
		a.addEventListener = cc.EventHelper.prototype.addEventListener;
		a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
		a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
		a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
	},
	addEventListener: function(a, c, b) {
		if("load" === a && this._textureLoaded) setTimeout(function() {
			c.call(b)
		}, 0);
		else {
			void 0 === this._listeners && (this._listeners = {});
			var d = this._listeners;
			void 0 ===
				d[a] && (d[a] = []);
			this.hasEventListener(a, c, b) || d[a].push({
				callback: c,
				eventTarget: b
			})
		}
	},
	hasEventListener: function(a, c, b) {
		if(void 0 === this._listeners) return !1;
		var d = this._listeners;
		if(void 0 !== d[a]) {
			a = 0;
			for(var e = d.length; a < e; a++) {
				var f = d[a];
				if(f.callback === c && f.eventTarget === b) return !0
			}
		}
		return !1
	},
	removeEventListener: function(a, c) {
		if(void 0 !== this._listeners) {
			var b = this._listeners[a];
			if(void 0 !== b)
				for(var d = 0; d < b.length;) b[d].eventTarget === c ? b.splice(d, 1) : d++
		}
	},
	dispatchEvent: function(a, c) {
		if(void 0 !==
			this._listeners) {
			null == c && (c = !0);
			var b = this._listeners[a];
			if(void 0 !== b) {
				for(var d = [], e = b.length, f = 0; f < e; f++) d[f] = b[f];
				for(f = 0; f < e; f++) d[f].callback.call(d[f].eventTarget, this);
				c && (b.length = 0)
			}
		}
	}
};
cc.EventAcceleration = cc.Event.extend({
	_acc: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
		this._acc = a
	}
});
cc.EventKeyboard = cc.Event.extend({
	_keyCode: 0,
	_isPressed: !1,
	ctor: function(a, c) {
		cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
		this._keyCode = a;
		this._isPressed = c
	}
});
cc._EventListenerAcceleration = cc.EventListener.extend({
	_onAccelerationEvent: null,
	ctor: function(a) {
		this._onAccelerationEvent = a;
		var c = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
			c._onAccelerationEvent(a._acc, a)
		})
	},
	checkAvailable: function() {
		cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
		return !0
	},
	clone: function() {
		return new cc._EventListenerAcceleration(this._onAccelerationEvent)
	}
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
	return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
	onKeyPressed: null,
	onKeyReleased: null,
	ctor: function() {
		var a = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(c) {
			if(c._isPressed) {
				if(a.onKeyPressed) a.onKeyPressed(c._keyCode, c)
			} else if(a.onKeyReleased) a.onKeyReleased(c._keyCode, c)
		})
	},
	clone: function() {
		var a = new cc._EventListenerKeyboard;
		a.onKeyPressed = this.onKeyPressed;
		a.onKeyReleased = this.onKeyReleased;
		return a
	},
	checkAvailable: function() {
		return null ===
			this.onKeyPressed && null === this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
	}
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
	return new cc._EventListenerKeyboard
};
cc.rendererCanvas = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToCanvasOn: !1,
	_cacheToCanvasCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	getRenderCmd: function(a) {
		return a._createRenderCmd()
	},
	rendering: function(a) {
		var c = this._renderCmds,
			b, d = cc.view.getScaleX(),
			e = cc.view.getScaleY(),
			f = a || cc._renderContext;
		f.computeRealOffsetY();
		a = 0;
		for(b = c.length; a < b; a++) c[a].rendering(f, d, e)
	},
	_renderingToCacheCanvas: function(a, c, b, d) {
		a || cc.log("The context of RenderTexture is invalid.");
		b = cc.isUndefined(b) ?
			1 : b;
		d = cc.isUndefined(d) ? 1 : d;
		c = c || this._currentID;
		var e = this._cacheToCanvasCmds[c],
			f, g;
		a.computeRealOffsetY();
		f = 0;
		for(g = e.length; f < g; f++) e[f].rendering(a, b, d);
		e.length = 0;
		a = this._cacheInstanceIds;
		delete this._cacheToCanvasCmds[c];
		cc.arrayRemoveObject(a, c);
		0 === a.length ? this._isCacheToCanvasOn = !1 : this._currentID = a[a.length - 1]
	},
	_turnToCacheMode: function(a) {
		this._isCacheToCanvasOn = !0;
		a = a || 0;
		this._cacheToCanvasCmds[a] = []; - 1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a);
		this._currentID =
			a
	},
	_turnToNormalMode: function() {
		this._isCacheToCanvasOn = !1
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var a = this._transformNodePool;
		a.sort(this._sortNodeByLevelAsc);
		for(var c = 0, b = a.length; c < b; c++) 0 !== a[c]._dirtyFlag && a[c].updateStatus();
		a.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(a, c) {
		return a._curLevel - c._curLevel
	},
	pushDirtyNode: function(a) {
		this._transformNodePool.push(a)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	pushRenderCommand: function(a) {
		if(a._needDraw)
			if(this._isCacheToCanvasOn) {
				var c = this._cacheToCanvasCmds[this._currentID]; - 1 === c.indexOf(a) && c.push(a)
			} else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.renderer = cc.rendererCanvas);
(function() {
	cc.CanvasContextWrapper = function(a) {
		this._context = a;
		this._saveCount = 0;
		this._currentAlpha = a.globalAlpha;
		this._currentCompositeOperation = a.globalCompositeOperation;
		this._currentFillStyle = a.fillStyle;
		this._currentStrokeStyle = a.strokeStyle;
		this._offsetY = this._offsetX = 0;
		this._realOffsetY = this.height;
		this._armatureMode = 0
	};
	var a = cc.CanvasContextWrapper.prototype;
	a.resetCache = function() {
		var a = this._context;
		this._currentAlpha = a.globalAlpha;
		this._currentCompositeOperation = a.globalCompositeOperation;
		this._currentFillStyle = a.fillStyle;
		this._currentStrokeStyle = a.strokeStyle;
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.setOffset = function(a, b) {
		this._offsetX = a;
		this._offsetY = b;
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.computeRealOffsetY = function() {
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.setViewScale = function(a, b) {
		this._scaleX = a;
		this._scaleY = b
	};
	a.getContext = function() {
		return this._context
	};
	a.save = function() {
		this._context.save();
		this._saveCount++
	};
	a.restore = function() {
		this._context.restore();
		this._saveCount--
	};
	a.setGlobalAlpha = function(a) {
		0 < this._saveCount ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
	};
	a.setCompositeOperation = function(a) {
		0 < this._saveCount ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
	};
	a.setFillStyle = function(a) {
		0 < this._saveCount ? this._context.fillStyle = a : this._currentFillStyle !==
			a && (this._currentFillStyle = a, this._context.fillStyle = a)
	};
	a.setStrokeStyle = function(a) {
		0 < this._saveCount ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
	};
	a.setTransform = function(a, b, d) {
		0 < this._armatureMode ? (this.restore(), this.save(), this._context.transform(a.a, -a.b, -a.c, a.d, a.tx * b, -(a.ty * d))) : this._context.setTransform(a.a, -a.b, -a.c, a.d, this._offsetX + a.tx * b, this._realOffsetY - a.ty * d)
	};
	a._switchToArmatureMode = function(a, b, d, e) {
		a ? (this._armatureMode++,
			this._context.setTransform(b.a, b.c, b.b, b.d, this._offsetX + b.tx * d, this._realOffsetY - b.ty * e), this.save()) : (this._armatureMode--, this.restore())
	}
})();
cc.rendererWebGL = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToBufferOn: !1,
	_cacheToBufferCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	getRenderCmd: function(a) {
		return a._createRenderCmd()
	},
	rendering: function(a) {
		var c = this._renderCmds,
			b, d = a || cc._renderContext;
		a = 0;
		for(b = c.length; a < b; a++) c[a].rendering(d)
	},
	_turnToCacheMode: function(a) {
		this._isCacheToBufferOn = !0;
		a = a || 0;
		this._cacheToBufferCmds[a] = [];
		this._cacheInstanceIds.push(a);
		this._currentID = a
	},
	_turnToNormalMode: function() {
		this._isCacheToBufferOn = !1
	},
	_renderingToBuffer: function(a) {
		a = a || this._currentID;
		var c = this._cacheToBufferCmds[a],
			b, d, e = cc._renderContext,
			f = this._cacheInstanceIds;
		b = 0;
		for(d = c.length; b < d; b++) c[b].rendering(e);
		c.length = 0;
		delete this._cacheToBufferCmds[a];
		cc.arrayRemoveObject(f, a);
		0 === f.length ? this._isCacheToBufferOn = !1 : this._currentID = f[f.length - 1]
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var a = this._transformNodePool;
		a.sort(this._sortNodeByLevelAsc);
		for(var c =
				0, b = a.length; c < b; c++) a[c].updateStatus();
		a.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(a, c) {
		return a._curLevel - c._curLevel
	},
	pushDirtyNode: function(a) {
		this._transformNodePool.push(a)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	pushRenderCommand: function(a) {
		if(a._needDraw)
			if(this._isCacheToBufferOn) {
				var c = this._cacheToBufferCmds[this._currentID]; - 1 === c.indexOf(a) && c.push(a)
			} else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
	}
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.renderer = cc.rendererWebGL);
cc._tmp.PrototypeCCNode = function() {
	var a = cc.Node.prototype;
	cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
	cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
	cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
	cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
	cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
	cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
	cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
	cc.defineGetterSetter(a, "skewY",
		a.getSkewY, a.setSkewY);
	cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
	cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
	cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
	cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
	cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
	cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
	cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
	cc.defineGetterSetter(a, "scaleY", a.getScaleY,
		a.setScaleY);
	cc.defineGetterSetter(a, "children", a.getChildren);
	cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
	cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
	cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
	cc.defineGetterSetter(a, "running", a.isRunning);
	cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
	cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
	cc.defineGetterSetter(a, "scheduler",
		a.getScheduler, a.setScheduler);
	cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
	cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
	_localZOrder: 0,
	_globalZOrder: 0,
	_vertexZ: 0,
	_rotationX: 0,
	_rotationY: 0,
	_scaleX: 1,
	_scaleY: 1,
	_position: null,
	_normalizedPosition: null,
	_usingNormalizedPosition: !1,
	_normalizedPositionDirty: !1,
	_skewX: 0,
	_skewY: 0,
	_children: null,
	_visible: !0,
	_anchorPoint: null,
	_contentSize: null,
	_running: !1,
	_parent: null,
	_ignoreAnchorPointForPosition: !1,
	tag: cc.NODE_TAG_INVALID,
	userData: null,
	userObject: null,
	_reorderChildDirty: !1,
	_shaderProgram: null,
	arrivalOrder: 0,
	_actionManager: null,
	_scheduler: null,
	_eventDispatcher: null,
	_additionalTransformDirty: !1,
	_additionalTransform: null,
	_componentContainer: null,
	_isTransitionFinished: !1,
	_className: "Node",
	_showNode: !1,
	_name: "",
	_realOpacity: 255,
	_realColor: null,
	_cascadeColorEnabled: !1,
	_cascadeOpacityEnabled: !1,
	_renderCmd: null,
	_camera: null,
	ctor: function() {
		this._initNode();
		this._initRendererCmd()
	},
	_initNode: function() {
		this._anchorPoint = cc.p(0, 0);
		this._contentSize = cc.size(0, 0);
		this._position = cc.p(0, 0);
		this._normalizedPosition = cc.p(0, 0);
		this._children = [];
		var a = cc.director;
		this._actionManager =
			a.getActionManager();
		this._scheduler = a.getScheduler();
		this._additionalTransform = cc.affineTransformMakeIdentity();
		cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
		this._realOpacity = 255;
		this._realColor = cc.color(255, 255, 255, 255);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
	},
	init: function() {
		return !0
	},
	_arrayMakeObjectsPerformSelector: function(a, c) {
		if(a && 0 !== a.length) {
			var b, d = a.length,
				e;
			b = cc.Node._stateCallbackType;
			switch(c) {
				case b.onEnter:
					for(b = 0; b < d; b++)
						if(e =
							a[b]) e.onEnter();
					break;
				case b.onExit:
					for(b = 0; b < d; b++)
						if(e = a[b]) e.onExit();
					break;
				case b.onEnterTransitionDidFinish:
					for(b = 0; b < d; b++)
						if(e = a[b]) e.onEnterTransitionDidFinish();
					break;
				case b.cleanup:
					for(b = 0; b < d; b++)(e = a[b]) && e.cleanup();
					break;
				case b.updateTransform:
					for(b = 0; b < d; b++)(e = a[b]) && e.updateTransform();
					break;
				case b.onExitTransitionDidStart:
					for(b = 0; b < d; b++)
						if(e = a[b]) e.onExitTransitionDidStart();
					break;
				case b.sortAllChildren:
					for(b = 0; b < d; b++)(e = a[b]) && e.sortAllChildren();
					break;
				default:
					cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
			}
		}
	},
	attr: function(a) {
		for(var c in a) this[c] = a[c]
	},
	getSkewX: function() {
		return this._skewX
	},
	setSkewX: function(a) {
		this._skewX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getSkewY: function() {
		return this._skewY
	},
	setSkewY: function(a) {
		this._skewY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setLocalZOrder: function(a) {
		this._localZOrder = a;
		this._parent && this._parent.reorderChild(this, a);
		cc.eventManager._setDirtyForNode(this)
	},
	_setLocalZOrder: function(a) {
		this._localZOrder =
			a
	},
	getLocalZOrder: function() {
		return this._localZOrder
	},
	getZOrder: function() {
		cc.log(cc._LogInfos.Node_getZOrder);
		return this.getLocalZOrder()
	},
	setZOrder: function(a) {
		cc.log(cc._LogInfos.Node_setZOrder);
		this.setLocalZOrder(a)
	},
	setGlobalZOrder: function(a) {
		this._globalZOrder !== a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
	},
	getGlobalZOrder: function() {
		return this._globalZOrder
	},
	getVertexZ: function() {
		return this._vertexZ
	},
	setVertexZ: function(a) {
		this._vertexZ = a
	},
	getRotation: function() {
		this._rotationX !==
			this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
		return this._rotationX
	},
	setRotation: function(a) {
		this._rotationX = this._rotationY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationX: function() {
		return this._rotationX
	},
	setRotationX: function(a) {
		this._rotationX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationY: function() {
		return this._rotationY
	},
	setRotationY: function(a) {
		this._rotationY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScale: function() {
		this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
		return this._scaleX
	},
	setScale: function(a, c) {
		this._scaleX = a;
		this._scaleY = c || 0 === c ? c : a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleX: function() {
		return this._scaleX
	},
	setScaleX: function(a) {
		this._scaleX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleY: function() {
		return this._scaleY
	},
	setScaleY: function(a) {
		this._scaleY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setPosition: function(a, c) {
		var b = this._position;
		if(void 0 === c) {
			if(b.x === a.x && b.y === a.y) return;
			b.x = a.x;
			b.y = a.y
		} else {
			if(b.x === a && b.y === c) return;
			b.x = a;
			b.y = c
		}
		this._usingNormalizedPosition = !1;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setNormalizedPosition: function(a, c) {
		var b = this._normalizedPosition;
		void 0 === c ? (b.x = a.x, b.y = a.y) : (b.x = a, b.y = c);
		this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPosition: function() {
		return cc.p(this._position)
	},
	getNormalizedPosition: function() {
		return cc.p(this._normalizedPosition)
	},
	getPositionX: function() {
		return this._position.x
	},
	setPositionX: function(a) {
		this._position.x = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPositionY: function() {
		return this._position.y
	},
	setPositionY: function(a) {
		this._position.y = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getChildrenCount: function() {
		return this._children.length
	},
	getChildren: function() {
		return this._children
	},
	isVisible: function() {
		return this._visible
	},
	setVisible: function(a) {
		this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
	},
	getAnchorPoint: function() {
		return cc.p(this._anchorPoint)
	},
	setAnchorPoint: function(a, c) {
		var b = this._anchorPoint;
		if(void 0 === c) {
			if(a.x === b.x && a.y === b.y) return;
			b.x = a.x;
			b.y = a.y
		} else {
			if(a === b.x && c === b.y) return;
			b.x = a;
			b.y = c
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getAnchorX: function() {
		return this._anchorPoint.x
	},
	_setAnchorX: function(a) {
		this._anchorPoint.x !==
			a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
	},
	_getAnchorY: function() {
		return this._anchorPoint.y
	},
	_setAnchorY: function(a) {
		this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
	},
	getAnchorPointInPoints: function() {
		return this._renderCmd.getAnchorPointInPoints()
	},
	_getWidth: function() {
		return this._contentSize.width
	},
	_setWidth: function(a) {
		this._contentSize.width = a;
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getHeight: function() {
		return this._contentSize.height
	},
	_setHeight: function(a) {
		this._contentSize.height = a;
		this._renderCmd._updateAnchorPointInPoint()
	},
	getContentSize: function() {
		return cc.size(this._contentSize)
	},
	setContentSize: function(a, c) {
		var b = this._contentSize;
		if(void 0 === c) {
			if(a.width === b.width && a.height === b.height) return;
			b.width = a.width;
			b.height = a.height
		} else {
			if(a === b.width && c === b.height) return;
			b.width = a;
			b.height = c
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	isRunning: function() {
		return this._running
	},
	getParent: function() {
		return this._parent
	},
	setParent: function(a) {
		this._parent =
			a
	},
	isIgnoreAnchorPointForPosition: function() {
		return this._ignoreAnchorPointForPosition
	},
	ignoreAnchorPointForPosition: function(a) {
		a !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(a) {
		this.tag = a
	},
	setName: function(a) {
		this._name = a
	},
	getName: function() {
		return this._name
	},
	getUserData: function() {
		return this.userData
	},
	setUserData: function(a) {
		this.userData = a
	},
	getUserObject: function() {
		return this.userObject
	},
	setUserObject: function(a) {
		this.userObject !== a && (this.userObject = a)
	},
	getOrderOfArrival: function() {
		return this.arrivalOrder
	},
	setOrderOfArrival: function(a) {
		this.arrivalOrder = a
	},
	getActionManager: function() {
		this._actionManager || (this._actionManager = cc.director.getActionManager());
		return this._actionManager
	},
	setActionManager: function(a) {
		this._actionManager !== a && (this.stopAllActions(), this._actionManager = a)
	},
	getScheduler: function() {
		this._scheduler || (this._scheduler = cc.director.getScheduler());
		return this._scheduler
	},
	setScheduler: function(a) {
		this._scheduler !== a && (this.unscheduleAllCallbacks(), this._scheduler = a)
	},
	boundingBox: function() {
		cc.log(cc._LogInfos.Node_boundingBox);
		return this.getBoundingBox()
	},
	getBoundingBox: function() {
		var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
	},
	cleanup: function() {
		this.stopAllActions();
		this.unscheduleAllCallbacks();
		cc.eventManager.removeListeners(this);
		this._arrayMakeObjectsPerformSelector(this._children,
			cc.Node._stateCallbackType.cleanup)
	},
	getChildByTag: function(a) {
		var c = this._children;
		if(null !== c)
			for(var b = 0; b < c.length; b++) {
				var d = c[b];
				if(d && d.tag === a) return d
			}
		return null
	},
	getChildByName: function(a) {
		if(!a) return cc.log("Invalid name"), null;
		for(var c = this._children, b = 0, d = c.length; b < d; b++)
			if(c[b]._name === a) return c[b];
		return null
	},
	addChild: function(a, c, b) {
		c = void 0 === c ? a._localZOrder : c;
		var d, e = !1;
		cc.isUndefined(b) ? (b = void 0, d = a._name) : cc.isString(b) ? (d = b, b = void 0) : cc.isNumber(b) && (e = !0, d = "");
		cc.assert(a,
			cc._LogInfos.Node_addChild_3);
		cc.assert(null === a._parent, "child already added. It can't be added again");
		this._addChildHelper(a, c, b, d, e)
	},
	_addChildHelper: function(a, c, b, d, e) {
		this._children || (this._children = []);
		this._insertChild(a, c);
		e ? a.setTag(b) : a.setName(d);
		a.setParent(this);
		a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
		if(this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
		this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	removeFromParent: function(a) {
		this._parent && (void 0 === a && (a = !0), this._parent.removeChild(this, a))
	},
	removeFromParentAndCleanup: function(a) {
		cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
		this.removeFromParent(a)
	},
	removeChild: function(a, c) {
		0 !== this._children.length && (void 0 === c && (c = !0), -1 < this._children.indexOf(a) && this._detachChild(a, c), cc.renderer.childrenOrderDirty = !0)
	},
	removeChildByTag: function(a, c) {
		a ===
			cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
		var b = this.getChildByTag(a);
		b ? this.removeChild(b, c) : cc.log(cc._LogInfos.Node_removeChildByTag_2, a)
	},
	removeAllChildrenWithCleanup: function(a) {
		this.removeAllChildren(a)
	},
	removeAllChildren: function(a) {
		var c = this._children;
		if(null !== c) {
			void 0 === a && (a = !0);
			for(var b = 0; b < c.length; b++) {
				var d = c[b];
				d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null, d._renderCmd.detachFromParent())
			}
			this._children.length = 0;
			cc.renderer.childrenOrderDirty = !0
		}
	},
	_detachChild: function(a, c) {
		this._running && (a.onExitTransitionDidStart(), a.onExit());
		c && a.cleanup();
		a.parent = null;
		a._renderCmd.detachFromParent();
		cc.arrayRemoveObject(this._children, a)
	},
	_insertChild: function(a, c) {
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		this._children.push(a);
		a._setLocalZOrder(c)
	},
	setNodeDirty: function() {
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	reorderChild: function(a, c) {
		cc.assert(a, cc._LogInfos.Node_reorderChild);
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		a.arrivalOrder = cc.s_globalOrderOfArrival;
		cc.s_globalOrderOfArrival++;
		a._setLocalZOrder(c)
	},
	sortAllChildren: function() {
		if(this._reorderChildDirty) {
			var a = this._children,
				c = a.length,
				b, d, e;
			for(b = 1; b < c; b++) {
				e = a[b];
				for(d = b - 1; 0 <= d;) {
					if(e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
					else if(e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
					else break;
					d--
				}
				a[d + 1] = e
			}
			this._reorderChildDirty = !1
		}
	},
	draw: function(a) {},
	transformAncestors: function() {
		null !==
			this._parent && (this._parent.transformAncestors(), this._parent.transform())
	},
	onEnter: function() {
		this._isTransitionFinished = !1;
		this._running = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
		this.resume()
	},
	onEnterTransitionDidFinish: function() {
		this._isTransitionFinished = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
	},
	onExitTransitionDidStart: function() {
		this._arrayMakeObjectsPerformSelector(this._children,
			cc.Node._stateCallbackType.onExitTransitionDidStart)
	},
	onExit: function() {
		this._running = !1;
		this.pause();
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
		this.removeAllComponents()
	},
	runAction: function(a) {
		cc.assert(a, cc._LogInfos.Node_runAction);
		this.actionManager.addAction(a, this, !this._running);
		return a
	},
	stopAllActions: function() {
		this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
	},
	stopAction: function(a) {
		this.actionManager.removeAction(a)
	},
	stopActionByTag: function(a) {
		a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
	},
	getActionByTag: function(a) {
		return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
	},
	getNumberOfRunningActions: function() {
		return this.actionManager.numberOfRunningActionsInTarget(this)
	},
	scheduleUpdate: function() {
		this.scheduleUpdateWithPriority(0)
	},
	scheduleUpdateWithPriority: function(a) {
		this.scheduler.scheduleUpdate(this,
			a, !this._running)
	},
	unscheduleUpdate: function() {
		this.scheduler.unscheduleUpdate(this)
	},
	schedule: function(a, c, b, d, e) {
		var f = arguments.length;
		"function" === typeof a ? 1 === f ? (c = 0, b = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : 2 === f ? "number" === typeof c ? (b = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : (e = c, c = 0, b = cc.REPEAT_FOREVER, d = 0) : 3 === f ? ("string" === typeof b ? (e = b, b = cc.REPEAT_FOREVER) : e = this.__instanceId, d = 0) : 4 === f && (e = this.__instanceId) : 1 === f ? (c = 0, b = cc.REPEAT_FOREVER, d = 0) : 2 === f && (b = cc.REPEAT_FOREVER, d = 0);
		cc.assert(a,
			cc._LogInfos.Node_schedule);
		cc.assert(0 <= c, cc._LogInfos.Node_schedule_2);
		b = null == b ? cc.REPEAT_FOREVER : b;
		this.scheduler.schedule(a, this, c || 0, b, d || 0, !this._running, e)
	},
	scheduleOnce: function(a, c, b) {
		void 0 === b && (b = this.__instanceId);
		this.schedule(a, 0, 0, c, b)
	},
	unschedule: function(a) {
		a && this.scheduler.unschedule(a, this)
	},
	unscheduleAllCallbacks: function() {
		this.scheduler.unscheduleAllForTarget(this)
	},
	resumeSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
		this.resume()
	},
	resume: function() {
		this.scheduler.resumeTarget(this);
		this.actionManager && this.actionManager.resumeTarget(this);
		cc.eventManager.resumeTarget(this)
	},
	pauseSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
		this.pause()
	},
	pause: function() {
		this.scheduler.pauseTarget(this);
		this.actionManager && this.actionManager.pauseTarget(this);
		cc.eventManager.pauseTarget(this)
	},
	setAdditionalTransform: function(a) {
		if(void 0 === a) return this._additionalTransformDirty = !1;
		this._additionalTransform = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
		this._additionalTransformDirty = !0
	},
	getParentToNodeTransform: function() {
		this._renderCmd.getParentToNodeTransform()
	},
	parentToNodeTransform: function() {
		return this.getParentToNodeTransform()
	},
	getNodeToWorldTransform: function() {
		for(var a = this.getNodeToParentTransform(), c = this._parent; null !== c; c = c.parent) a = cc.affineTransformConcat(a, c.getNodeToParentTransform());
		return a
	},
	nodeToWorldTransform: function() {
		return this.getNodeToWorldTransform()
	},
	getWorldToNodeTransform: function() {
		return cc.affineTransformInvert(this.getNodeToWorldTransform())
	},
	worldToNodeTransform: function() {
		return this.getWorldToNodeTransform()
	},
	convertToNodeSpace: function(a) {
		return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
	},
	convertToWorldSpace: function(a) {
		a = a || cc.p(0, 0);
		return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
	},
	convertToNodeSpaceAR: function(a) {
		return cc.pSub(this.convertToNodeSpace(a), this._renderCmd.getAnchorPointInPoints())
	},
	convertToWorldSpaceAR: function(a) {
		a = a || cc.p(0, 0);
		a = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
		return this.convertToWorldSpace(a)
	},
	_convertToWindowSpace: function(a) {
		a = this.convertToWorldSpace(a);
		return cc.director.convertToUI(a)
	},
	convertTouchToNodeSpace: function(a) {
		a = a.getLocation();
		return this.convertToNodeSpace(a)
	},
	convertTouchToNodeSpaceAR: function(a) {
		a = cc.director.convertToGL(a.getLocation());
		return this.convertToNodeSpaceAR(a)
	},
	update: function(a) {
		this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
	},
	updateTransform: function() {
		this._arrayMakeObjectsPerformSelector(this._children,
			cc.Node._stateCallbackType.updateTransform)
	},
	retain: function() {},
	release: function() {},
	getComponent: function(a) {
		return this._componentContainer ? this._componentContainer.getComponent(a) : null
	},
	addComponent: function(a) {
		this._componentContainer && this._componentContainer.add(a)
	},
	removeComponent: function(a) {
		return this._componentContainer ? this._componentContainer.remove(a) : !1
	},
	removeAllComponents: function() {
		this._componentContainer && this._componentContainer.removeAll()
	},
	grid: null,
	visit: function(a) {
		this._renderCmd.visit(a)
	},
	transform: function(a, c) {
		this._renderCmd.transform(a, c)
	},
	nodeToParentTransform: function() {
		return this.getNodeToParentTransform()
	},
	getNodeToParentTransform: function() {
		return this._renderCmd.getNodeToParentTransform()
	},
	getCamera: function() {
		this._camera || (this._camera = new cc.Camera);
		return this._camera
	},
	getGrid: function() {
		return this.grid
	},
	setGrid: function(a) {
		this.grid = a
	},
	getShaderProgram: function() {
		return this._renderCmd.getShaderProgram()
	},
	setShaderProgram: function(a) {
		this._renderCmd.setShaderProgram(a)
	},
	getGLServerState: function() {
		return 0
	},
	setGLServerState: function(a) {},
	getBoundingBoxToWorld: function() {
		var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
			c = this.getNodeToWorldTransform(),
			a = cc.rectApplyAffineTransform(a, c);
		if(!this._children) return a;
		for(var b = this._children, d = 0; d < b.length; d++) {
			var e = b[d];
			e && e._visible && (e = e._getBoundingBoxToCurrentNode(c)) && (a = cc.rectUnion(a, e))
		}
		return a
	},
	_getBoundingBoxToCurrentNode: function(a) {
		var c = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		a = void 0 === a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
		c = cc.rectApplyAffineTransform(c, a);
		if(!this._children) return c;
		for(var b = this._children, d = 0; d < b.length; d++) {
			var e = b[d];
			e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (c = cc.rectUnion(c, e))
		}
		return c
	},
	getOpacity: function() {
		return this._realOpacity
	},
	getDisplayedOpacity: function() {
		return this._renderCmd.getDisplayedOpacity()
	},
	setOpacity: function(a) {
		this._realOpacity = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	updateDisplayedOpacity: function(a) {
		this._renderCmd._updateDisplayOpacity(a)
	},
	isCascadeOpacityEnabled: function() {
		return this._cascadeOpacityEnabled
	},
	setCascadeOpacityEnabled: function(a) {
		this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled = a, this._renderCmd.setCascadeOpacityEnabledDirty())
	},
	getColor: function() {
		var a = this._realColor;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	getDisplayedColor: function() {
		return this._renderCmd.getDisplayedColor()
	},
	setColor: function(a) {
		var c = this._realColor;
		c.r = a.r;
		c.g =
			a.g;
		c.b = a.b;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	updateDisplayedColor: function(a) {
		this._renderCmd._updateDisplayColor(a)
	},
	isCascadeColorEnabled: function() {
		return this._cascadeColorEnabled
	},
	setCascadeColorEnabled: function(a) {
		this._cascadeColorEnabled !== a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_initRendererCmd: function() {
		this._renderCmd = cc.renderer.getRenderCmd(this)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
	},
	enumerateChildren: function(a, c) {
		cc.assert(a && 0 != a.length, "Invalid name");
		cc.assert(null != c, "Invalid callback function");
		var b = a.length,
			d = 0,
			e = b,
			f = !1;
		2 < b && "/" === a[0] && "/" === a[1] && (f = !0, d = 2, e -= 2);
		var g = !1;
		3 < b && "/" === a[b - 3] && "." === a[b - 2] && "." === a[b - 1] && (g = !0, e -= 3);
		b = a.substr(d, e);
		g && (b = "[[:alnum:]]+/" + b);
		f ? this.doEnumerateRecursive(this, b, c) : this.doEnumerate(b,
			c)
	},
	doEnumerateRecursive: function(a, c, b) {
		if(!a.doEnumerate(c, b))
			for(var d = a.getChildren(), e = d.length, f = 0; f < e && (a = d[f], !this.doEnumerateRecursive(a, c, b)); f++);
	},
	doEnumerate: function(a, c) {
		var b = a.indexOf("/"),
			d = a,
			e = !1; - 1 !== b && (d = a.substr(0, b), e = !0);
		for(var b = !1, f, g = this._children, h = g.length, k = 0; k < h; k++)
			if(f = g[k], -1 !== f._name.indexOf(d))
				if(e) {
					if(b = f.doEnumerate(a, c)) break
				} else if(c(f)) {
			b = !0;
			break
		}
		return b
	}
});
cc.Node.create = function() {
	return new cc.Node
};
cc.Node._stateCallbackType = {
	onEnter: 1,
	onExit: 2,
	cleanup: 3,
	onEnterTransitionDidFinish: 4,
	updateTransform: 5,
	onExitTransitionDidStart: 6,
	sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(a, c) {
	this._needDraw = !0;
	this._target = a;
	this._callback = c;
	this.rendering = function(a, c, e) {
		this._callback && this._callback.call(this._target, a, c, e)
	}
};
cc.Node._dirtyFlags = {
	transformDirty: 1,
	visibleDirty: 2,
	colorDirty: 4,
	opacityDirty: 8,
	cacheDirty: 16,
	orderDirty: 32,
	textDirty: 64,
	gradientDirty: 128,
	all: 255
};
cc.Node.RenderCmd = function(a) {
	this._dirtyFlag = 1;
	this._node = a;
	this._needDraw = !1;
	this._anchorPointInPoints = new cc.Point(0, 0);
	this._transform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._worldTransform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._inverse = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._displayedOpacity = 255;
	this._displayedColor = cc.color(255, 255, 255, 255);
	this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
	this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
	constructor: cc.Node.RenderCmd,
	getAnchorPointInPoints: function() {
		return cc.p(this._anchorPointInPoints)
	},
	getDisplayedColor: function() {
		var a = this._displayedColor;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	getDisplayedOpacity: function() {
		return this._displayedOpacity
	},
	setCascadeColorEnabledDirty: function() {
		this._cascadeColorEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setCascadeOpacityEnabledDirty: function() {
		this._cascadeOpacityEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getParentToNodeTransform: function() {
		this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
		return this._inverse
	},
	detachFromParent: function() {},
	_updateAnchorPointInPoint: function() {
		var a = this._anchorPointInPoints,
			c = this._node._contentSize,
			b = this._node._anchorPoint;
		a.x = c.width * b.x;
		a.y = c.height * b.y;
		this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setDirtyFlag: function(a) {
		0 === this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this);
		this._dirtyFlag |= a
	},
	getParentRenderCmd: function() {
		return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
	},
	_updateDisplayColor: function(a) {
		var c = this._node,
			b = this._displayedColor,
			d = c._realColor,
			e;
		if(this._cascadeColorEnabledDirty && !c._cascadeColorEnabled) {
			b.r = d.r;
			b.g = d.g;
			b.b = d.b;
			b = new cc.Color(255, 255, 255, 255);
			a = c._children;
			c = 0;
			for(d = a.length; c < d; c++)(e = a[c]) && e._renderCmd && e._renderCmd._updateDisplayColor(b);
			this._cascadeColorEnabledDirty = !1
		} else if(void 0 ===
			a && (a = (a = c._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE), b.r = 0 | d.r * a.r / 255, b.g = 0 | d.g * a.g / 255, b.b = 0 | d.b * a.b / 255, c._cascadeColorEnabled)
			for(a = c._children, c = 0, d = a.length; c < d; c++)(e = a[c]) && e._renderCmd && (e._renderCmd._updateDisplayColor(b), e._renderCmd._updateColor());
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
	},
	_updateDisplayOpacity: function(a) {
		var c = this._node,
			b, d;
		if(this._cascadeOpacityEnabledDirty && !c._cascadeOpacityEnabled) {
			this._displayedOpacity = c._realOpacity;
			b = c._children;
			a = 0;
			for(c = b.length; a < c; a++)(d = b[a]) && d._renderCmd && d._renderCmd._updateDisplayOpacity(255);
			this._cascadeOpacityEnabledDirty = !1
		} else if(void 0 === a && (b = c._parent, a = 255, b && b._cascadeOpacityEnabled && (a = b.getDisplayedOpacity())), this._displayedOpacity = c._realOpacity * a / 255, c._cascadeOpacityEnabled)
			for(b = c._children, a = 0, c = b.length; a < c; a++)(d = b[a]) && d._renderCmd && (d._renderCmd._updateDisplayOpacity(this._displayedOpacity), d._renderCmd._updateColor());
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
	},
	_syncDisplayColor: function(a) {
		var c = this._node,
			b = this._displayedColor,
			d = c._realColor;
		void 0 === a && (a = (a = c._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
		b.r = 0 | d.r * a.r / 255;
		b.g = 0 | d.g * a.g / 255;
		b.b = 0 | d.b * a.b / 255
	},
	_syncDisplayOpacity: function(a) {
		var c = this._node;
		if(void 0 === a) {
			var b = c._parent;
			a = 255;
			b && b._cascadeOpacityEnabled && (a = b.getDisplayedOpacity())
		}
		this._displayedOpacity = c._realOpacity * a / 255
	},
	_updateColor: function() {},
	updateStatus: function() {
		var a = cc.Node._dirtyFlags,
			c = this._dirtyFlag,
			b = c & a.colorDirty,
			d = c & a.opacityDirty;
		b && this._updateDisplayColor();
		d && this._updateDisplayOpacity();
		(b || d) && this._updateColor();
		c & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	}
};
(function() {
	cc.Node.CanvasRenderCmd = function(a) {
		cc.Node.RenderCmd.call(this, a);
		this._cachedParent = null;
		this._cacheDirty = !1
	};
	var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	a.constructor = cc.Node.CanvasRenderCmd;
	a.transform = function(a, b) {
		var d = this.getNodeToParentTransform(),
			e = this._worldTransform;
		this._cacheDirty = !0;
		if(a) {
			var f = a._worldTransform;
			e.a = d.a * f.a + d.b * f.c;
			e.b = d.a * f.b + d.b * f.d;
			e.c = d.c * f.a + d.d * f.c;
			e.d = d.c * f.b + d.d * f.d;
			e.tx = f.a * d.tx + f.c * d.ty + f.tx;
			e.ty = f.d * d.ty +
				f.ty + f.b * d.tx
		} else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
		if(b && (d = this._node._children) && 0 !== d.length)
			for(e = 0, f = d.length; e < f; e++) d[e]._renderCmd.transform(this, b)
	};
	a.getNodeToParentTransform = function() {
		var a = this._node,
			b = !1;
		a._usingNormalizedPosition && a._parent && (b = a._parent._contentSize, a._position.x = a._normalizedPosition.x * b.width, a._position.y = a._normalizedPosition.y * b.height, a._normalizedPositionDirty = !1, b = !0);
		if(b || this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			b = this._transform;
			b.tx = a._position.x;
			b.ty = a._position.y;
			var d = 1,
				e = 0,
				f = 0,
				g = 1;
			a._rotationX && (g = 0.017453292519943295 * a._rotationX, f = Math.sin(g), g = Math.cos(g));
			a._rotationY && (e = 0.017453292519943295 * a._rotationY, d = Math.cos(e), e = -Math.sin(e));
			b.a = d;
			b.b = e;
			b.c = f;
			b.d = g;
			var h = a._scaleX,
				k = a._scaleY,
				m = this._anchorPointInPoints.x,
				n = this._anchorPointInPoints.y,
				p = 1E-6 > h && -1E-6 < h ? 1E-6 : h,
				s = 1E-6 > k && -1E-6 < k ? 1E-6 : k;
			if(1 !== h || 1 !== k) d = b.a *= p, e = b.b *= p, f = b.c *= s, g = b.d *= s;
			if(a._skewX || a._skewY) h = Math.tan(-a._skewX * Math.PI / 180), k = Math.tan(-a._skewY *
				Math.PI / 180), Infinity === h && (h = 99999999), Infinity === k && (k = 99999999), p = n * h, s = m * k, b.a = d - f * k, b.b = e - g * k, b.c = f - d * h, b.d = g - e * h, b.tx += d * p + f * s, b.ty += e * p + g * s;
			b.tx -= d * m + f * n;
			b.ty -= e * m + g * n;
			a._ignoreAnchorPointForPosition && (b.tx += m, b.ty += n);
			a._additionalTransformDirty && (this._transform = cc.affineTransformConcat(b, a._additionalTransform))
		}
		return this._transform
	};
	a.visit = function(a) {
		var b = this._node;
		if(b._visible) {
			if(a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
			var d = b._children,
				e;
			this._syncStatus(a);
			a = d.length;
			if(0 < a) {
				b.sortAllChildren();
				for(b = 0; b < a; b++)
					if(e = d[b], 0 > e._localZOrder) e._renderCmd.visit(this);
					else break;
				for(cc.renderer.pushRenderCommand(this); b < a; b++) d[b]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0
		}
	};
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag &
			b.transformDirty && (d |= b.transformDirty);
		var e = d & b.colorDirty,
			f = d & b.opacityDirty,
			b = d & b.transformDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e && this._updateColor();
		b && this.transform(a)
	};
	a.setDirtyFlag = function(a) {
		cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a);
		this._setCacheDirty();
		this._cachedParent && this._cachedParent.setDirtyFlag(a)
	};
	a._setCacheDirty = function() {
		if(!1 === this._cacheDirty) {
			this._cacheDirty = !0;
			var a = this._cachedParent;
			a && a !== this && a._setNodeDirtyForCache &&
				a._setNodeDirtyForCache()
		}
	};
	a._setCachedParent = function(a) {
		if(this._cachedParent !== a) {
			this._cachedParent = a;
			for(var b = this._node._children, d = 0, e = b.length; d < e; d++) b[d]._renderCmd._setCachedParent(a)
		}
	};
	a.detachFromParent = function() {
		this._cachedParent = null;
		for(var a = this._node._children, b, d = 0, e = a.length; d < e; d++)(b = a[d]) && b._renderCmd && b._renderCmd.detachFromParent()
	};
	a.setShaderProgram = function(a) {};
	a.getShaderProgram = function() {
		return null
	};
	cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(a) {
		return a ?
			a.src === cc.SRC_ALPHA && a.dst === cc.ONE || a.src === cc.ONE && a.dst === cc.ONE ? "lighter" : a.src === cc.ZERO && a.dst === cc.SRC_ALPHA ? "destination-in" : a.src === cc.ZERO && a.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
	}
})();
(function() {
	cc.Node.WebGLRenderCmd = function(a) {
		cc.Node.RenderCmd.call(this, a);
		a = new cc.math.Matrix4;
		var b = a.mat;
		b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
		b[10] = b[15] = 1;
		this._transform4x4 = a;
		this._stackMatrix = new cc.math.Matrix4;
		this._camera = this._shaderProgram = null
	};
	var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	a.constructor = cc.Node.WebGLRenderCmd;
	a.getNodeToParentTransform = function() {
		var a = this._node;
		if(a._usingNormalizedPosition && a._parent) {
			var b = a._parent._contentSize;
			a._position.x = a._normalizedPosition.x * b.width;
			a._position.y = a._normalizedPosition.y * b.height;
			a._normalizedPositionDirty = !1
		}
		if(this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			var b = a._position.x,
				d = a._position.y,
				e = this._anchorPointInPoints.x,
				f = -e,
				g = this._anchorPointInPoints.y,
				h = -g,
				k = a._scaleX,
				m = a._scaleY,
				n = 0.017453292519943295 * a._rotationX,
				p = 0.017453292519943295 * a._rotationY;
			a._ignoreAnchorPointForPosition && (b += e, d += g);
			var s = 1,
				q = 0,
				t = 1,
				r = 0;
			if(0 !== a._rotationX || 0 !== a._rotationY) s = Math.cos(-n), q = Math.sin(-n),
				t = Math.cos(-p), r = Math.sin(-p);
			n = a._skewX || a._skewY;
			n || 0 === e && 0 === g || (b += t * f * k + -q * h * m, d += r * f * k + s * h * m);
			p = this._transform;
			p.a = t * k;
			p.b = r * k;
			p.c = -q * m;
			p.d = s * m;
			p.tx = b;
			p.ty = d;
			n && (p = cc.affineTransformConcat({
				a: 1,
				b: Math.tan(cc.degreesToRadians(a._skewY)),
				c: Math.tan(cc.degreesToRadians(a._skewX)),
				d: 1,
				tx: 0,
				ty: 0
			}, p), 0 !== e || 0 !== g) && (p = cc.affineTransformTranslate(p, f, h));
			a._additionalTransformDirty && (p = cc.affineTransformConcat(p, a._additionalTransform), a._additionalTransformDirty = !1);
			this._transform = p
		}
		return this._transform
	};
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag & b.transformDirty && (d |= b.transformDirty);
		e = d & b.colorDirty;
		b = d & b.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		b && this._syncDisplayOpacity();
		(e || b) && this._updateColor();
		this.transform(a)
	};
	a._updateColor = function() {};
	a.visit = function(a) {
		var b =
			this._node;
		if(b._visible) {
			a = a || this.getParentRenderCmd();
			b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._syncStatus(a);
			d.top = this._stackMatrix;
			if((a = b._children) && 0 < a.length) {
				var e = a.length;
				b.sortAllChildren();
				for(b = 0; b < e; b++)
					if(a[b] && 0 > a[b]._localZOrder) a[b]._renderCmd.visit(this);
					else break;
				for(cc.renderer.pushRenderCommand(this); b < e; b++) a[b] && a[b]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.transform = function(a, b) {
		var d = this._transform4x4,
			e = this._stackMatrix,
			f = this._node,
			g = (a = a || this.getParentRenderCmd()) ? a._stackMatrix : cc.current_stack.top,
			h = this.getNodeToParentTransform();
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
		var k = d.mat;
		k[0] = h.a;
		k[4] = h.c;
		k[12] = h.tx;
		k[1] = h.b;
		k[5] = h.d;
		k[13] = h.ty;
		k[14] = f._vertexZ;
		cc.kmMat4Multiply(e, g, d);
		null === f._camera || null !== f.grid && f.grid.isActive() || (g = this._anchorPointInPoints.x, h = this._anchorPointInPoints.y,
			0 !== g || 0 !== h ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (g |= 0, h |= 0), k = cc.math.Matrix4.createByTranslation(g, h, 0, d), e.multiply(k), f._camera._locateForRenderer(e), k = cc.math.Matrix4.createByTranslation(-g, -h, 0, k), e.multiply(k), d.identity()) : f._camera._locateForRenderer(e));
		if(b && f._children && 0 !== f._children.length)
			for(f = f._children, d = 0, e = f.length; d < e; d++) f[d]._renderCmd.transform(this, b)
	};
	a.setShaderProgram = function(a) {
		this._shaderProgram = a
	};
	a.getShaderProgram = function() {
		return this._shaderProgram
	}
})();
cc.AtlasNode = cc.Node.extend({
	textureAtlas: null,
	quadsToDraw: 0,
	_itemsPerRow: 0,
	_itemsPerColumn: 0,
	_itemWidth: 0,
	_itemHeight: 0,
	_opacityModifyRGB: !1,
	_blendFunc: null,
	_ignoreContentScaleFactor: !1,
	_className: "AtlasNode",
	_textureForCanvas: null,
	ctor: function(a, c, b, d) {
		cc.Node.prototype.ctor.call(this);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._ignoreContentScaleFactor = !1;
		void 0 !== d && this.initWithTileFile(a, c, b, d)
	},
	_createRenderCmd: function() {
		this._renderCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ?
			new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
	},
	updateAtlasValues: function() {
		cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
	},
	getColor: function() {
		return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
	},
	setOpacityModifyRGB: function(a) {
		var c = this.color;
		this._opacityModifyRGB = a;
		this.setColor(c)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a,
		c) {
		this._blendFunc = void 0 === c ? a : {
			src: a,
			dst: c
		}
	},
	setTextureAtlas: function(a) {
		this.textureAtlas = a
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	getQuadsToDraw: function() {
		return this.quadsToDraw
	},
	setQuadsToDraw: function(a) {
		this.quadsToDraw = a
	},
	initWithTileFile: function(a, c, b, d) {
		if(!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
		a = cc.textureCache.addImage(a);
		return this.initWithTexture(a, c, b, d)
	},
	initWithTexture: function(a, c, b, d) {
		return this._renderCmd.initWithTexture(a, c, b, d)
	},
	setColor: function(a) {
		this._renderCmd.setColor(a)
	},
	setOpacity: function(a) {
		this._renderCmd.setOpacity(a)
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	_setIgnoreContentScaleFactor: function(a) {
		this._ignoreContentScaleFactor = a
	}
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(a, c, b, d) {
	return new cc.AtlasNode(a, c, b, d)
};
(function() {
	cc.AtlasNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !1;
		this._colorUnmodified = cc.color.WHITE;
		this._texture = this._originalTexture = null
	};
	var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.AtlasNode.CanvasRenderCmd;
	a.initWithTexture = function(a, b, d, e) {
		var f = this._node;
		f._itemWidth = b;
		f._itemHeight = d;
		f._opacityModifyRGB = !0;
		this._originalTexture = a;
		if(!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._texture = this._originalTexture;
		this._calculateMaxItems();
		f.quadsToDraw = e;
		return !0
	};
	a.setColor = function(a) {
		var b = this._node._realColor;
		if(b.r !== a.r || b.g !== a.g || b.b !== a.b) this._colorUnmodified = a, this._changeTextureColor()
	};
	a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ? function() {
		var a = this._node,
			b = a.getTexture();
		if(b && this._originalTexture) {
			var d = this._originalTexture.getHtmlElementObj();
			if(d) {
				var e = b.getHtmlElementObj(),
					b = cc.rect(0, 0, d.width, d.height);
				e instanceof HTMLCanvasElement ?
					cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._colorUnmodified, b, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._colorUnmodified, b), b = new cc.Texture2D, b.initWithElement(e), b.handleLoadedTexture(), a.setTexture(b))
			}
		}
	} : function() {
		var a = this._node,
			b, d = a.getTexture();
		if(d && this._originalTexture && (b = d.getHtmlElementObj())) {
			var e = this._originalTexture.getHtmlElementObj();
			if(d = cc.textureCache.getTextureColors(e)) e = cc.rect(0, 0, e.width, e.height), b instanceof HTMLCanvasElement ?
				cc.Sprite.CanvasRenderCmd._generateTintImage(b, d, this._displayedColor, e, b) : (b = cc.Sprite.CanvasRenderCmd._generateTintImage(b, d, this._displayedColor, e), d = new cc.Texture2D, d.initWithElement(b), d.handleLoadedTexture(), a.setTexture(d))
		}
	};
	a.setOpacity = function(a) {
		cc.Node.prototype.setOpacity.call(this._node, a)
	};
	a.getTexture = function() {
		return this._texture
	};
	a.setTexture = function(a) {
		this._texture = a
	};
	a._calculateMaxItems = function() {
		var a = this._node,
			b = this._texture.getContentSize();
		a._itemsPerColumn = 0 | b.height /
			a._itemHeight;
		a._itemsPerRow = 0 | b.width / a._itemWidth
	}
})();
(function() {
	cc.AtlasNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureAtlas = null;
		this._colorUnmodified = cc.color.WHITE;
		this._uniformColor = this._colorF32Array = null;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
		this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
	};
	var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor =
		cc.AtlasNode.WebGLRenderCmd;
	a._updateBlendFunc = function() {
		var a = this._node;
		this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
	};
	a._updateOpacityModifyRGB = function() {
		this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
	};
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var b = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glBlendFunc(b._blendFunc.src,
			b._blendFunc.dst);
		this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(b.quadsToDraw, 0))
	};
	a.initWithTexture = function(a, b, d, e) {
		var f = this._node;
		f._itemWidth = b;
		f._itemHeight = d;
		this._colorUnmodified = cc.color.WHITE;
		f._opacityModifyRGB = !0;
		f._blendFunc.src = cc.BLEND_SRC;
		f._blendFunc.dst = cc.BLEND_DST;
		b = f._realColor;
		this._colorF32Array = new Float32Array([b.r / 255, b.g / 255, b.b / 255, f._realOpacity / 255]);
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(a, e);
		if(!this._textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB();
		this._calculateMaxItems();
		f.quadsToDraw = e;
		return !0
	};
	a.setColor = function(a) {
		var b = cc.color(a.r, a.g, a.b),
			d = this._node;
		this._colorUnmodified = a;
		a = this._displayedOpacity;
		d._opacityModifyRGB && (b.r = b.r * a / 255, b.g = b.g * a / 255, b.b = b.b * a / 255);
		cc.Node.prototype.setColor.call(d, b)
	};
	a.setOpacity = function(a) {
		var b = this._node;
		cc.Node.prototype.setOpacity.call(b,
			a);
		b._opacityModifyRGB && (b.color = this._colorUnmodified)
	};
	a._updateColor = function() {
		var a = this._displayedColor;
		this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
	};
	a.getTexture = function() {
		return this._textureAtlas.texture
	};
	a.setTexture = function(a) {
		this._textureAtlas.texture = a;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB()
	};
	a._calculateMaxItems = function() {
		var a = this._node,
			b = this._textureAtlas.texture,
			d = b.getContentSize();
		a._ignoreContentScaleFactor && (d =
			b.getContentSizeInPixels());
		a._itemsPerColumn = 0 | d.height / a._itemHeight;
		a._itemsPerRow = 0 | d.width / a._itemWidth
	}
})();
cc._tmp.WebGLTexture2D = function() {
	cc.Texture2D = cc.Class.extend({
		_pVRHaveAlphaPremultiplied: !0,
		_pixelFormat: null,
		_pixelsWide: 0,
		_pixelsHigh: 0,
		_name: "",
		_contentSize: null,
		maxS: 0,
		maxT: 0,
		_hasPremultipliedAlpha: !1,
		_hasMipmaps: !1,
		shaderProgram: null,
		_textureLoaded: !1,
		_htmlElementObj: null,
		_webTextureObj: null,
		url: null,
		ctor: function() {
			this._contentSize = cc.size(0, 0);
			this._pixelFormat = cc.Texture2D.defaultPixelFormat
		},
		releaseTexture: function() {
			this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
			cc.loader.release(this.url)
		},
		getPixelFormat: function() {
			return this._pixelFormat
		},
		getPixelsWide: function() {
			return this._pixelsWide
		},
		getPixelsHigh: function() {
			return this._pixelsHigh
		},
		getName: function() {
			return this._webTextureObj
		},
		getContentSize: function() {
			return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
		},
		_getWidth: function() {
			return this._contentSize.width / cc.contentScaleFactor()
		},
		_getHeight: function() {
			return this._contentSize.height / cc.contentScaleFactor()
		},
		getContentSizeInPixels: function() {
			return this._contentSize
		},
		getMaxS: function() {
			return this.maxS
		},
		setMaxS: function(a) {
			this.maxS = a
		},
		getMaxT: function() {
			return this.maxT
		},
		setMaxT: function(a) {
			this.maxT = a
		},
		getShaderProgram: function() {
			return this.shaderProgram
		},
		setShaderProgram: function(a) {
			this.shaderProgram = a
		},
		hasPremultipliedAlpha: function() {
			return this._hasPremultipliedAlpha
		},
		hasMipmaps: function() {
			return this._hasMipmaps
		},
		description: function() {
			return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
				this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
		},
		releaseData: function(a) {},
		keepData: function(a, c) {
			return a
		},
		initWithData: function(a, c, b, d, e) {
			var f = cc.Texture2D,
				g = cc._renderContext,
				h = g.RGBA,
				k = g.UNSIGNED_BYTE,
				m = b * cc.Texture2D._B[c] / 8;
			0 === m % 8 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 8) : 0 === m % 4 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 4) : 0 === m % 2 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 2) : g.pixelStorei(g.UNPACK_ALIGNMENT, 1);
			this._webTextureObj = g.createTexture();
			cc.glBindTexture2D(this);
			g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR);
			g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR);
			g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE);
			g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE);
			switch(c) {
				case f.PIXEL_FORMAT_RGBA8888:
					h = g.RGBA;
					break;
				case f.PIXEL_FORMAT_RGB888:
					h = g.RGB;
					break;
				case f.PIXEL_FORMAT_RGBA4444:
					k = g.UNSIGNED_SHORT_4_4_4_4;
					break;
				case f.PIXEL_FORMAT_RGB5A1:
					k = g.UNSIGNED_SHORT_5_5_5_1;
					break;
				case f.PIXEL_FORMAT_RGB565:
					k = g.UNSIGNED_SHORT_5_6_5;
					break;
				case f.PIXEL_FORMAT_AI88:
					h = g.LUMINANCE_ALPHA;
					break;
				case f.PIXEL_FORMAT_A8:
					h = g.ALPHA;
					break;
				case f.PIXEL_FORMAT_I8:
					h = g.LUMINANCE;
					break;
				default:
					cc.assert(0, cc._LogInfos.Texture2D_initWithData)
			}
			g.texImage2D(g.TEXTURE_2D, 0, h, b, d, 0, h, k, a);
			this._contentSize.width = e.width;
			this._contentSize.height = e.height;
			this._pixelsWide = b;
			this._pixelsHigh = d;
			this._pixelFormat = c;
			this.maxS = e.width / b;
			this.maxT = e.height / d;
			this._hasMipmaps = this._hasPremultipliedAlpha = !1;
			this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
			return this._textureLoaded = !0
		},
		drawAtPoint: function(a) {
			var c = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
				b = this._pixelsWide * this.maxS,
				d = this._pixelsHigh * this.maxT;
			a = [a.x, a.y, 0, b + a.x, a.y, 0, a.x, d + a.y, 0, b + a.x, d + a.y, 0];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			b = cc._renderContext;
			b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, a);
			b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
				2, b.FLOAT, !1, 0, c);
			b.drawArrays(b.TRIANGLE_STRIP, 0, 4)
		},
		drawInRect: function(a) {
			var c = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
			a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			var b = cc._renderContext;
			b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, a);
			b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
				2, b.FLOAT, !1, 0, c);
			b.drawArrays(b.TRIANGLE_STRIP, 0, 4)
		},
		initWithImage: function(a) {
			if(null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
			var c = a.getWidth(),
				b = a.getHeight(),
				d = cc.configuration.getMaxTextureSize();
			if(c > d || b > d) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, c, b, d, d), !1;
			this._textureLoaded = !0;
			return this._initPremultipliedATextureWithImage(a, c, b)
		},
		initWithElement: function(a) {
			a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a, this._textureLoaded = !0)
		},
		getHtmlElementObj: function() {
			return this._htmlElementObj
		},
		isLoaded: function() {
			return this._textureLoaded
		},
		handleLoadedTexture: function(a) {
			a = void 0 === a ? !1 : a;
			if(cc._rendererInitialized) {
				if(!this._htmlElementObj) {
					var c = cc.loader.getRes(this.url);
					if(!c) return;
					this.initWithElement(c)
				}
				this._htmlElementObj.width && this._htmlElementObj.height && (c = cc._renderContext, cc.glBindTexture2D(this), c.pixelStorei(c.UNPACK_ALIGNMENT, 4), a && c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), c.texImage2D(c.TEXTURE_2D,
						0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, this._htmlElementObj), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a && c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), c = this._htmlElementObj.height, this._pixelsWide =
					this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = c, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasPremultipliedAlpha = a, this._hasMipmaps = !1, this.dispatchEvent("load"))
			}
		},
		initWithString: function(a, c, b, d, e, f) {
			cc.log(cc._LogInfos.Texture2D_initWithString);
			return null
		},
		initWithETCFile: function(a) {
			cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
			return !1
		},
		initWithPVRFile: function(a) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
			return !1
		},
		initWithPVRTCData: function(a, c, b, d, e, f) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
			return !1
		},
		setTexParameters: function(a, c, b, d) {
			var e = cc._renderContext;
			void 0 !== c && (a = {
				minFilter: a,
				magFilter: c,
				wrapS: b,
				wrapT: d
			});
			cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || a.wrapS === e.CLAMP_TO_EDGE && a.wrapT === e.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
			cc.glBindTexture2D(this);
			e.texParameteri(e.TEXTURE_2D,
				e.TEXTURE_MIN_FILTER, a.minFilter);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, a.magFilter);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a.wrapS);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a.wrapT)
		},
		setAntiAliasTexParameters: function() {
			var a = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
		},
		setAliasTexParameters: function() {
			var a = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
		},
		generateMipmap: function() {
			cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
			cc.glBindTexture2D(this);
			cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
			this._hasMipmaps = !0
		},
		stringForFormat: function() {
			return cc.Texture2D._M[this._pixelFormat]
		},
		bitsPerPixelForFormat: function(a) {
			a = a || this._pixelFormat;
			var c = cc.Texture2D._B[a];
			if(null != c) return c;
			cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
			return -1
		},
		_initPremultipliedATextureWithImage: function(a, c, b) {
			var d = cc.Texture2D,
				e = a.getData(),
				f = null,
				f = null,
				g = a.hasAlpha(),
				h = cc.size(a.getWidth(), a.getHeight()),
				k = d.defaultPixelFormat,
				m = a.getBitsPerComponent();
			g || (8 <= m ? k = d.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), k = d.PIXEL_FORMAT_RGB565));
			var n = c * b;
			if(k === d.PIXEL_FORMAT_RGB565)
				if(g)
					for(e = new Uint16Array(c * b), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 2 << 5 | (f[m] >> 16 & 255) >> 3 << 0;
				else
					for(e = new Uint16Array(c * b), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] & 255) >> 3 << 11 | (f[m] & 255) >> 2 << 5 | (f[m] & 255) >> 3 << 0;
			else if(k === d.PIXEL_FORMAT_RGBA4444)
				for(e = new Uint16Array(c * b), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >>
					0 & 255) >> 4 << 12 | (f[m] >> 8 & 255) >> 4 << 8 | (f[m] >> 16 & 255) >> 4 << 4 | (f[m] >> 24 & 255) >> 4 << 0;
			else if(k === d.PIXEL_FORMAT_RGB5A1)
				for(e = new Uint16Array(c * b), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 3 << 6 | (f[m] >> 16 & 255) >> 3 << 1 | (f[m] >> 24 & 255) >> 7 << 0;
			else if(k === d.PIXEL_FORMAT_A8)
				for(e = new Uint8Array(c * b), f = a.getData(), m = 0; m < n; ++m) e[m] = f >> 24 & 255;
			if(g && k === d.PIXEL_FORMAT_RGB888)
				for(f = a.getData(), e = new Uint8Array(c * b * 3), m = 0; m < n; ++m) e[3 * m] = f >> 0 & 255, e[3 * m + 1] = f >> 8 & 255, e[3 * m + 2] = f >> 16 & 255;
			this.initWithData(e,
				k, c, b, h);
			a.getData();
			this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
			return !0
		},
		addLoadedEventListener: function(a, c) {
			this.addEventListener("load", a, c)
		},
		removeLoadedEventListener: function(a) {
			this.removeEventListener("load", a)
		}
	})
};
cc._tmp.WebGLTextureAtlas = function() {
	var a = cc.TextureAtlas.prototype;
	a._setupVBO = function() {
		var a = cc._renderContext;
		this._buffersVBO[0] = a.createBuffer();
		this._buffersVBO[1] = a.createBuffer();
		this._quadsWebBuffer = a.createBuffer();
		this._mapBuffers()
	};
	a._mapBuffers = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER,
			this._indices, a.STATIC_DRAW)
	};
	a.drawNumberOfQuads = function(a, b) {
		b = b || 0;
		if(0 !== a && this.texture && this.texture.isLoaded()) {
			var d = cc._renderContext;
			cc.glBindTexture2D(this.texture);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			d.bindBuffer(d.ARRAY_BUFFER, this._quadsWebBuffer);
			this.dirty && (d.bufferData(d.ARRAY_BUFFER, this._quadsArrayBuffer, d.DYNAMIC_DRAW), this.dirty = !1);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 24, 16);
			d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
			cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? d.drawElements(d.TRIANGLE_STRIP, 6 * a, d.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT) : d.drawElements(d.TRIANGLES, 6 * a, d.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT);
			cc.g_NumberOfDraws++
		}
	}
};
cc._tmp.WebGLTextureCache = function() {
	var a = cc.textureCache;
	a.handleLoadedTexture = function(a) {
		var b = this._textures,
			d;
		cc._rendererInitialized || (b = this._loadedTexturesBefore);
		d = b[a];
		d || (d = b[a] = new cc.Texture2D, d.url = a);
		".png" === cc.path.extname(a) ? d.handleLoadedTexture(!0) : d.handleLoadedTexture()
	};
	a.addImage = function(a, b, d) {
		cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
		var e = this._textures;
		cc._rendererInitialized || (e = this._loadedTexturesBefore);
		var f = e[a] || e[cc.loader._aliases[a]];
		if(f) return f.isLoaded() ?
			b && b.call(d, f) : f.addEventListener("load", function() {
				b && b.call(d, f)
			}, d), f;
		f = e[a] = new cc.Texture2D;
		f.url = a;
		(cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(f, h) {
			if(f) return b && b.call(d, f);
			cc.textureCache.handleLoadedTexture(a);
			var k = e[a];
			b && b.call(d, k)
		});
		return f
	};
	a.addImageAsync = a.addImage;
	a = null
};
cc._tmp.PrototypeTexture2D = function() {
	var a = cc.Texture2D;
	a.PVRImagesHavePremultipliedAlpha = function(a) {
		cc.PVRHaveAlphaPremultiplied_ = a
	};
	a.PIXEL_FORMAT_RGBA8888 = 2;
	a.PIXEL_FORMAT_RGB888 = 3;
	a.PIXEL_FORMAT_RGB565 = 4;
	a.PIXEL_FORMAT_A8 = 5;
	a.PIXEL_FORMAT_I8 = 6;
	a.PIXEL_FORMAT_AI88 = 7;
	a.PIXEL_FORMAT_RGBA4444 = 8;
	a.PIXEL_FORMAT_RGB5A1 = 7;
	a.PIXEL_FORMAT_PVRTC4 = 9;
	a.PIXEL_FORMAT_PVRTC2 = 10;
	a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
	a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT;
	var c = cc.Texture2D._M = {};
	c[a.PIXEL_FORMAT_RGBA8888] =
		"RGBA8888";
	c[a.PIXEL_FORMAT_RGB888] = "RGB888";
	c[a.PIXEL_FORMAT_RGB565] = "RGB565";
	c[a.PIXEL_FORMAT_A8] = "A8";
	c[a.PIXEL_FORMAT_I8] = "I8";
	c[a.PIXEL_FORMAT_AI88] = "AI88";
	c[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
	c[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
	c[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
	c[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
	c = cc.Texture2D._B = {};
	c[a.PIXEL_FORMAT_RGBA8888] = 32;
	c[a.PIXEL_FORMAT_RGB888] = 24;
	c[a.PIXEL_FORMAT_RGB565] = 16;
	c[a.PIXEL_FORMAT_A8] = 8;
	c[a.PIXEL_FORMAT_I8] = 8;
	c[a.PIXEL_FORMAT_AI88] = 16;
	c[a.PIXEL_FORMAT_RGBA4444] =
		16;
	c[a.PIXEL_FORMAT_RGB5A1] = 16;
	c[a.PIXEL_FORMAT_PVRTC4] = 4;
	c[a.PIXEL_FORMAT_PVRTC2] = 3;
	a = cc.Texture2D.prototype;
	cc.defineGetterSetter(a, "name", a.getName);
	cc.defineGetterSetter(a, "pixelFormat", a.getPixelFormat);
	cc.defineGetterSetter(a, "pixelsWidth", a.getPixelsWide);
	cc.defineGetterSetter(a, "pixelsHeight", a.getPixelsHigh);
	cc.defineGetterSetter(a, "width", a._getWidth);
	cc.defineGetterSetter(a, "height", a._getHeight)
};
cc._tmp.PrototypeTextureAtlas = function() {
	var a = cc.TextureAtlas.prototype;
	cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
	cc.defineGetterSetter(a, "capacity", a.getCapacity);
	cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.Texture2D = cc.Class.extend({
	_contentSize: null,
	_textureLoaded: !1,
	_htmlElementObj: null,
	url: null,
	_pattern: null,
	ctor: function() {
		this._contentSize = cc.size(0, 0);
		this._textureLoaded = !1;
		this._htmlElementObj = null;
		this._pattern = ""
	},
	getPixelsWide: function() {
		return this._contentSize.width
	},
	getPixelsHigh: function() {
		return this._contentSize.height
	},
	getContentSize: function() {
		var a = cc.contentScaleFactor();
		return cc.size(this._contentSize.width / a, this._contentSize.height /
			a)
	},
	_getWidth: function() {
		return this._contentSize.width / cc.contentScaleFactor()
	},
	_getHeight: function() {
		return this._contentSize.height / cc.contentScaleFactor()
	},
	getContentSizeInPixels: function() {
		return this._contentSize
	},
	initWithElement: function(a) {
		a && (this._htmlElementObj = a, this._contentSize.width = a.width, this._contentSize.height = a.height, this._textureLoaded = !0)
	},
	getHtmlElementObj: function() {
		return this._htmlElementObj
	},
	isLoaded: function() {
		return this._textureLoaded
	},
	handleLoadedTexture: function() {
		if(!this._textureLoaded) {
			if(!this._htmlElementObj) {
				var a =
					cc.loader.getRes(this.url);
				if(!a) return;
				this.initWithElement(a)
			}
			a = this._htmlElementObj;
			this._contentSize.width = a.width;
			this._contentSize.height = a.height;
			this.dispatchEvent("load")
		}
	},
	description: function() {
		return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
	},
	initWithData: function(a, c, b, d, e) {
		return !1
	},
	initWithImage: function(a) {
		return !1
	},
	initWithString: function(a, c, b, d, e, f) {
		return !1
	},
	releaseTexture: function() {
		cc.loader.release(this.url)
	},
	getName: function() {
		return null
	},
	getMaxS: function() {
		return 1
	},
	setMaxS: function(a) {},
	getMaxT: function() {
		return 1
	},
	setMaxT: function(a) {},
	getPixelFormat: function() {
		return null
	},
	getShaderProgram: function() {
		return null
	},
	setShaderProgram: function(a) {},
	hasPremultipliedAlpha: function() {
		return !1
	},
	hasMipmaps: function() {
		return !1
	},
	releaseData: function(a) {},
	keepData: function(a, c) {
		return a
	},
	drawAtPoint: function(a) {},
	drawInRect: function(a) {},
	initWithETCFile: function(a) {
		cc.log(cc._LogInfos.Texture2D_initWithETCFile);
		return !1
	},
	initWithPVRFile: function(a) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
		return !1
	},
	initWithPVRTCData: function(a, c, b, d, e, f) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
		return !1
	},
	setTexParameters: function(a, c, b, d) {
		void 0 !== c && (a = {
			minFilter: a,
			magFilter: c,
			wrapS: b,
			wrapT: d
		});
		this._pattern = a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? "repeat" : a.wrapS === cc.REPEAT ? "repeat-x" : a.wrapT === cc.REPEAT ? "repeat-y" : ""
	},
	setAntiAliasTexParameters: function() {},
	setAliasTexParameters: function() {},
	generateMipmap: function() {},
	stringForFormat: function() {
		return ""
	},
	bitsPerPixelForFormat: function(a) {
		return -1
	},
	addLoadedEventListener: function(a, c) {
		this.addEventListener("load", a, c)
	},
	removeLoadedEventListener: function(a) {
		this.removeEventListener("load", a)
	},
	_grayElementObj: null,
	_backupElement: null,
	_isGray: !1,
	_switchToGray: function(a) {
		this._textureLoaded && this._isGray !== a && ((this._isGray = a) ? (this._backupElement = this._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj =
			this._backupElement))
	}
}), cc.Texture2D._generateGrayTexture = function(a, c, b) {
	if(null === a) return null;
	b = b || cc.newElement("canvas");
	c = c || cc.rect(0, 0, a.width, a.height);
	b.width = c.width;
	b.height = c.height;
	var d = b.getContext("2d");
	d.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
	a = d.getImageData(0, 0, c.width, c.height);
	c = a.data;
	for(var e = 0, f = c.length; e < f; e += 4) c[e] = c[e + 1] = c[e + 2] = 0.34 * c[e] + 0.5 * c[e + 1] + 0.16 * c[e + 2];
	d.putImageData(a, 0, 0);
	return b
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile,
	"TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
	_textures: {},
	_textureColorsCache: {},
	_textureKeySeq: 0 | 1E3 * Math.random(),
	_loadedTexturesBefore: {},
	_initializingRenderer: function() {
		var a, c = this._loadedTexturesBefore,
			b = this._textures;
		for(a in c) {
			var d = c[a];
			d.handleLoadedTexture();
			b[a] = d
		}
		this._loadedTexturesBefore = {}
	},
	addPVRTCImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addPVRTCImage)
	},
	addETCImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addETCImage)
	},
	description: function() {
		return "\x3cTextureCache | Number of textures \x3d " +
			this._textures.length + "\x3e"
	},
	textureForKey: function(a) {
		cc.log(cc._LogInfos.textureCache_textureForKey);
		return this.getTextureForKey(a)
	},
	getTextureForKey: function(a) {
		return this._textures[a] || this._textures[cc.loader._aliases[a]]
	},
	getKeyByTexture: function(a) {
		for(var c in this._textures)
			if(this._textures[c] === a) return c;
		return null
	},
	_generalTextureKey: function() {
		this._textureKeySeq++;
		return "_textureKey_" + this._textureKeySeq
	},
	getTextureColors: function(a) {
		var c = this.getKeyByTexture(a);
		c || (c = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
		this._textureColorsCache[c] || (this._textureColorsCache[c] = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor(a));
		return this._textureColorsCache[c]
	},
	addPVRImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addPVRImage)
	},
	removeAllTextures: function() {
		var a = this._textures,
			c;
		for(c in a) a[c] && a[c].releaseTexture();
		this._textures = {}
	},
	removeTexture: function(a) {
		if(a) {
			var c = this._textures,
				b;
			for(b in c) c[b] === a && (c[b].releaseTexture(), delete c[b])
		}
	},
	removeTextureForKey: function(a) {
		null !=
			a && this._textures[a] && delete this._textures[a]
	},
	cacheImage: function(a, c) {
		if(c instanceof cc.Texture2D) this._textures[a] = c;
		else {
			var b = new cc.Texture2D;
			b.initWithElement(c);
			b.handleLoadedTexture();
			this._textures[a] = b
		}
	},
	addUIImage: function(a, c) {
		cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
		if(c && this._textures[c]) return this._textures[c];
		var b = new cc.Texture2D;
		b.initWithImage(a);
		null != c ? this._textures[c] = b : cc.log(cc._LogInfos.textureCache_addUIImage);
		return b
	},
	dumpCachedTextureInfo: function() {
		var a =
			0,
			c = 0,
			b = this._textures,
			d;
		for(d in b) {
			var e = b[d];
			a++;
			e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight);
			c += e.pixelsWidth * e.pixelsHeight * 4
		}
		b = this._textureColorsCache;
		for(d in b) {
			var e = b[d],
				f;
			for(f in e) {
				var g = e[f];
				a++;
				cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, g.width, g.height);
				c += g.width *
					g.height * 4
			}
		}
		cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, c / 1024, (c / 1048576).toFixed(2))
	},
	_clear: function() {
		this._textures = {};
		this._textureColorsCache = {};
		this._textureKeySeq = 0 | 1E3 * Math.random();
		this._loadedTexturesBefore = {}
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
	var c = this._textures,
		b = c[a];
	b || (b = c[a] = new cc.Texture2D, b.url = a);
	b.handleLoadedTexture()
}, _p.addImage = function(a, c, b) {
	cc.assert(a, cc._LogInfos.Texture2D_addImage);
	var d = this._textures,
		e = d[a] || d[cc.loader._aliases[a]];
	if(e) return e.isLoaded() ? c && c.call(b, e) : e.addEventListener("load", function() {
		c && c.call(b, e)
	}, b), e;
	e = d[a] = new cc.Texture2D;
	e.url = a;
	(cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader,
		a,
		function(e, g) {
			if(e) return c && c.call(b, e);
			cc.textureCache.handleLoadedTexture(a);
			var h = d[a];
			c && c.call(b, h)
		});
	return e
}, _p.addImageAsync = _p.addImage, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
	dirty: !1,
	texture: null,
	_indices: null,
	_buffersVBO: null,
	_capacity: 0,
	_quads: null,
	_quadsArrayBuffer: null,
	_quadsWebBuffer: null,
	_quadsReader: null,
	ctor: function(a, c) {
		this._buffersVBO = [];
		cc.isString(a) ? this.initWithFile(a, c) : a instanceof cc.Texture2D && this.initWithTexture(a, c)
	},
	getTotalQuads: function() {
		return this._totalQuads
	},
	getCapacity: function() {
		return this._capacity
	},
	getTexture: function() {
		return this.texture
	},
	setTexture: function(a) {
		this.texture = a
	},
	setDirty: function(a) {
		this.dirty =
			a
	},
	isDirty: function() {
		return this.dirty
	},
	getQuads: function() {
		return this._quads
	},
	setQuads: function(a) {
		this._quads = a
	},
	_copyQuadsToTextureAtlas: function(a, c) {
		if(a)
			for(var b = 0; b < a.length; b++) this._setQuadToArray(a[b], c + b)
	},
	_setQuadToArray: function(a, c) {
		var b = this._quads;
		b[c] ? (b[c].bl = a.bl, b[c].br = a.br, b[c].tl = a.tl, b[c].tr = a.tr) : b[c] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, c * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
	},
	description: function() {
		return "\x3ccc.TextureAtlas | totalQuads \x3d" +
			this._totalQuads + "\x3e"
	},
	_setupIndices: function() {
		if(0 !== this._capacity)
			for(var a = this._indices, c = this._capacity, b = 0; b < c; b++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * b + 0] = 4 * b + 0, a[6 * b + 1] = 4 * b + 0, a[6 * b + 2] = 4 * b + 2, a[6 * b + 3] = 4 * b + 1, a[6 * b + 4] = 4 * b + 3, a[6 * b + 5] = 4 * b + 3) : (a[6 * b + 0] = 4 * b + 0, a[6 * b + 1] = 4 * b + 1, a[6 * b + 2] = 4 * b + 2, a[6 * b + 3] = 4 * b + 3, a[6 * b + 4] = 4 * b + 2, a[6 * b + 5] = 4 * b + 1)
	},
	_setupVBO: function() {
		var a = cc._renderContext;
		this._buffersVBO[0] = a.createBuffer();
		this._buffersVBO[1] = a.createBuffer();
		this._quadsWebBuffer = a.createBuffer();
		this._mapBuffers()
	},
	_mapBuffers: function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
	},
	initWithFile: function(a, c) {
		var b = cc.textureCache.addImage(a);
		if(b) return this.initWithTexture(b, c);
		cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
		return !1
	},
	initWithTexture: function(a, c) {
		cc.assert(a,
			cc._LogInfos.TextureAtlas_initWithTexture);
		this._capacity = c |= 0;
		this._totalQuads = 0;
		this.texture = a;
		this._quads = [];
		this._indices = new Uint16Array(6 * c);
		var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._quadsArrayBuffer = new ArrayBuffer(b * c);
		this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
		if((!this._quads || !this._indices) && 0 < c) return !1;
		for(var d = this._quads, e = 0; e < c; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * b);
		this._setupIndices();
		this._setupVBO();
		return this.dirty = !0
	},
	updateQuad: function(a, c) {
		cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
		cc.assert(0 <= c && c < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
		this._totalQuads = Math.max(c + 1, this._totalQuads);
		this._setQuadToArray(a, c);
		this.dirty = !0
	},
	insertQuad: function(a, c) {
		cc.assert(c < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
		this._totalQuads++;
		if(this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = c * b,
				e = (this._totalQuads -
					1 - c) * b;
			this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * b);
			this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + b);
			this._setQuadToArray(a, c);
			this.dirty = !0
		}
	},
	insertQuads: function(a, c, b) {
		b = b || a.length;
		cc.assert(c + b <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
		var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads += b;
		if(this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var e = c *
				d,
				f = (this._totalQuads - 1 - c - b) * d,
				g = this._totalQuads - 1 - b,
				h;
			for(h = 0; h < b; h++) this._quads[g + h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
			this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * b);
			for(h = 0; h < b; h++) this._setQuadToArray(a[h], c + h);
			this.dirty = !0
		}
	},
	insertQuadFromIndex: function(a, c) {
		if(a !== c) {
			cc.assert(0 <= c || c < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
			cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
			var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = this._quadsReader,
				e = d.subarray(a * b, b),
				f;
			a > c ? (f = c * b, d.set(d.subarray(f, f + (a - c) * b), f + b), d.set(e, f)) : (f = (a + 1) * b, d.set(d.subarray(f, f + (c - a) * b), f - b), d.set(e, c * b));
			this.dirty = !0
		}
	},
	removeQuadAtIndex: function(a) {
		cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
		var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads--;
		this._quads.length = this._totalQuads;
		if(a !== this._totalQuads) {
			var b = (a + 1) * c;
			this._quadsReader.set(this._quadsReader.subarray(b,
				b + (this._totalQuads - a) * c), b - c)
		}
		this.dirty = !0
	},
	removeQuadsAtIndex: function(a, c) {
		cc.assert(a + c <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
		this._totalQuads -= c;
		if(a !== this._totalQuads) {
			var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = (a + c) * b,
				e = a * b;
			this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * b), e)
		}
		this.dirty = !0
	},
	removeAllQuads: function() {
		this._totalQuads = this._quads.length = 0
	},
	_setDirty: function(a) {
		this.dirty = a
	},
	resizeCapacity: function(a) {
		if(a === this._capacity) return !0;
		var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			b = this._capacity;
		this._totalQuads = Math.min(this._totalQuads, a);
		var d = this._capacity = 0 | a,
			e = this._totalQuads;
		if(null === this._quads)
			for(this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(c * d), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), a = 0; a < d; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * c);
		else {
			var f, g, h = this._quads;
			if(d > b) {
				f = [];
				g = new ArrayBuffer(c * d);
				for(a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl,
					h[a].bl, h[a].tr, h[a].br, g, a * c);
				for(; a < d; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * c)
			} else
				for(e = Math.max(e, d), f = [], g = new ArrayBuffer(c * d), a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * c);
			this._quadsReader = new Uint8Array(g);
			this._quads = f;
			this._quadsArrayBuffer = g
		}
		null === this._indices ? this._indices = new Uint16Array(6 * d) : d > b ? (c = new Uint16Array(6 * d), c.set(this._indices, 0), this._indices = c) : this._indices = this._indices.subarray(0, 6 * d);
		this._setupIndices();
		this._mapBuffers();
		return this.dirty = !0
	},
	increaseTotalQuadsWith: function(a) {
		this._totalQuads += a
	},
	moveQuadsFromIndex: function(a, c, b) {
		if(void 0 === b) {
			if(b = c, c = this._totalQuads - a, cc.assert(b + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === c) return
		} else if(cc.assert(b + c <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a === b) return;
		var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			e = a * d,
			f = c * d,
			g = this._quadsReader,
			h = g.subarray(e, e + f),
			k = b * d;
		b < a ? (c = b * d, g.set(g.subarray(c, c + (a - b) * d), c + f)) : (c = (a + c) * d, g.set(g.subarray(c, c + (b - a) * d), e));
		g.set(h, k);
		this.dirty = !0
	},
	fillWithEmptyQuadsFromIndex: function(a, c) {
		for(var b = c * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, b), e = 0; e < b; e++) d[e] = 0
	},
	drawQuads: function() {
		this.drawNumberOfQuads(this._totalQuads, 0)
	},
	_releaseBuffer: function() {
		var a = cc._renderContext;
		this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
			this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
		this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
	}
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, c) {
	return new cc.TextureAtlas(a, c)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
	_className: "Scene",
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(0.5, 0.5);
		this.setContentSize(cc.director.getWinSize())
	}
});
cc.Scene.create = function() {
	return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
	_interval: null,
	_label: null,
	_className: "LoaderScene",
	cb: null,
	target: null,
	init: function() {
		var a = this,
			c = 200,
			b = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
		a.addChild(b, 0);
		var d = 24,
			e = -c / 2 + 100;
		cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
			isCrossOrigin: !1
		}, function(b, d) {
			c = d.height;
			a._initStage(d, cc.visibleRect.center)
		}), d = 14, e = -c / 2 - 10);
		d = a._label = new cc.LabelTTF("Loading... 0%", "Arial", d);
		d.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, e)));
		d.setColor(cc.color(180,
			180, 180));
		b.addChild(this._label, 10);
		return !0
	},
	_initStage: function(a, c) {
		var b = this._texture2d = new cc.Texture2D;
		b.initWithElement(a);
		b.handleLoadedTexture();
		b = this._logo = new cc.Sprite(b);
		b.setScale(cc.contentScaleFactor());
		b.x = c.x;
		b.y = c.y;
		this._bgLayer.addChild(b, 10)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.schedule(this._startLoading, 0.3)
	},
	onExit: function() {
		cc.Node.prototype.onExit.call(this);
		this._label.setString("Loading... 0%")
	},
	initWithResources: function(a, c, b) {
		cc.isString(a) &&
			(a = [a]);
		this.resources = a || [];
		this.cb = c;
		this.target = b
	},
	_startLoading: function() {
		var a = this;
		a.unschedule(a._startLoading);
		cc.loader.load(a.resources, function(c, b, d) {
			c = Math.min(d / b * 100 | 0, 100);
			a._label.setString("Loading... " + c + "%")
		}, function() {
			a.cb && a.cb.call(a.target);
			a._label.setString("Loading... 100%")
		})
	}
});
cc.LoaderScene.preload = function(a, c, b) {
	var d = cc;
	d.loaderScene || (d.loaderScene = new cc.LoaderScene, d.loaderScene.init());
	d.loaderScene.initWithResources(a, c, b);
	cc.director.runScene(d.loaderScene);
	return d.loaderScene
};
cc.Layer = cc.Node.extend({
	_className: "Layer",
	ctor: function() {
		var a = cc.Node.prototype;
		a.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		a.setAnchorPoint.call(this, 0.5, 0.5);
		a.setContentSize.call(this, cc.winSize)
	},
	init: function() {
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(0.5, 0.5);
		this.setContentSize(cc.winSize);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
		return !0
	},
	bake: function() {
		this._renderCmd.bake()
	},
	unbake: function() {
		this._renderCmd.unbake()
	},
	isBaked: function() {
		return this._renderCmd._isBaked
	},
	addChild: function(a, c, b) {
		cc.Node.prototype.addChild.call(this, a, c, b);
		this._renderCmd._bakeForAddChild(a)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
	}
});
cc.Layer.create = function() {
	return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
	_blendFunc: null,
	_className: "LayerColor",
	getBlendFunc: function() {
		return this._blendFunc
	},
	changeWidthAndHeight: function(a, c) {
		this.width = a;
		this.height = c
	},
	changeWidth: function(a) {
		this.width = a
	},
	changeHeight: function(a) {
		this.height = a
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	ctor: function(a, c, b) {
		cc.Layer.prototype.ctor.call(this);
		this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		cc.LayerColor.prototype.init.call(this, a,
			c, b)
	},
	init: function(a, c, b) {
		cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
		var d = cc.director.getWinSize();
		a = a || cc.color(0, 0, 0, 255);
		c = void 0 === c ? d.width : c;
		b = void 0 === b ? d.height : b;
		d = this._realColor;
		d.r = a.r;
		d.g = a.g;
		d.b = a.b;
		this._realOpacity = a.a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
		cc.LayerColor.prototype.setContentSize.call(this, c, b);
		return !0
	},
	setBlendFunc: function(a, c) {
		var b =
			this._blendFunc;
		void 0 === c ? (b.src = a.src, b.dst = a.dst) : (b.src = a, b.dst = c);
		this._renderCmd.updateBlendFunc(b)
	},
	_setWidth: function(a) {
		cc.Node.prototype._setWidth.call(this, a);
		this._renderCmd._updateSquareVerticesWidth(a)
	},
	_setHeight: function(a) {
		cc.Node.prototype._setHeight.call(this, a);
		this._renderCmd._updateSquareVerticesHeight(a)
	},
	setContentSize: function(a, c) {
		cc.Layer.prototype.setContentSize.call(this, a, c);
		this._renderCmd._updateSquareVertices(a, c)
	},
	_createRenderCmd: function() {
		return cc._renderType ===
			cc._RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
	}
});
cc.LayerColor.create = function(a, c, b) {
	return new cc.LayerColor(a, c, b)
};
(function() {
	var a = cc.LayerColor.prototype;
	cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
	cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
	_endColor: null,
	_startOpacity: 255,
	_endOpacity: 255,
	_alongVector: null,
	_compressedInterpolation: !1,
	_className: "LayerGradient",
	_colorStops: [],
	ctor: function(a, c, b, d) {
		cc.LayerColor.prototype.ctor.call(this);
		this._endColor = cc.color(0, 0, 0, 255);
		this._alongVector = cc.p(0, -1);
		this._endOpacity = this._startOpacity = 255;
		d && d instanceof Array ? (this._colorStops = d, d.splice(0, 0, {
			p: 0,
			color: a || cc.color.BLACK
		}), d.push({
			p: 1,
			color: c || cc.color.BLACK
		})) : this._colorStops = [{
			p: 0,
			color: a || cc.color.BLACK
		}, {
			p: 1,
			color: c || cc.color.BLACK
		}];
		cc.LayerGradient.prototype.init.call(this, a, c, b, d)
	},
	init: function(a, c, b, d) {
		a = a || cc.color(0, 0, 0, 255);
		c = c || cc.color(0, 0, 0, 255);
		b = b || cc.p(0, -1);
		d = this._endColor;
		this._startOpacity = a.a;
		d.r = c.r;
		d.g = c.g;
		d.b = c.b;
		this._endOpacity = c.a;
		this._alongVector = b;
		this._compressedInterpolation = !0;
		cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
		return !0
	},
	setContentSize: function(a, c) {
		cc.LayerColor.prototype.setContentSize.call(this, a, c);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setWidth: function(a) {
		cc.LayerColor.prototype._setWidth.call(this, a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setHeight: function(a) {
		cc.LayerColor.prototype._setHeight.call(this, a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getStartColor: function() {
		return cc.color(this._realColor)
	},
	setStartColor: function(a) {
		this.color =
			a;
		var c = this._colorStops;
		c && 0 < c.length && (c = c[0].color, c.r = a.r, c.g = a.g, c.b = a.b)
	},
	setEndColor: function(a) {
		var c = this._endColor;
		c.r = a.r;
		c.g = a.g;
		c.b = a.b;
		(c = this._colorStops) && 0 < c.length && (c = c[c.length - 1].color, c.r = a.r, c.g = a.g, c.b = a.b);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	getEndColor: function() {
		return cc.color(this._endColor)
	},
	setStartOpacity: function(a) {
		this._startOpacity = a;
		var c = this._colorStops;
		c && 0 < c.length && (c[0].color.a = a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getStartOpacity: function() {
		return this._startOpacity
	},
	setEndOpacity: function(a) {
		this._endOpacity = a;
		var c = this._colorStops;
		c && 0 < c.length && (c[c.length - 1].color.a = a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getEndOpacity: function() {
		return this._endOpacity
	},
	setVector: function(a) {
		this._alongVector.x = a.x;
		this._alongVector.y = a.y;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getVector: function() {
		return cc.p(this._alongVector.x, this._alongVector.y)
	},
	isCompressedInterpolation: function() {
		return this._compressedInterpolation
	},
	setCompressedInterpolation: function(a) {
		this._compressedInterpolation = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getColorStops: function() {
		return this._colorStops
	},
	setColorStops: function(a) {
		this._colorStops = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
	}
});
cc.LayerGradient.create = function(a, c, b, d) {
	return new cc.LayerGradient(a, c, b, d)
};
(function() {
	var a = cc.LayerGradient.prototype;
	cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
	cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
	cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
	cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
	cc.defineGetterSetter(a, "vector", a.getVector, a.setVector);
	cc.defineGetterSetter(a, "colorStops", a.getColorStops, a.setColorStops)
})();
cc.LayerMultiplex = cc.Layer.extend({
	_enabledLayer: 0,
	_layers: null,
	_className: "LayerMultiplex",
	ctor: function(a) {
		cc.Layer.prototype.ctor.call(this);
		a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
	},
	initWithLayers: function(a) {
		0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
		this._layers = a;
		this._enabledLayer = 0;
		this.addChild(this._layers[this._enabledLayer]);
		return !0
	},
	switchTo: function(a) {
		a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
	},
	switchToAndReleaseMe: function(a) {
		a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
	},
	addLayer: function(a) {
		a ? this._layers.push(a) :
			cc.log(cc._LogInfos.LayerMultiplex_addLayer)
	}
});
cc.LayerMultiplex.create = function() {
	return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function() {
	cc.Layer.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._isBaked = !1;
		this._bakeSprite = null
	};
	var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.Layer.CanvasRenderCmd;
	a.bake = function() {
		if(!this._isBaked) {
			this._needDraw = !0;
			this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
			for(var a = this._node._children, b = 0, d = a.length; b < d; b++) a[b]._renderCmd._setCachedParent(this);
			this._bakeSprite || (this._bakeSprite =
				new cc.BakeSprite, this._bakeSprite.setAnchorPoint(0, 0))
		}
	};
	a.unbake = function() {
		if(this._isBaked) {
			cc.renderer.childrenOrderDirty = !0;
			this._isBaked = this._needDraw = !1;
			this._cacheDirty = !0;
			for(var a = this._node._children, b = 0, d = a.length; b < d; b++) a[b]._renderCmd._setCachedParent(null)
		}
	};
	a.isBaked = function() {
		return this._isBaked
	};
	a.rendering = function() {
		if(this._cacheDirty) {
			var a = this._node,
				b = a._children,
				d = this._bakeSprite;
			this.transform(this.getParentRenderCmd(), !0);
			var e = this._getBoundingBoxForBake();
			e.width =
				0 | e.width + 0.5;
			e.height = 0 | e.height + 0.5;
			var f = d.getCacheContext(),
				g = f.getContext();
			d.resetCanvasSize(e.width, e.height);
			f.setOffset(0 - e.x, g.canvas.height - e.height + e.y);
			d.setPosition(e.x, e.y);
			a.sortAllChildren();
			cc.renderer._turnToCacheMode(this.__instanceId);
			a = 0;
			for(e = b.length; a < e; a++) b[a].visit(this);
			cc.renderer._renderingToCacheCanvas(f, this.__instanceId);
			d.transform();
			this._cacheDirty = !1
		}
	};
	a.visit = function(a) {
		if(this._isBaked) {
			var b = this._node,
				d = b._children.length;
			b._visible && 0 !== d && (this._syncStatus(a),
				cc.renderer.pushRenderCommand(this), this._cacheDirty = !0, this._bakeSprite.visit(this), this._dirtyFlag = 0)
		} else cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
	};
	a._bakeForAddChild = function(a) {
		a._parent === this._node && this._isBaked && a._renderCmd._setCachedParent(this)
	};
	a._getBoundingBoxForBake = function() {
		var a = null,
			b = this._node;
		if(!b._children || 0 === b._children.length) return cc.rect(0, 0, 10, 10);
		for(var d = b.getNodeToWorldTransform(), b = b._children, e = 0, f = b.length; e < f; e++) {
			var g = b[e];
			g && g._visible && (a ?
				(g = g._getBoundingBoxToCurrentNode(d)) && (a = cc.rectUnion(a, g)) : a = g._getBoundingBoxToCurrentNode(d))
		}
		return a
	}
})();
(function() {
	cc.LayerColor.CanvasRenderCmd = function(a) {
		cc.Layer.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._blendFuncStr = "source-over";
		this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
	};
	var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
	a.constructor = cc.LayerColor.CanvasRenderCmd;
	a.unbake = function() {
		cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
		this._needDraw = !0
	};
	a.rendering = function(a, b, d) {
		a = a || cc._renderContext;
		var e =
			a.getContext(),
			f = this._node,
			g = this._displayedColor,
			h = this._displayedOpacity / 255,
			k = f._contentSize.width,
			f = f._contentSize.height;
		0 !== h && (a.setCompositeOperation(this._blendFuncStr), a.setGlobalAlpha(h), a.setFillStyle("rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + ", 1)"), a.setTransform(this._worldTransform, b, d), e.fillRect(0, 0, k * b, -f * d), cc.g_NumberOfDraws++)
	};
	a.updateBlendFunc = function(a) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
	};
	a._updateSquareVertices = a._updateSquareVerticesWidth =
		a._updateSquareVerticesHeight = function() {};
	a._bakeRendering = function() {
		if(this._cacheDirty) {
			var a = this._node,
				b = this._bakeSprite,
				d = a._children,
				e = d.length;
			this.transform(this.getParentRenderCmd(), !0);
			var f = this._getBoundingBoxForBake();
			f.width = 0 | f.width + 0.5;
			f.height = 0 | f.height + 0.5;
			var g = b.getCacheContext(),
				h = g.getContext();
			b.resetCanvasSize(f.width, f.height);
			h.fillStyle = g._currentFillStyle;
			g.setOffset(0 - f.x, h.canvas.height - f.height + f.y);
			b.setPosition(f.x, f.y);
			cc.renderer._turnToCacheMode(this.__instanceId);
			if(0 < e) {
				a.sortAllChildren();
				for(a = 0; a < e; a++)
					if(f = d[a], 0 > f._localZOrder) f._renderCmd.visit(this);
					else break;
				for(cc.renderer.pushRenderCommand(this); a < e; a++) d[a]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			cc.renderer._renderingToCacheCanvas(g, this.__instanceId);
			b.transform();
			this._cacheDirty = !1
		}
	};
	a.visit = function(a) {
		this._isBaked ? this._node._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
			this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
	};
	a._getBoundingBoxForBake = function() {
		var a = this._node,
			b = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
			d = a.getNodeToWorldTransform(),
			b = cc.rectApplyAffineTransform(b, a.getNodeToWorldTransform());
		if(!a._children || 0 === a._children.length) return b;
		for(var a = a._children, e = 0; e < a.length; e++) {
			var f = a[e];
			f && f._visible && (f = f._getBoundingBoxToCurrentNode(d), b = cc.rectUnion(b, f))
		}
		return b
	}
})();
(function() {
	cc.LayerGradient.RenderCmd = {
		updateStatus: function() {
			var a = cc.Node._dirtyFlags,
				c = this._dirtyFlag,
				b = c & a.colorDirty,
				d = c & a.opacityDirty;
			b && this._updateDisplayColor();
			d && this._updateDisplayOpacity();
			c & a.transformDirty && this.transform(null, !0);
			(b || d || c & a.gradientDirty) && this._updateColor();
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.LayerGradient.CanvasRenderCmd = function(a) {
		cc.LayerColor.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._startPoint = cc.p(0, 0);
		this._endPoint = cc.p(0, 0);
		this._endStopStr = this._startStopStr = null
	};
	var a = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, a);
	a.constructor = cc.LayerGradient.CanvasRenderCmd;
	a.rendering = function(a, b, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			g = this._displayedOpacity /
			255;
		if(0 !== g) {
			var h = f._contentSize.width,
				k = f._contentSize.height;
			a.setCompositeOperation(this._blendFuncStr);
			a.setGlobalAlpha(g);
			g = e.createLinearGradient(this._startPoint.x * b, this._startPoint.y * d, this._endPoint.x * b, this._endPoint.y * d);
			if(f._colorStops)
				for(var m = 0; m < f._colorStops.length; m++) g.addColorStop(f._colorStops[m].p, this._colorStopsStr[m]);
			else g.addColorStop(0, this._startStopStr), g.addColorStop(1, this._endStopStr);
			a.setFillStyle(g);
			a.setTransform(this._worldTransform, b, d);
			e.fillRect(0, 0, h *
				b, -k * d);
			cc.g_NumberOfDraws++
		}
	};
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag & b.transformDirty && (d |= b.transformDirty);
		var e = d & b.colorDirty,
			f = d & b.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		d & b.transformDirty && this.transform(a);
		(e || f || d & b.gradientDirty) &&
		this._updateColor()
	};
	a._updateColor = function() {
		var a = this._node,
			b = a._contentSize,
			d = 0.5 * b.width,
			b = 0.5 * b.height;
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		var e = cc.pAngleSigned(cc.p(0, -1), a._alongVector),
			e = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), e),
			f = Math.min(Math.abs(1 / e.x), Math.abs(1 / e.y));
		this._startPoint.x = d * -e.x * f + d;
		this._startPoint.y = b * e.y * f - b;
		this._endPoint.x = d * e.x * f + d;
		this._endPoint.y = b * -e.y * f - b;
		d = this._displayedColor;
		b = a._endColor;
		e = a._startOpacity / 255;
		f = a._endOpacity /
			255;
		this._startStopStr = "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + e.toFixed(4) + ")";
		this._endStopStr = "rgba(" + Math.round(b.r) + "," + Math.round(b.g) + "," + Math.round(b.b) + "," + f.toFixed(4) + ")";
		if(a._colorStops)
			for(this._endOpacity = this._startOpacity = 0, this._colorStopsStr = [], d = 0; d < a._colorStops.length; d++) b = a._colorStops[d].color, e = null == b.a ? 1 : b.a / 255, this._colorStopsStr.push("rgba(" + Math.round(b.r) + "," + Math.round(b.g) + "," + Math.round(b.b) + "," + e.toFixed(4) + ")")
	}
})();
(function() {
	cc.Layer.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a)
	};
	var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.Layer.WebGLRenderCmd;
	a.bake = function() {};
	a.unbake = function() {};
	a._bakeForAddChild = function() {}
})();
(function() {
	cc.LayerColor.WebGLRenderCmd = function(a) {
		cc.Layer.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._squareVerticesAB = new ArrayBuffer(32);
		this._squareColorsAB = new ArrayBuffer(16);
		a = this._squareVerticesAB;
		var b = this._squareColorsAB,
			d = cc.Vertex2F.BYTES_PER_ELEMENT,
			e = cc.Color.BYTES_PER_ELEMENT;
		this._squareVertices = [new cc.Vertex2F(0, 0, a, 0), new cc.Vertex2F(0, 0, a, d), new cc.Vertex2F(0, 0, a, 2 * d), new cc.Vertex2F(0, 0, a, 3 * d)];
		this._squareColors = [cc.color(0, 0, 0, 255, b, 0), cc.color(0, 0, 0, 255, b, e), cc.color(0,
			0, 0, 255, b, 2 * e), cc.color(0, 0, 0, 255, b, 3 * e)];
		this._verticesFloat32Buffer = cc._renderContext.createBuffer();
		this._colorsUint8Buffer = cc._renderContext.createBuffer()
	};
	var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
	a.constructor = cc.LayerColor.WebGLRenderCmd;
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var b = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION |
			cc.VERTEX_ATTRIB_FLAG_COLOR);
		cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
		a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length)
	};
	a._updateSquareVertices = function(a, b) {
		var d = this._squareVertices;
		void 0 === b ? (d[1].x = a.width, d[2].y = a.height, d[3].x =
			a.width, d[3].y = a.height) : (d[1].x = a, d[2].y = b, d[3].x = a, d[3].y = b);
		this._bindLayerVerticesBufferData()
	};
	a._updateSquareVerticesWidth = function(a) {
		var b = this._squareVertices;
		b[1].x = a;
		b[3].x = a;
		this._bindLayerVerticesBufferData()
	};
	a._updateSquareVerticesHeight = function(a) {
		var b = this._squareVertices;
		b[2].y = a;
		b[3].y = a;
		this._bindLayerVerticesBufferData()
	};
	a._updateColor = function() {
		for(var a = this._displayedColor, b = this._displayedOpacity, d = this._squareColors, e = 0; 4 > e; e++) d[e].r = a.r, d[e].g = a.g, d[e].b = a.b, d[e].a =
			b;
		this._bindLayerColorsBufferData()
	};
	a._bindLayerVerticesBufferData = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
	};
	a._bindLayerColorsBufferData = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
	};
	a.updateBlendFunc = function(a) {}
})();
(function() {
	cc.LayerGradient.WebGLRenderCmd = function(a) {
		cc.LayerColor.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._clipRect = new cc.Rect;
		this._clippingRectDirty = !1
	};
	var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, a);
	a.constructor = cc.LayerGradient.WebGLRenderCmd;
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |=
			b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag & b.transformDirty && (d |= b.transformDirty);
		var e = d & b.colorDirty,
			f = d & b.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		this.transform(a);
		(e || f || d & b.gradientDirty) && this._updateColor()
	};
	a._updateColor = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		var a = this._node,
			b = a._colorStops;
		if(b && !(2 > b.length)) {
			this._clippingRectDirty = !0;
			var d = b.length,
				e = 2 * d,
				f, g = a._contentSize;
			this._squareVerticesAB = new ArrayBuffer(8 * e);
			this._squareColorsAB = new ArrayBuffer(4 * e);
			var h = this._squareVertices,
				k = this._squareColors;
			h.length = 0;
			k.length = 0;
			var m = this._squareVerticesAB,
				n = this._squareColorsAB,
				p = cc.Vertex2F.BYTES_PER_ELEMENT,
				s = cc.Color.BYTES_PER_ELEMENT;
			for(f = 0; f < e; f++) h.push(new cc.Vertex2F(0, 0, m, p * f)), k.push(cc.color(0, 0, 0, 255, n, s * f));
			n = Math.PI + cc.pAngleSigned(cc.p(0, -1), a._alongVector);
			a = cc.p(g.width / 2, g.height / 2);
			f = Math.round(cc.radiansToDegrees(n));
			e = cc.affineTransformMake(1, 0, 0, 1, a.x, a.y);
			e = cc.affineTransformRotate(e, n);
			90 > f ? (p = cc.p(-a.x, a.y), f = cc.p(a.x, a.y)) : 180 > f ? (p = cc.p(a.x, a.y), f = cc.p(a.x, -a.y)) : 270 > f ? (p = cc.p(a.x, -a.y), f = cc.p(-a.x, -a.y)) : (p = cc.p(-a.x, -a.y), f = cc.p(-a.x, a.y));
			m = Math.sin(n);
			n = Math.cos(n);
			p = Math.abs((p.x * n - p.y * m) / a.x);
			f = Math.abs((f.x * m + f.y * n) / a.y);
			e = cc.affineTransformScale(e, p, f);
			for(f = 0; f < d; f++) m = b[f].p * g.height, n = cc.pointApplyAffineTransform(-a.x, m - a.y, e), h[2 * f].x = n.x, h[2 * f].y = n.y, m = cc.pointApplyAffineTransform(g.width - a.x,
				m - a.y, e), h[2 * f + 1].x = m.x, h[2 * f + 1].y = m.y;
			g = this._displayedOpacity / 255;
			for(f = 0; f < d; f++) h = b[f].color, a = k[2 * f], e = k[2 * f + 1], a.r = h.r, a.g = h.g, a.b = h.b, a.a = h.a * g, e.r = h.r, e.g = h.g, e.b = h.b, e.a = h.a * g;
			this._bindLayerVerticesBufferData();
			this._bindLayerColorsBufferData()
		}
	};
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var b = this._node,
			d = this._getClippingRect();
		a.enable(a.SCISSOR_TEST);
		cc.view.setScissorInPoints(d.x, d.y, d.width, d.height);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
		cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
		a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length);
		a.disable(a.SCISSOR_TEST)
	};
	a._getClippingRect = function() {
		if(this._clippingRectDirty) {
			var a =
				this._node,
				b = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
				a = a.getNodeToWorldTransform();
			this._clipRect = cc._rectApplyAffineTransformIn(b, a)
		}
		return this._clipRect
	}
})();
cc._tmp.PrototypeSprite = function() {
	var a = cc.Sprite.prototype;
	cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
	cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
	cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
	cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
	cc.defineGetterSetter(a,
		"texture", a.getTexture, a.setTexture);
	cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
	cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
	cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.Sprite = cc.Node.extend({
	dirty: !1,
	atlasIndex: 0,
	textureAtlas: null,
	_batchNode: null,
	_recursiveDirty: null,
	_hasChildren: null,
	_shouldBeHidden: !1,
	_transformToBatch: null,
	_blendFunc: null,
	_texture: null,
	_rect: null,
	_rectRotated: !1,
	_offsetPosition: null,
	_unflippedOffsetPositionFromCenter: null,
	_opacityModifyRGB: !1,
	_flippedX: !1,
	_flippedY: !1,
	_textureLoaded: !1,
	_className: "Sprite",
	ctor: function(a, c, b) {
		cc.Node.prototype.ctor.call(this);
		this._shouldBeHidden = !1;
		this._offsetPosition = cc.p(0, 0);
		this._unflippedOffsetPositionFromCenter =
			cc.p(0, 0);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._rect = cc.rect(0, 0, 0, 0);
		this._softInit(a, c, b)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, c) {
		this.addEventListener("load", a, c)
	},
	isDirty: function() {
		return this.dirty
	},
	setDirty: function(a) {
		this.dirty = a
	},
	isTextureRectRotated: function() {
		return this._rectRotated
	},
	getAtlasIndex: function() {
		return this.atlasIndex
	},
	setAtlasIndex: function(a) {
		this.atlasIndex = a
	},
	getTextureRect: function() {
		return cc.rect(this._rect)
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	setTextureAtlas: function(a) {
		this.textureAtlas = a
	},
	getOffsetPosition: function() {
		return cc.p(this._offsetPosition)
	},
	_getOffsetX: function() {
		return this._offsetPosition.x
	},
	_getOffsetY: function() {
		return this._offsetPosition.y
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	initWithSpriteFrame: function(a) {
		cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
		a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback,
			this));
		var c = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
			c = this.initWithTexture(a.getTexture(), a.getRect(), c);
		this.setSpriteFrame(a);
		return c
	},
	initWithSpriteFrameName: function(a) {
		cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
		var c = cc.spriteFrameCache.getSpriteFrame(a);
		cc.assert(c, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
		return this.initWithSpriteFrame(c)
	},
	useBatchNode: function(a) {
		this.textureAtlas = a.getTextureAtlas();
		this._batchNode = a
	},
	setVertexRect: function(a) {
		var c = this._rect;
		c.x = a.x;
		c.y = a.y;
		c.width = a.width;
		c.height = a.height
	},
	sortAllChildren: function() {
		if(this._reorderChildDirty) {
			var a = this._children,
				c = a.length,
				b, d, e;
			for(b = 1; b < c; b++) {
				e = a[b];
				for(d = b - 1; 0 <= d;) {
					if(e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
					else if(e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
					else break;
					d--
				}
				a[d + 1] = e
			}
			this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren);
			this._reorderChildDirty = !1
		}
	},
	reorderChild: function(a, c) {
		cc.assert(a,
			cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : c !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, c))
	},
	removeChild: function(a, c) {
		this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
		cc.Node.prototype.removeChild.call(this, a, c)
	},
	setVisible: function(a) {
		cc.Node.prototype.setVisible.call(this, a);
		this._renderCmd.setDirtyRecursively(!0)
	},
	removeAllChildren: function(a) {
		var c = this._children,
			b = this._batchNode;
		if(b && null != c)
			for(var d = 0, e = c.length; d < e; d++) b.removeSpriteFromAtlas(c[d]);
		cc.Node.prototype.removeAllChildren.call(this, a);
		this._hasChildren = !1
	},
	ignoreAnchorPointForPosition: function(a) {
		this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
	},
	setFlippedX: function(a) {
		this._flippedX !== a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated,
			this._contentSize), this.setNodeDirty(!0))
	},
	setFlippedY: function(a) {
		this._flippedY !== a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
	},
	isFlippedX: function() {
		return this._flippedX
	},
	isFlippedY: function() {
		return this._flippedY
	},
	setOpacityModifyRGB: function(a) {
		this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setDisplayFrameWithAnimationName: function(a,
		c) {
		cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
		var b = cc.animationCache.getAnimation(a);
		b ? (b = b.getFrames()[c]) ? this.setSpriteFrame(b.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
	},
	getBatchNode: function() {
		return this._batchNode
	},
	_setReorderChildDirtyRecursively: function() {
		if(!this._reorderChildDirty) {
			this._reorderChildDirty = !0;
			for(var a = this._parent; a && a !== this._batchNode;) a._setReorderChildDirtyRecursively(),
				a = a.parent
		}
	},
	getTexture: function() {
		return this._texture
	},
	_softInit: function(a, c, b) {
		if(void 0 === a) cc.Sprite.prototype.init.call(this);
		else if(cc.isString(a)) "#" === a[0] ? (c = a.substr(1, a.length - 1), (c = cc.spriteFrameCache.getSpriteFrame(c)) ? this.initWithSpriteFrame(c) : cc.log("%s does not exist", a)) : cc.Sprite.prototype.init.call(this, a, c);
		else if("object" === typeof a)
			if(a instanceof cc.Texture2D) this.initWithTexture(a, c, b);
			else if(a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
		else if(a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.initWithTexture(c)
	},
	getQuad: function() {
		return this._renderCmd.getQuad()
	},
	setBlendFunc: function(a, c) {
		var b = this._blendFunc;
		void 0 === c ? (b.src = a.src, b.dst = a.dst) : (b.src = a, b.dst = c);
		this._renderCmd.updateBlendFunc(b)
	},
	init: function() {
		if(0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
		cc.Node.prototype.init.call(this);
		this.dirty = this._recursiveDirty = !1;
		this._blendFunc.src =
			cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this.texture = null;
		this._flippedX = this._flippedY = !1;
		this.anchorY = this.anchorX = 0.5;
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
		return !0
	},
	initWithFile: function(a, c) {
		cc.assert(a, cc._LogInfos.Sprite_initWithFile);
		var b = cc.textureCache.getTextureForKey(a);
		if(b) {
			if(!c) {
				var d = b.getContentSize();
				c = cc.rect(0, 0, d.width, d.height)
			}
			return this.initWithTexture(b,
				c)
		}
		b = cc.textureCache.addImage(a);
		return this.initWithTexture(b, c || cc.rect(0, 0, b._contentSize.width, b._contentSize.height))
	},
	initWithTexture: function(a, c, b, d) {
		cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
		b = b || !1;
		a = this._renderCmd._handleTextureForRotatedTexture(a, c, b, d);
		if(!cc.Node.prototype.init.call(this)) return !1;
		this._batchNode = null;
		this.dirty = this._recursiveDirty = !1;
		this._opacityModifyRGB = !0;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this._flippedX =
			this._flippedY = !1;
		this.setAnchorPoint(0.5, 0.5);
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		var e = a.isLoaded();
		this._textureLoaded = e;
		if(!e) return this._rectRotated = b, c && (this._rect.x = c.x, this._rect.y = c.y, this._rect.width = c.width, this._rect.height = c.height), this.texture && this.texture.removeEventListener("load", this), a.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.texture = a, !0;
		c || (c = cc.rect(0, 0, a.width, a.height));
		this._renderCmd._checkTextureBoundary(a,
			c, b);
		this.setTexture(a);
		this.setTextureRect(c, b);
		this.setBatchNode(null);
		return !0
	},
	setTextureRect: function(a, c, b, d) {
		this._rectRotated = c || !1;
		this.setContentSize(b || a);
		this.setVertexRect(a);
		this._renderCmd._setTextureCoords(a, d);
		a = this._unflippedOffsetPositionFromCenter.x;
		c = this._unflippedOffsetPositionFromCenter.y;
		this._flippedX && (a = -a);
		this._flippedY && (c = -c);
		b = this._rect;
		this._offsetPosition.x = a + (this._contentSize.width - b.width) / 2;
		this._offsetPosition.y = c + (this._contentSize.height - b.height) / 2;
		this._batchNode ?
			this.dirty = !0 : this._renderCmd._resetForBatchNode()
	},
	updateTransform: function() {
		this._renderCmd.updateTransform()
	},
	addChild: function(a, c, b) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
		null == c && (c = a._localZOrder);
		null == b && (b = a.tag);
		this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, c, b), this._hasChildren = !0)
	},
	setSpriteFrame: function(a) {
		var c = this;
		cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
		this.setNodeDirty(!0);
		var b = a.getOffset();
		c._unflippedOffsetPositionFromCenter.x = b.x;
		c._unflippedOffsetPositionFromCenter.y = b.y;
		b = a.getTexture();
		a.textureLoaded() ? (b !== c._texture && (c.texture = b), c.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize())) : (c._textureLoaded = !1, a.addEventListener("load", function(a) {
			c._textureLoaded = !0;
			var b = a.getTexture();
			b !== c._texture && (c.texture = b);
			c.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
			c.dispatchEvent("load");
			c.setColor(c.color)
		}, c));
		this._renderCmd._updateForSetSpriteFrame(b)
	},
	setDisplayFrame: function(a) {
		cc.log(cc._LogInfos.Sprite_setDisplayFrame);
		this.setSpriteFrame(a)
	},
	isFrameDisplayed: function(a) {
		return this._renderCmd.isFrameDisplayed(a)
	},
	displayFrame: function() {
		return this.getSpriteFrame()
	},
	getSpriteFrame: function() {
		return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
	},
	setBatchNode: function(a) {
		(this._batchNode = a) ? (this._transformToBatch =
			cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
	},
	setTexture: function(a) {
		if(!a) return this._renderCmd._setTexture(null);
		var c = this._texture;
		cc.isString(a) ? (a = cc.textureCache.addImage(a), a._textureLoaded ? (this._renderCmd._setTexture(a), this._changeRectWithTexture(a, c), this.setColor(this._realColor), this._textureLoaded = !0) :
			a.addEventListener("load", function() {
				this._renderCmd._setTexture(a);
				this._changeRectWithTexture(a, c);
				this.setColor(this._realColor);
				this._textureLoaded = !0
			}, this)) : (cc.assert(a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._changeRectWithTexture(a, c), this._renderCmd._setTexture(a))
	},
	_changeRectWithTexture: function(a, c) {
		var b = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
			d = c ? c._contentSize : cc.size(),
			e = this._contentSize,
			f = b.width,
			g = b.height,
			h = d.width,
			d = d.height,
			k = e.width,
			e =
			e.height;
		if(b && (f || g)) {
			var m = this._rect;
			if(0 === k || 0 === e || k === h || e === d || h !== f || d !== g || 0 === m.height && 0 === m.width) b.x = b.x || 0, b.y = b.y || 0, b.width = b.width || 0, b.height = b.height || 0, this.setTextureRect(b)
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
	}
});
cc.Sprite.create = function(a, c, b) {
	return new cc.Sprite(a, c, b)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
	cc.Sprite.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureCoord = {
			renderX: 0,
			renderY: 0,
			x: 0,
			y: 0,
			width: 0,
			height: 0,
			validRect: !1
		};
		this._blendFuncStr = "source-over";
		this._colorized = !1;
		this._originalTexture = null
	};
	var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.Sprite.CanvasRenderCmd;
	a._init = function() {};
	a.setDirtyRecursively = function(a) {};
	a._resetForBatchNode = function() {};
	a._setTexture = function(a) {
		var b =
			this._node;
		b._texture !== a && (a ? (a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), b._textureLoaded = a._textureLoaded) : b._textureLoaded = !1, b._texture = a)
	};
	a._setColorDirty = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
	};
	a.isFrameDisplayed = function(a) {
		var b = this._node;
		return a.getTexture() !== b._texture ? !1 : cc.rectEqualToRect(a.getRect(), b._rect)
	};
	a.updateBlendFunc = function(a) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
	};
	a._setBatchNodeForAddChild = function(a) {
		return !0
	};
	a._handleTextureForRotatedTexture = function(a, b, d, e) {
		d && a.isLoaded() && (a = a.getHtmlElementObj(), a = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(a, b, e), e = new cc.Texture2D, e.initWithElement(a), e.handleLoadedTexture(), a = e, b.x = b.y = 0, this._node._rect = cc.rect(0, 0, b.width, b.height));
		return a
	};
	a._checkTextureBoundary = function(a, b, d) {
		a && a.url && (d = b.y + b.height, b.x + b.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight,
			a.url));
		this._node._originalTexture = a
	};
	a.rendering = function(a, b, d) {
		var e = this._node,
			f = this._textureCoord,
			g = this._displayedOpacity / 255;
		if((!e._texture || 0 !== f.width && 0 !== f.height && e._texture._textureLoaded) && 0 !== g) {
			a = a || cc._renderContext;
			var h = a.getContext(),
				k = e._offsetPosition.x,
				m = e._rect.height,
				n = e._rect.width,
				p = -e._offsetPosition.y - m;
			a.setTransform(this._worldTransform, b, d);
			a.setCompositeOperation(this._blendFuncStr);
			a.setGlobalAlpha(g);
			(e._flippedX || e._flippedY) && a.save();
			e._flippedX && (k = -k - n, h.scale(-1,
				1));
			e._flippedY && (p = e._offsetPosition.y, h.scale(1, -1));
			e._texture ? (g = e._texture._htmlElementObj, "" !== e._texture._pattern ? (a.setFillStyle(h.createPattern(g, e._texture._pattern)), h.fillRect(k * b, p * d, n * b, m * d)) : this._colorized ? h.drawImage(g, 0, 0, f.width, f.height, k * b, p * d, n * b, m * d) : h.drawImage(g, f.renderX, f.renderY, f.width, f.height, k * b, p * d, n * b, m * d)) : (g = e._contentSize, f.validRect && (f = this._displayedColor, a.setFillStyle("rgba(" + f.r + "," + f.g + "," + f.b + ",1)"), h.fillRect(k * b, p * d, g.width * b, g.height * d)));
			(e._flippedX ||
				e._flippedY) && a.restore();
			cc.g_NumberOfDraws++
		}
	};
	a._updateColor = cc.sys._supportCanvasNewBlendModes ? function() {
		var a = this._node,
			b = this._displayedColor;
		if(255 === b.r && 255 === b.g && 255 === b.b) this._setOriginalTexture();
		else {
			var d, e = a._texture,
				f = this._textureCoord;
			e && f.validRect && this._originalTexture && (d = e.getHtmlElementObj()) && (this._colorized = !0, d instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj !== d ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj,
				b, f, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, b, f), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(), a.setTexture(e)))
		}
	} : function() {
		var a = this._node,
			b = this._displayedColor;
		if(255 === b.r && 255 === b.g && 255 === b.b) this._setOriginalTexture();
		else {
			var d, e = a._texture,
				f = this._textureCoord;
			e && f.validRect && this._originalTexture && (d = e.getHtmlElementObj()) && (e = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (this._colorized = !0, d instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, b, f, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, b, f), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(), a.texture = e))
		}
	};
	a._setOriginalTexture = function() {
		if(this._colorized) {
			this._colorized = !1;
			var a = this._node,
				b = cc.rect(a._rect),
				d = cc.size(a._contentSize),
				e = a._rectRotated;
			a.setTexture(this._originalTexture);
			a.setTextureRect(b, e, d)
		}
	};
	a.getQuad =
		function() {
			return null
		};
	a._updateForSetSpriteFrame = function(a, b) {
		this._originalTexture = a;
		this._colorized = !1;
		this._textureCoord.renderX = this._textureCoord.x;
		this._textureCoord.renderY = this._textureCoord.y;
		if(b = b || a._textureLoaded) {
			var d = this._node.getColor();
			255 === d.r && 255 === d.g && 255 === d.b || this._updateColor()
		}
	};
	a.updateTransform = function() {
		var a = this._node;
		if(a.dirty) {
			var b = a._parent;
			!a._visible || b && b !== a._batchNode && b._shouldBeHidden ? a._shouldBeHidden = !0 : (a._shouldBeHidden = !1, a._transformToBatch =
				b && b !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), b._transformToBatch) : this.getNodeToParentTransform());
			a._recursiveDirty = !1;
			a.dirty = !1
		}
		a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
	};
	a._updateDisplayColor = function(a) {
		cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a)
	};
	a._spriteFrameLoadedCallback = function(a) {
		this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
		this._renderCmd._updateColor();
		this.dispatchEvent("load")
	};
	a._textureLoadedCallback = function(a) {
		if(!this._textureLoaded) {
			this._textureLoaded = !0;
			var b = this._rect,
				d = this._renderCmd;
			b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height);
			this.texture = d._originalTexture = a;
			this.setTextureRect(b, this._rectRotated);
			a = d._displayedColor;
			255 === a.r && 255 === a.g && 255 === a.b || d._updateColor();
			this.setBatchNode(this._batchNode);
			this.dispatchEvent("load")
		}
	};
	a._setTextureCoords = function(a, b) {
		void 0 === b && (b = !0);
		var d = this._textureCoord,
			e = b ? cc.contentScaleFactor() : 1;
		d.renderX = d.x = 0 | a.x * e;
		d.renderY = d.y = 0 | a.y * e;
		d.width = 0 | a.width * e;
		d.height = 0 | a.height * e;
		d.validRect = !(0 === d.width || 0 === d.height || 0 > d.x || 0 > d.y)
	};
	cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply = function(a, b, d, e) {
		e = e || cc.newElement("canvas");
		d = d || cc.rect(0, 0, a.width, a.height);
		var f = e.getContext("2d");
		e.width !== d.width || e.height !== d.height ? (e.width = d.width, e.height = d.height) : f.globalCompositeOperation = "source-over";
		f.fillStyle = "rgb(" + (0 | b.r) +
			"," + (0 | b.g) + "," + (0 | b.b) + ")";
		f.fillRect(0, 0, d.width, d.height);
		f.globalCompositeOperation = "multiply";
		f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
		f.globalCompositeOperation = "destination-atop";
		f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
		return e
	};
	cc.Sprite.CanvasRenderCmd._generateTintImage = function(a, b, d, e, f) {
		e || (e = cc.rect(0, 0, a.width, a.height));
		a = d.r / 255;
		var g = d.g / 255;
		d = d.b / 255;
		var h = Math.min(e.width, b[0].width),
			k = Math.min(e.height, b[0].height),
			m;
		f ? (m = f.getContext("2d"),
			m.clearRect(0, 0, h, k)) : (f = cc.newElement("canvas"), f.width = h, f.height = k, m = f.getContext("2d"));
		m.save();
		m.globalCompositeOperation = "lighter";
		var n = m.globalAlpha;
		0 < a && (m.globalAlpha = a * n, m.drawImage(b[0], e.x, e.y, h, k, 0, 0, h, k));
		0 < g && (m.globalAlpha = g * n, m.drawImage(b[1], e.x, e.y, h, k, 0, 0, h, k));
		0 < d && (m.globalAlpha = d * n, m.drawImage(b[2], e.x, e.y, h, k, 0, 0, h, k));
		1 > a + g + d && (m.globalAlpha = n, m.drawImage(b[3], e.x, e.y, h, k, 0, 0, h, k));
		m.restore();
		return f
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor = function(a) {
		function b() {
			var b =
				cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor,
				e = a.width,
				h = a.height;
			d[0].width = e;
			d[0].height = h;
			d[1].width = e;
			d[1].height = h;
			d[2].width = e;
			d[2].height = h;
			d[3].width = e;
			d[3].height = h;
			b.canvas.width = e;
			b.canvas.height = h;
			var k = b.canvas.getContext("2d");
			k.drawImage(a, 0, 0);
			b.tempCanvas.width = e;
			b.tempCanvas.height = h;
			for(var k = k.getImageData(0, 0, e, h).data, m = 0; 4 > m; m++) {
				var n = d[m].getContext("2d");
				n.getImageData(0, 0, e, h).data;
				b.tempCtx.drawImage(a, 0, 0);
				for(var p = b.tempCtx.getImageData(0, 0, e, h), s = p.data,
						q = 0; q < k.length; q += 4) s[q] = 0 === m ? k[q] : 0, s[q + 1] = 1 === m ? k[q + 1] : 0, s[q + 2] = 2 === m ? k[q + 2] : 0, s[q + 3] = k[q + 3];
				n.putImageData(p, 0, 0)
			}
			a.onload = null
		}
		if(a.channelCache) return a.channelCache;
		var d = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
		try {
			b()
		} catch(e) {
			a.onload = b
		}
		return a.channelCache = d
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.canvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCtx = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas.getContext("2d");
	cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(a, b, d) {
		if(!a) return null;
		if(!b) return a;
		d = null == d ? !0 : d;
		var e = cc.newElement("canvas");
		e.width = b.width;
		e.height = b.height;
		var f = e.getContext("2d");
		f.translate(e.width / 2, e.height / 2);
		d ? f.rotate(-1.5707963267948966) : f.rotate(1.5707963267948966);
		f.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width /
			2, b.height, b.width);
		return e
	}
})();
(function() {
	cc.Sprite.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._quad = new cc.V3F_C4B_T2F_Quad;
		this._quadWebBuffer = cc._renderContext.createBuffer();
		this._quadDirty = !0;
		this._recursiveDirty = this._dirty = !1
	};
	var a = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.Sprite.WebGLRenderCmd;
	a.updateBlendFunc = function(a) {};
	a.setDirtyFlag = function(a) {
		cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, a);
		this._dirty = !0
	};
	a.setDirtyRecursively = function(a) {
		this._dirty = this._recursiveDirty = a;
		for(var b = this._node._children, d, e = b ? b.length : 0, f = 0; f < e; f++) d = b[f], d instanceof cc.Sprite && d._renderCmd.setDirtyRecursively(a)
	};
	a._setBatchNodeForAddChild = function(a) {
		var b = this._node;
		if(b._batchNode) {
			if(!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
			a.texture._webTextureObj !== b.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
			b._batchNode.appendChild(a);
			b._reorderChildDirty ||
				b._setReorderChildDirtyRecursively()
		}
		return !0
	};
	a._handleTextureForRotatedTexture = function(a) {
		return a
	};
	a.isFrameDisplayed = function(a) {
		var b = this._node;
		return cc.rectEqualToRect(a.getRect(), b._rect) && a.getTexture().getName() === b._texture.getName() && cc.pointEqualToPoint(a.getOffset(), b._unflippedOffsetPositionFromCenter)
	};
	a._init = function() {
		var a = {
				r: 255,
				g: 255,
				b: 255,
				a: 255
			},
			b = this._quad;
		b.bl.colors = a;
		b.br.colors = a;
		b.tl.colors = a;
		b.tr.colors = a;
		this._quadDirty = !0
	};
	a._resetForBatchNode = function() {
		var a = this._node,
			b = a._offsetPosition.x,
			d = a._offsetPosition.y,
			e = b + a._rect.width,
			a = d + a._rect.height,
			f = this._quad;
		f.bl.vertices = {
			x: b,
			y: d,
			z: 0
		};
		f.br.vertices = {
			x: e,
			y: d,
			z: 0
		};
		f.tl.vertices = {
			x: b,
			y: a,
			z: 0
		};
		f.tr.vertices = {
			x: e,
			y: a,
			z: 0
		};
		this._quadDirty = !0
	};
	a.getQuad = function() {
		return this._quad
	};
	a._updateForSetSpriteFrame = function() {};
	a._spriteFrameLoadedCallback = function(a) {
		this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
		this.dispatchEvent("load")
	};
	a._textureLoadedCallback = function(a) {
		var b = this._renderCmd;
		if(!this._textureLoaded) {
			this._textureLoaded = !0;
			var d = this._rect;
			d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
			this.texture = a;
			this.setTextureRect(d, this._rectRotated);
			this.setBatchNode(this._batchNode);
			b._quadDirty = !0;
			this.dispatchEvent("load")
		}
	};
	a._setTextureCoords = function(a, b) {
		void 0 === b && (b = !0);
		b && (a = cc.rectPointsToPixels(a));
		var d = this._node,
			e = d._batchNode ? d.textureAtlas.texture : d._texture;
		if(e) {
			var f = e.pixelsWidth,
				g = e.pixelsHeight,
				h, k, m = this._quad;
			d._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.height - 2) / (2 * f), h = (2 * a.y + 1) / (2 * g), g = h + (2 * a.width - 2) / (2 * g)) : (e = a.x / f, f = (a.x + a.height) / f, h = a.y / g, g = (a.y + a.width) / g), d._flippedX && (k = h, h = g, g = k), d._flippedY && (k = e, e = f, f = k), m.bl.texCoords.u = e, m.bl.texCoords.v = h, m.br.texCoords.u = e, m.br.texCoords.v = g, m.tl.texCoords.u = f, m.tl.texCoords.v = h, m.tr.texCoords.u = f, m.tr.texCoords.v = g) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.width - 2) / (2 * f), h = (2 * a.y + 1) / (2 * g), g =
				h + (2 * a.height - 2) / (2 * g)) : (e = a.x / f, f = (a.x + a.width) / f, h = a.y / g, g = (a.y + a.height) / g), d._flippedX && (k = e, e = f, f = k), d._flippedY && (k = h, h = g, g = k), m.bl.texCoords.u = e, m.bl.texCoords.v = g, m.br.texCoords.u = f, m.br.texCoords.v = g, m.tl.texCoords.u = e, m.tl.texCoords.v = h, m.tr.texCoords.u = f, m.tr.texCoords.v = h);
			this._quadDirty = !0
		}
	};
	a.transform = function(a, b) {
		cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, b);
		this._dirty = !0
	};
	a._setColorDirty = function() {};
	a._updateColor = function() {
		var a = this._displayedColor,
			b = this._displayedOpacity,
			d = this._node,
			a = {
				r: a.r,
				g: a.g,
				b: a.b,
				a: b
			};
		d._opacityModifyRGB && (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255);
		b = this._quad;
		b.bl.colors = a;
		b.br.colors = a;
		b.tl.colors = a;
		b.tr.colors = a;
		d._batchNode && (d.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? d.textureAtlas.updateQuad(b, d.atlasIndex) : this._dirty = !0);
		this._quadDirty = !0
	};
	a._updateBlendFunc = function() {
		if(this._batchNode) cc.log(cc._LogInfos.Sprite__updateBlendFunc);
		else {
			var a = this._node;
			a._texture && a._texture.hasPremultipliedAlpha() ? (a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst =
				cc.BLEND_DST, a.opacityModifyRGB = !0) : (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, a.opacityModifyRGB = !1)
		}
	};
	a._setTexture = function(a) {
		var b = this._node;
		if(b._batchNode) {
			if(b._batchNode.texture !== a) {
				cc.log(cc._LogInfos.Sprite_setTexture);
				return
			}
		} else b._texture !== a && (b._textureLoaded = a ? a._textureLoaded : !1, b._texture = a, this._updateBlendFunc());
		this._shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR)
	};
	a.updateTransform = function() {
		var a = this._node;
		if(this._dirty) {
			var b = this._quad,
				d = a._parent;
			if(!a._visible || d && d !== a._batchNode && d._shouldBeHidden) b.br.vertices = b.tl.vertices = b.tr.vertices = b.bl.vertices = {
				x: 0,
				y: 0,
				z: 0
			}, a._shouldBeHidden = !0;
			else {
				a._shouldBeHidden = !1;
				0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
				a._transformToBatch = d && d !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), d._transformToBatch) : this.getNodeToParentTransform();
				var e = a._transformToBatch,
					f =
					a._rect,
					d = a._offsetPosition.x,
					g = a._offsetPosition.y,
					h = d + f.width,
					k = g + f.height,
					m = e.tx,
					n = e.ty,
					p = e.a,
					s = e.b,
					q = e.d,
					t = -e.c,
					e = d * p - g * t + m,
					f = d * s + g * q + n,
					r = h * p - g * t + m,
					g = h * s + g * q + n,
					u = h * p - k * t + m,
					h = h * s + k * q + n,
					m = d * p - k * t + m,
					d = d * s + k * q + n,
					k = a._vertexZ;
				cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (e |= 0, f |= 0, r |= 0, g |= 0, u |= 0, h |= 0, m |= 0, d |= 0);
				b.bl.vertices = {
					x: e,
					y: f,
					z: k
				};
				b.br.vertices = {
					x: r,
					y: g,
					z: k
				};
				b.tl.vertices = {
					x: m,
					y: d,
					z: k
				};
				b.tr.vertices = {
					x: u,
					y: h,
					z: k
				}
			}
			a.textureAtlas.updateQuad(b, a.atlasIndex);
			this._dirty = a._recursiveDirty = !1
		}
		a._hasChildren &&
			a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
	};
	a._checkTextureBoundary = function(a, b, d) {
		a && a.url && (d ? (d = b.x + b.height, b = b.y + b.width) : (d = b.x + b.width, b = b.y + b.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), b > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
	};
	a.rendering = function(a) {
		var b = this._node,
			d = b._texture;
		d && !d._textureLoaded || 0 === this._displayedOpacity || (a = a || cc._renderContext, d ? d._textureLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
				cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
				cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++,
			0 === cc.SPRITE_DEBUG_DRAW && !b._showNode) || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || b._showNode ? (b = this._quad, b = [cc.p(b.tl.vertices.x, b.tl.vertices.y), cc.p(b.bl.vertices.x, b.bl.vertices.y), cc.p(b.br.vertices.x, b.br.vertices.y), cc.p(b.tr.vertices.x, b.tr.vertices.y)], cc._drawingUtil.drawPoly(b, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (d = b.getTextureRect(), b = b.getOffsetPosition(), b = [cc.p(b.x, b.y), cc.p(b.x +
			d.width, b.y), cc.p(b.x + d.width, b.y + d.height), cc.p(b.x, b.y + d.height)], cc._drawingUtil.drawPoly(b, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop())
	}
})();
cc.SpriteBatchNode = cc.Node.extend({
	_blendFunc: null,
	_descendants: null,
	_className: "SpriteBatchNode",
	ctor: function(a, c) {
		cc.Node.prototype.ctor.call(this);
		this._descendants = [];
		this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		var b;
		c = c || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		cc.isString(a) ? (b = cc.textureCache.getTextureForKey(a)) || (b = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (b = a);
		b && this.initWithTexture(b, c)
	},
	addSpriteWithoutQuad: function(a, c, b) {
		cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
		if(!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
		a.atlasIndex = c;
		var d = 0,
			e, f = this._descendants;
		if(f && 0 < f.length)
			for(d = 0, e = f.length; d < e; d++) {
				var g = f[d];
				if(g && g.atlasIndex >= c) break
			}
		f.splice(d, 0, a);
		cc.Node.prototype.addChild.call(this, a, c, b);
		this.reorderBatch(!1);
		return this
	},
	getTextureAtlas: function() {
		return this._renderCmd.getTextureAtlas()
	},
	setTextureAtlas: function(a) {
		this._renderCmd.getTextureAtlas(a)
	},
	getDescendants: function() {
		return this._descendants
	},
	initWithFile: function(a, c) {
		var b = cc.textureCache.getTextureForKey(a);
		b || (b = cc.textureCache.addImage(a));
		return this.initWithTexture(b, c)
	},
	_setNodeDirtyForCache: function() {
		this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
	},
	init: function(a, c) {
		var b = cc.textureCache.getTextureForKey(a);
		b || (b = cc.textureCache.addImage(a));
		return this.initWithTexture(b, c)
	},
	increaseAtlasCapacity: function() {
		this._renderCmd.increaseAtlasCapacity()
	},
	removeChildAtIndex: function(a,
		c) {
		this.removeChild(this._children[a], c)
	},
	rebuildIndexInOrder: function(a, c) {
		var b = a.children;
		if(b && 0 < b.length)
			for(var d = 0; d < b.length; d++) {
				var e = b[d];
				e && 0 > e.zIndex && (c = this.rebuildIndexInOrder(e, c))
			}!a === this && (a.atlasIndex = c, c++);
		if(b && 0 < b.length)
			for(d = 0; d < b.length; d++)(e = b[d]) && 0 <= e.zIndex && (c = this.rebuildIndexInOrder(e, c));
		return c
	},
	highestAtlasIndexInChild: function(a) {
		var c = a.children;
		return c && 0 !== c.length ? this.highestAtlasIndexInChild(c[c.length - 1]) : a.atlasIndex
	},
	lowestAtlasIndexInChild: function(a) {
		var c =
			a.children;
		return c && 0 !== c.length ? this.lowestAtlasIndexInChild(c[c.length - 1]) : a.atlasIndex
	},
	atlasIndexForChild: function(a, c) {
		var b = a.parent,
			d = b.children,
			e = d.indexOf(a),
			f = null;
		0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
		return b === this ? 0 === e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 === e ? 0 > c ? b.atlasIndex : b.atlasIndex + 1 : 0 > f.zIndex && 0 > c || 0 <= f.zIndex && 0 <= c ? this.highestAtlasIndexInChild(f) + 1 : b.atlasIndex + 1
	},
	reorderBatch: function(a) {
		this._reorderChildDirty = a
	},
	setBlendFunc: function(a, c) {
		this._blendFunc = void 0 === c ? a : {
			src: a,
			dst: c
		}
	},
	getBlendFunc: function() {
		return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
	},
	reorderChild: function(a, c) {
		cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : c !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, c)
	},
	removeChild: function(a, c) {
		null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this,
			a, c)))
	},
	updateQuadFromSprite: function(a, c) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
		a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = c, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
	},
	insertQuadFromSprite: function(a, c) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
		a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, c), a.batchNode = this, a.atlasIndex = c, a.dirty = !0, a.updateTransform(),
			this._renderCmd.cutting(a, c)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
	},
	initWithTexture: function(a, c) {
		this._children.length = 0;
		this._descendants.length = 0;
		c = c || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		this._renderCmd.initWithTexture(a, c);
		return !0
	},
	insertChild: function(a, c) {
		a.batchNode = this;
		a.atlasIndex = c;
		a.dirty = !0;
		this._renderCmd.insertQuad(a, c);
		this._descendants.splice(c, 0, a);
		var b = c + 1,
			d = this._descendants;
		if(d && 0 < d.length)
			for(; b < d.length; b++) d[b].atlasIndex++;
		var d = a.children,
			e, f;
		if(d)
			for(b =
				0, f = d.length || 0; b < f; b++)
				if(e = d[b]) {
					var g = this.atlasIndexForChild(e, e.zIndex);
					this.insertChild(e, g)
				}
	},
	appendChild: function(a) {
		this._reorderChildDirty = !0;
		a.batchNode = this;
		a.dirty = !0;
		this._descendants.push(a);
		var c = this._descendants.length - 1;
		a.atlasIndex = c;
		this._renderCmd.insertQuad(a, c);
		a = a.children;
		for(var c = 0, b = a.length || 0; c < b; c++) this.appendChild(a[c])
	},
	removeSpriteFromAtlas: function(a) {
		this._renderCmd.removeQuadAtIndex(a.atlasIndex);
		a.batchNode = null;
		var c = this._descendants,
			b = c.indexOf(a);
		if(-1 !==
			b) {
			c.splice(b, 1);
			for(var d = c.length; b < d; ++b) c[b].atlasIndex--
		}
		if(a = a.children)
			for(c = 0, b = a.length || 0; c < b; c++) a[c] && this.removeSpriteFromAtlas(a[c])
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	addChild: function(a, c, b) {
		cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
		this._renderCmd.isValidChild(a) && (c = null == c ? a.zIndex : c, b = null == b ? a.tag : b, cc.Node.prototype.addChild.call(this, a, c, b), this.appendChild(a))
	},
	removeAllChildren: function(a) {
		var c =
			this._descendants;
		if(c && 0 < c.length)
			for(var b = 0, d = c.length; b < d; b++) c[b] && (c[b].batchNode = null);
		cc.Node.prototype.removeAllChildren.call(this, a);
		this._descendants.length = 0;
		this._renderCmd.removeAllQuads()
	},
	sortAllChildren: function() {
		if(this._reorderChildDirty) {
			var a = this._children,
				c, b = 0,
				d = a.length,
				e;
			for(c = 1; c < d; c++) {
				var f = a[c],
					b = c - 1;
				for(e = a[b]; 0 <= b && (f._localZOrder < e._localZOrder || f._localZOrder === e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[b + 1] = e, b -= 1, e = a[b];
				a[b + 1] = f
			}
			0 < a.length && (this._arrayMakeObjectsPerformSelector(a,
				cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(a));
			this._reorderChildDirty = !1
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
	}
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function(a, c) {
	return new cc.SpriteBatchNode(a, c)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function() {
	cc.SpriteBatchNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._originalTexture = this._texture = null
	};
	var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
	a.checkAtlasCapacity = function() {};
	a.isValidChild = function(a) {
		return a instanceof cc.Sprite ? !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
	};
	a.initWithTexture = function(a, b) {
		this._texture = this._originalTexture = a
	};
	a.insertQuad =
		function(a, b) {};
	a.increaseAtlasCapacity = function() {};
	a.removeQuadAtIndex = function() {};
	a.removeAllQuads = function() {};
	a.getTexture = function() {
		return this._texture
	};
	a.setTexture = function(a) {
		this._texture = a;
		for(var b = this._node._children, d = 0; d < b.length; d++) b[d].setTexture(a)
	};
	a.updateChildrenAtlasIndex = function(a) {
		for(var b = this._node._descendants.length = 0, d = a.length; b < d; b++) this._updateAtlasIndex(a[b])
	};
	a._updateAtlasIndex = function(a) {
		var b = this._node._descendants,
			d = a.children,
			e, f = d.length;
		for(e = 0; e <
			f; e++)
			if(0 > d[e]._localZOrder) b.push(d[e]);
			else break;
		for(b.push(a); e < f; e++) b.push(d[e])
	};
	a.getTextureAtlas = function() {};
	a.setTextureAtlas = function(a) {};
	a.cutting = function(a, b) {
		this._node._children.splice(b, 0, a)
	}
})();
(function() {
	cc.SpriteBatchNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureAtlas = null
	};
	var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
	a.isValidChild = function(a) {
		return a instanceof cc.Sprite ? a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
	};
	a.rendering = function() {
		var a = this._node;
		0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
	};
	a.visit = function(a) {
		var b = this._node;
		if(b._visible) {
			b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._dirtyFlag &
				cc.Node._dirtyFlags.transformDirty || this.transform(a);
			this.updateStatus(a);
			d.top = this._stackMatrix;
			b.sortAllChildren();
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.checkAtlasCapacity = function(a) {
		for(var b = this._textureAtlas; a >= b.capacity || b.capacity === b.totalQuads;) this.increaseAtlasCapacity()
	};
	a.increaseAtlasCapacity = function() {
		var a = this._textureAtlas.capacity,
			b = Math.floor(4 * (a + 1) / 3);
		cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, b);
		this._textureAtlas.resizeCapacity(b) ||
			cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
	};
	a.initWithTexture = function(a, b) {
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(a, b);
		this._updateBlendFunc();
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a.insertQuad = function(a, b) {
		var d = this._textureAtlas;
		d.totalQuads >= d.capacity && this.increaseAtlasCapacity();
		d.insertQuad(a.quad, b)
	};
	a.removeQuadAtIndex = function(a) {
		this._textureAtlas.removeQuadAtIndex(a)
	};
	a.getTexture = function() {
		return this._textureAtlas.texture
	};
	a.setTexture = function(a) {
		this._textureAtlas.setTexture(a);
		a && this._updateBlendFunc()
	};
	a.removeAllQuads = function() {
		this._textureAtlas.removeAllQuads()
	};
	a._swap = function(a, b) {
		var d = this._node._descendants,
			e = this._textureAtlas,
			f = e.quads,
			g = d[a],
			h = cc.V3F_C4B_T2F_QuadCopy(f[a]);
		d[b].atlasIndex = a;
		d[a] = d[b];
		e.updateQuad(f[b], a);
		d[b] = g;
		e.updateQuad(h, b)
	};
	a._updateAtlasIndex = function(a, b) {
		var d = 0,
			e = a.children;
		e && (d = e.length);
		var f = 0;
		if(0 === d) f = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, f !== b && this._swap(f,
			b), b++;
		else {
			f = !0;
			0 <= e[0].zIndex && (f = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, f !== b && this._swap(f, b), b++, f = !1);
			for(d = 0; d < e.length; d++) {
				var g = e[d];
				f && 0 <= g.zIndex && (f = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, f !== b && this._swap(f, b), b++, f = !1);
				b = this._updateAtlasIndex(g, b)
			}
			f && (f = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, f !== b && this._swap(f, b), b++)
		}
		return b
	};
	a.updateChildrenAtlasIndex = function(a) {
		for(var b = 0, d = 0; d < a.length; d++) b = this._updateAtlasIndex(a[d], b)
	};
	a._updateBlendFunc = function() {
		if(!this._textureAtlas.texture.hasPremultipliedAlpha()) {
			var a =
				this._node._blendFunc;
			a.src = cc.SRC_ALPHA;
			a.dst = cc.ONE_MINUS_SRC_ALPHA
		}
	};
	a.getTextureAtlas = function() {
		return this._textureAtlas
	};
	a.setTextureAtlas = function(a) {
		a !== this._textureAtlas && (this._textureAtlas = a)
	};
	a.cutting = function() {}
})();
cc.BakeSprite = cc.Sprite.extend({
	_cacheCanvas: null,
	_cacheContext: null,
	ctor: function() {
		cc.Sprite.prototype.ctor.call(this);
		var a = document.createElement("canvas");
		a.width = a.height = 10;
		this._cacheCanvas = a;
		this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
		var c = new cc.Texture2D;
		c.initWithElement(a);
		c.handleLoadedTexture();
		this.setTexture(c)
	},
	getCacheContext: function() {
		return this._cacheContext
	},
	getCacheCanvas: function() {
		return this._cacheCanvas
	},
	resetCanvasSize: function(a, c) {
		var b = this._cacheCanvas,
			d = this._cacheContext,
			e = d._context.strokeStyle,
			f = d._context.fillStyle;
		void 0 === c && (c = a.height, a = a.width);
		b.width = a;
		b.height = c;
		e !== d._context.strokeStyle && (d._context.strokeStyle = e);
		f !== d._context.fillStyle && (d._context.fillStyle = f);
		this.getTexture().handleLoadedTexture();
		this.setTextureRect(cc.rect(0, 0, a, c), !1)
	}
});
cc.AnimationFrame = cc.Class.extend({
	_spriteFrame: null,
	_delayPerUnit: 0,
	_userInfo: null,
	ctor: function(a, c, b) {
		this._spriteFrame = a || null;
		this._delayPerUnit = c || 0;
		this._userInfo = b || null
	},
	clone: function() {
		var a = new cc.AnimationFrame;
		a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return a
	},
	copyWithZone: function(a) {
		return cc.clone(this)
	},
	copy: function(a) {
		a = new cc.AnimationFrame;
		a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return a
	},
	initWithSpriteFrame: function(a,
		c, b) {
		this._spriteFrame = a;
		this._delayPerUnit = c;
		this._userInfo = b;
		return !0
	},
	getSpriteFrame: function() {
		return this._spriteFrame
	},
	setSpriteFrame: function(a) {
		this._spriteFrame = a
	},
	getDelayUnits: function() {
		return this._delayPerUnit
	},
	setDelayUnits: function(a) {
		this._delayPerUnit = a
	},
	getUserInfo: function() {
		return this._userInfo
	},
	setUserInfo: function(a) {
		this._userInfo = a
	}
});
cc.AnimationFrame.create = function(a, c, b) {
	return new cc.AnimationFrame(a, c, b)
};
cc.Animation = cc.Class.extend({
	_frames: null,
	_loops: 0,
	_restoreOriginalFrame: !1,
	_duration: 0,
	_delayPerUnit: 0,
	_totalDelayUnits: 0,
	ctor: function(a, c, b) {
		this._frames = [];
		if(void 0 === a) this.initWithSpriteFrames(null, 0);
		else {
			var d = a[0];
			d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, c, b) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, c, b))
		}
	},
	getFrames: function() {
		return this._frames
	},
	setFrames: function(a) {
		this._frames = a
	},
	addSpriteFrame: function(a) {
		var c = new cc.AnimationFrame;
		c.initWithSpriteFrame(a,
			1, null);
		this._frames.push(c);
		this._totalDelayUnits++
	},
	addSpriteFrameWithFile: function(a) {
		a = cc.textureCache.addImage(a);
		var c = cc.rect(0, 0, 0, 0);
		c.width = a.width;
		c.height = a.height;
		a = new cc.SpriteFrame(a, c);
		this.addSpriteFrame(a)
	},
	addSpriteFrameWithTexture: function(a, c) {
		var b = new cc.SpriteFrame(a, c);
		this.addSpriteFrame(b)
	},
	initWithAnimationFrames: function(a, c, b) {
		cc.arrayVerifyType(a, cc.AnimationFrame);
		this._delayPerUnit = c;
		this._loops = void 0 === b ? 1 : b;
		this._totalDelayUnits = 0;
		c = this._frames;
		for(b = c.length =
			0; b < a.length; b++) {
			var d = a[b];
			c.push(d);
			this._totalDelayUnits += d.getDelayUnits()
		}
		return !0
	},
	clone: function() {
		var a = new cc.Animation;
		a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		a.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return a
	},
	copyWithZone: function(a) {
		a = new cc.Animation;
		a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		a.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return a
	},
	_copyFrames: function() {
		for(var a = [], c = 0; c < this._frames.length; c++) a.push(this._frames[c].clone());
		return a
	},
	copy: function(a) {
		return this.copyWithZone(null)
	},
	getLoops: function() {
		return this._loops
	},
	setLoops: function(a) {
		this._loops = a
	},
	setRestoreOriginalFrame: function(a) {
		this._restoreOriginalFrame = a
	},
	getRestoreOriginalFrame: function() {
		return this._restoreOriginalFrame
	},
	getDuration: function() {
		return this._totalDelayUnits * this._delayPerUnit
	},
	getDelayPerUnit: function() {
		return this._delayPerUnit
	},
	setDelayPerUnit: function(a) {
		this._delayPerUnit = a
	},
	getTotalDelayUnits: function() {
		return this._totalDelayUnits
	},
	initWithSpriteFrames: function(a, c, b) {
		cc.arrayVerifyType(a, cc.SpriteFrame);
		this._loops = void 0 === b ? 1 : b;
		this._delayPerUnit = c || 0;
		this._totalDelayUnits = 0;
		c = this._frames;
		c.length = 0;
		if(a) {
			for(b = 0; b < a.length; b++) {
				var d = a[b],
					e = new cc.AnimationFrame;
				e.initWithSpriteFrame(d, 1, null);
				c.push(e)
			}
			this._totalDelayUnits += a.length
		}
		return !0
	},
	retain: function() {},
	release: function() {}
});
cc.Animation.create = function(a, c, b) {
	return new cc.Animation(a, c, b)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
	_animations: {},
	addAnimation: function(a, c) {
		this._animations[c] = a
	},
	removeAnimation: function(a) {
		a && this._animations[a] && delete this._animations[a]
	},
	getAnimation: function(a) {
		return this._animations[a] ? this._animations[a] : null
	},
	_addAnimationsWithDictionary: function(a, c) {
		var b = a.animations;
		if(b) {
			var d = 1,
				e = a.properties;
			if(e)
				for(var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++) f.addSpriteFrames(g.changeBasename(c, e[h]));
			switch(d) {
				case 1:
					this._parseVersion1(b);
					break;
				case 2:
					this._parseVersion2(b);
					break;
				default:
					cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
			}
		} else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
	},
	addAnimations: function(a) {
		cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
		var c = cc.loader.getRes(a);
		c ? this._addAnimationsWithDictionary(c, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
	},
	_parseVersion1: function(a) {
		var c = cc.spriteFrameCache,
			b;
		for(b in a) {
			var d = a[b],
				e = d.frames,
				d = parseFloat(d.delay) ||
				0,
				f = null;
			if(e) {
				for(var f = [], g = 0; g < e.length; g++) {
					var h = c.getSpriteFrame(e[g]);
					if(h) {
						var k = new cc.AnimationFrame;
						k.initWithSpriteFrame(h, 1, null);
						f.push(k)
					} else cc.log(cc._LogInfos.animationCache__parseVersion1_2, b, e[g])
				}
				0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, b) : (f.length !== e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, b), f = new cc.Animation(f, d, 1), cc.animationCache.addAnimation(f, b))
			} else cc.log(cc._LogInfos.animationCache__parseVersion1, b)
		}
	},
	_parseVersion2: function(a) {
		var c =
			cc.spriteFrameCache,
			b;
		for(b in a) {
			var d = a[b],
				e = d.loop,
				f = parseInt(d.loops),
				e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
				f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1,
				g = d.frames;
			if(g) {
				for(var h = [], k = 0; k < g.length; k++) {
					var m = g[k],
						n = m.spriteframe,
						p = c.getSpriteFrame(n);
					if(p) {
						var n = parseFloat(m.delayUnits) || 0,
							m = m.notification,
							s = new cc.AnimationFrame;
						s.initWithSpriteFrame(p, n, m);
						h.push(s)
					} else cc.log(cc._LogInfos.animationCache__parseVersion2_2, b, n)
				}
				d = parseFloat(d.delayPerUnit) || 0;
				g = new cc.Animation;
				g.initWithAnimationFrames(h,
					d, e);
				g.setRestoreOriginalFrame(f);
				cc.animationCache.addAnimation(g, b)
			} else cc.log(cc._LogInfos.animationCache__parseVersion2, b)
		}
	},
	_clear: function() {
		this._animations = {}
	}
};
cc.SpriteFrame = cc.Class.extend({
	_offset: null,
	_originalSize: null,
	_rectInPixels: null,
	_rotated: !1,
	_rect: null,
	_offsetInPixels: null,
	_originalSizeInPixels: null,
	_texture: null,
	_textureFilename: "",
	_textureLoaded: !1,
	ctor: function(a, c, b, d, e) {
		this._offset = cc.p(0, 0);
		this._offsetInPixels = cc.p(0, 0);
		this._originalSize = cc.size(0, 0);
		this._rotated = !1;
		this._originalSizeInPixels = cc.size(0, 0);
		this._textureFilename = "";
		this._texture = null;
		this._textureLoaded = !1;
		void 0 !== a && void 0 !== c && (void 0 === b || void 0 === d || void 0 === e ?
			this.initWithTexture(a, c) : this.initWithTexture(a, c, b, d, e))
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, c) {
		this.addEventListener("load", a, c)
	},
	getRectInPixels: function() {
		var a = this._rectInPixels;
		return cc.rect(a.x, a.y, a.width, a.height)
	},
	setRectInPixels: function(a) {
		this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
		this._rectInPixels.x = a.x;
		this._rectInPixels.y = a.y;
		this._rectInPixels.width = a.width;
		this._rectInPixels.height = a.height;
		this._rect = cc.rectPixelsToPoints(a)
	},
	isRotated: function() {
		return this._rotated
	},
	setRotated: function(a) {
		this._rotated = a
	},
	getRect: function() {
		var a = this._rect;
		return cc.rect(a.x, a.y, a.width, a.height)
	},
	setRect: function(a) {
		this._rect || (this._rect = cc.rect(0, 0, 0, 0));
		this._rect.x = a.x;
		this._rect.y = a.y;
		this._rect.width = a.width;
		this._rect.height = a.height;
		this._rectInPixels = cc.rectPointsToPixels(this._rect)
	},
	getOffsetInPixels: function() {
		return cc.p(this._offsetInPixels)
	},
	setOffsetInPixels: function(a) {
		this._offsetInPixels.x = a.x;
		this._offsetInPixels.y =
			a.y;
		cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
	},
	getOriginalSizeInPixels: function() {
		return cc.size(this._originalSizeInPixels)
	},
	setOriginalSizeInPixels: function(a) {
		this._originalSizeInPixels.width = a.width;
		this._originalSizeInPixels.height = a.height
	},
	getOriginalSize: function() {
		return cc.size(this._originalSize)
	},
	setOriginalSize: function(a) {
		this._originalSize.width = a.width;
		this._originalSize.height = a.height
	},
	getTexture: function() {
		if(this._texture) return this._texture;
		if("" !== this._textureFilename) {
			var a =
				cc.textureCache.addImage(this._textureFilename);
			a && (this._textureLoaded = a.isLoaded());
			return a
		}
		return null
	},
	setTexture: function(a) {
		if(this._texture !== a) {
			var c = a.isLoaded();
			this._textureLoaded = c;
			this._texture = a;
			c || a.addEventListener("load", function(a) {
				this._textureLoaded = !0;
				if(this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
					var c = a.getHtmlElementObj(),
						c = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(c, this.getRect()),
						e = new cc.Texture2D;
					e.initWithElement(c);
					e.handleLoadedTexture();
					this.setTexture(e);
					c = this.getRect();
					this.setRect(cc.rect(0, 0, c.width, c.height))
				}
				c = this._rect;
				0 === c.width && 0 === c.height && (c = a.width, a = a.height, this._rect.width = c, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = c, this._originalSize.height = a);
				this.dispatchEvent("load")
			}, this)
		}
	},
	getOffset: function() {
		return cc.p(this._offset)
	},
	setOffset: function(a) {
		this._offset.x =
			a.x;
		this._offset.y = a.y
	},
	clone: function() {
		var a = new cc.SpriteFrame;
		a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		a.setTexture(this._texture);
		return a
	},
	copyWithZone: function() {
		var a = new cc.SpriteFrame;
		a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		a.setTexture(this._texture);
		return a
	},
	copy: function() {
		return this.copyWithZone()
	},
	initWithTexture: function(a,
		c, b, d, e) {
		2 === arguments.length && (c = cc.rectPointsToPixels(c));
		d = d || cc.p(0, 0);
		e = e || c;
		b = b || !1;
		cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
		a = this.getTexture();
		this._rectInPixels = c;
		c = this._rect = cc.rectPixelsToPoints(c);
		if(a && a.url && a.isLoaded()) {
			var f, g;
			b ? (f = c.x + c.height, g = c.y + c.width) : (f = c.x + c.width, g = c.y + c.height);
			f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
			g > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
		}
		this._offsetInPixels.x =
			d.x;
		this._offsetInPixels.y = d.y;
		cc._pointPixelsToPointsOut(d, this._offset);
		this._originalSizeInPixels.width = e.width;
		this._originalSizeInPixels.height = e.height;
		cc._sizePixelsToPointsOut(e, this._originalSize);
		this._rotated = b;
		return !0
	}
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(a, c, b, d, e) {
	return new cc.SpriteFrame(a, c, b, d, e)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, c, b, d, e) {
	var f = new cc.SpriteFrame;
	f._texture = a;
	f._rectInPixels = c;
	f._rect = cc.rectPixelsToPoints(c);
	f._offsetInPixels.x = d.x;
	f._offsetInPixels.y = d.y;
	cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset);
	f._originalSizeInPixels.width = e.width;
	f._originalSizeInPixels.height = e.height;
	cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize);
	f._rotated = b;
	return f
};
cc.spriteFrameCache = {
	_CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
	_CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
	_spriteFrames: {},
	_spriteFramesAliases: {},
	_frameConfigCache: {},
	_rectFromString: function(a) {
		return(a = this._CCNS_REG2.exec(a)) ? cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4])) : cc.rect(0, 0, 0, 0)
	},
	_pointFromString: function(a) {
		return(a = this._CCNS_REG1.exec(a)) ?
			cc.p(parseFloat(a[1]), parseFloat(a[2])) : cc.p(0, 0)
	},
	_sizeFromString: function(a) {
		return(a = this._CCNS_REG1.exec(a)) ? cc.size(parseFloat(a[1]), parseFloat(a[2])) : cc.size(0, 0)
	},
	_getFrameConfig: function(a) {
		var c = cc.loader.getRes(a);
		cc.assert(c, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
		cc.loader.release(a);
		if(c._inited) return this._frameConfigCache[a] = c;
		this._frameConfigCache[a] = this._parseFrameConfig(c);
		return this._frameConfigCache[a]
	},
	_getFrameConfigByJsonObject: function(a, c) {
		cc.assert(c, cc._LogInfos.spriteFrameCache__getFrameConfig_2,
			a);
		this._frameConfigCache[a] = this._parseFrameConfig(c);
		return this._frameConfigCache[a]
	},
	_parseFrameConfig: function(a) {
		var c = a.frames,
			b = a.metadata || a.meta;
		a = {};
		var d = {},
			e = 0;
		b && (e = b.format, e = 1 >= e.length ? parseInt(e) : e, d.image = b.textureFileName || b.textureFileName || b.image);
		for(var f in c) {
			var g = c[f];
			if(g) {
				b = {};
				if(0 == e) {
					b.rect = cc.rect(g.x, g.y, g.width, g.height);
					b.rotated = !1;
					b.offset = cc.p(g.offsetX, g.offsetY);
					var h = g.originalWidth,
						g = g.originalHeight;
					h && g || cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
					h = Math.abs(h);
					g = Math.abs(g);
					b.size = cc.size(h, g)
				} else if(1 == e || 2 == e) b.rect = this._rectFromString(g.frame), b.rotated = g.rotated || !1, b.offset = this._pointFromString(g.offset), b.size = this._sizeFromString(g.sourceSize);
				else if(3 == e) {
					var h = this._sizeFromString(g.spriteSize),
						k = this._rectFromString(g.textureRect);
					h && (k = cc.rect(k.x, k.y, h.width, h.height));
					b.rect = k;
					b.rotated = g.textureRotated || !1;
					b.offset = this._pointFromString(g.spriteOffset);
					b.size = this._sizeFromString(g.spriteSourceSize);
					b.aliases = g.aliases
				} else h =
					g.frame, k = g.sourceSize, f = g.filename || f, b.rect = cc.rect(h.x, h.y, h.w, h.h), b.rotated = g.rotated || !1, b.offset = cc.p(0, 0), b.size = cc.size(k.w, k.h);
				a[f] = b
			}
		}
		return {
			_inited: !0,
			frames: a,
			meta: d
		}
	},
	_addSpriteFramesByObject: function(a, c, b) {
		cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
		c && c.frames && (c = this._frameConfigCache[a] || this._getFrameConfigByJsonObject(a, c), this._createSpriteFrames(a, c, b))
	},
	_createSpriteFrames: function(a, c, b) {
		var d = c.frames;
		c = c.meta;
		b ? b instanceof cc.Texture2D || (cc.isString(b) ?
			b = cc.textureCache.addImage(b) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (b = cc.path.changeBasename(a, c.image || ".png", !1, !0), b = cc.textureCache.addImage(b));
		a = this._spriteFramesAliases;
		c = this._spriteFrames;
		for(var e in d) {
			var f = d[e],
				g = c[e];
			if(!g) {
				g = new cc.SpriteFrame(b, f.rect, f.rotated, f.offset, f.size);
				if(f = f.aliases)
					for(var h = 0, k = f.length; h < k; h++) {
						var m = f[h];
						a[m] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, m);
						a[m] = e
					}
				cc._renderType === cc._RENDER_TYPE_CANVAS && g.isRotated() &&
					g.getTexture().isLoaded() && (f = g.getTexture().getHtmlElementObj(), f = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(f, g.getRectInPixels()), h = new cc.Texture2D, h.initWithElement(f), h.handleLoadedTexture(), g.setTexture(h), f = g._rect, g.setRect(cc.rect(0, 0, f.width, f.height)));
				c[e] = g
			}
		}
	},
	addSpriteFrames: function(a, c) {
		cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
		var b = this._frameConfigCache[a] || cc.loader.getRes(a);
		b && b.frames && (b = this._frameConfigCache[a] || this._getFrameConfig(a), this._createSpriteFrames(a,
			b, c))
	},
	_checkConflict: function(a) {
		a = a.frames;
		for(var c in a) this._spriteFrames[c] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, c)
	},
	addSpriteFrame: function(a, c) {
		this._spriteFrames[c] = a
	},
	removeSpriteFrames: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {}
	},
	removeSpriteFrameByName: function(a) {
		a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
	},
	removeSpriteFramesFromFile: function(a) {
		var c = this._spriteFrames,
			b =
			this._spriteFramesAliases;
		if(a = this._frameConfigCache[a]) {
			a = a.frames;
			for(var d in a)
				if(c[d]) {
					delete c[d];
					for(var e in b) b[e] === d && delete b[e]
				}
		}
	},
	removeSpriteFramesFromTexture: function(a) {
		var c = this._spriteFrames,
			b = this._spriteFramesAliases,
			d;
		for(d in c) {
			var e = c[d];
			if(e && e.getTexture() === a) {
				delete c[d];
				for(var f in b) b[f] === d && delete b[f]
			}
		}
	},
	getSpriteFrame: function(a) {
		var c = this._spriteFrames[a];
		if(!c) {
			var b = this._spriteFramesAliases[a];
			b && ((c = this._spriteFrames[b.toString()]) || delete this._spriteFramesAliases[a])
		}
		return c
	},
	_clear: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {};
		this._frameConfigCache = {}
	}
};
cc.configuration = {
	ERROR: 0,
	STRING: 1,
	INT: 2,
	DOUBLE: 3,
	BOOLEAN: 4,
	_maxTextureSize: 0,
	_maxModelviewStackDepth: 0,
	_supportsPVRTC: !1,
	_supportsNPOT: !1,
	_supportsBGRA8888: !1,
	_supportsDiscardFramebuffer: !1,
	_supportsShareableVAO: !1,
	_maxSamplesAllowed: 0,
	_maxTextureUnits: 0,
	_GlExtensions: "",
	_valueDict: {},
	_inited: !1,
	_init: function() {
		var a = this._valueDict;
		a["cocos2d.x.version"] = cc.ENGINE_VERSION;
		a["cocos2d.x.compiled_with_profiler"] = !1;
		a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
		this._inited = !0
	},
	getMaxTextureSize: function() {
		return this._maxTextureSize
	},
	getMaxModelviewStackDepth: function() {
		return this._maxModelviewStackDepth
	},
	getMaxTextureUnits: function() {
		return this._maxTextureUnits
	},
	supportsNPOT: function() {
		return this._supportsNPOT
	},
	supportsPVRTC: function() {
		return this._supportsPVRTC
	},
	supportsETC: function() {
		return !1
	},
	supportsS3TC: function() {
		return !1
	},
	supportsATITC: function() {
		return !1
	},
	supportsBGRA8888: function() {
		return this._supportsBGRA8888
	},
	supportsDiscardFramebuffer: function() {
		return this._supportsDiscardFramebuffer
	},
	supportsShareableVAO: function() {
		return this._supportsShareableVAO
	},
	checkForGLExtension: function(a) {
		return -1 < this._GlExtensions.indexOf(a)
	},
	getValue: function(a, c) {
		this._inited || this._init();
		var b = this._valueDict;
		return b[a] ? b[a] : c
	},
	setValue: function(a, c) {
		this._valueDict[a] = c
	},
	dumpInfo: function() {
		0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
	},
	gatherGPUInfo: function() {
		if(cc._renderType !== cc._RENDER_TYPE_CANVAS) {
			this._inited || this._init();
			var a = cc._renderContext,
				c = this._valueDict;
			c["gl.vendor"] = a.getParameter(a.VENDOR);
			c["gl.renderer"] = a.getParameter(a.RENDERER);
			c["gl.version"] = a.getParameter(a.VERSION);
			this._GlExtensions = "";
			for(var b = a.getSupportedExtensions(), d = 0; d < b.length; d++) this._GlExtensions += b[d] + " ";
			this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
			c["gl.max_texture_size"] = this._maxTextureSize;
			this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			c["gl.max_texture_units"] = this._maxTextureUnits;
			this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
			c["gl.supports_PVRTC"] = this._supportsPVRTC;
			this._supportsNPOT = !1;
			c["gl.supports_NPOT"] = this._supportsNPOT;
			this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
			c["gl.supports_BGRA8888"] = this._supportsBGRA8888;
			this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
			c["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
			this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
			c["gl.supports_vertex_array_object"] =
				this._supportsShareableVAO;
			cc.checkGLErrorDebug()
		}
	},
	loadConfigFile: function(a) {
		this._inited || this._init();
		var c = cc.loader.getRes(a);
		if(!c) throw "Please load the resource first : " + a;
		cc.assert(c, cc._LogInfos.configuration_loadConfigFile_2, a);
		if(c = c.data)
			for(var b in c) this._valueDict[b] = c[b];
		else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
	}
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
	cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
	var c = new cc.math.Matrix4;
	cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c);
	a.multiply(c)
};
cc.androidBlackList = ["hisense e100", "gt-s7572"];
cc.isInAndroidBlackList = !1;
for(var i = 0; i < cc.androidBlackList.length; i++) 0 <= navigator.userAgent.toLowerCase().indexOf(cc.androidBlackList[i]) && (cc.isInAndroidBlackList = !0);
cc.Director = cc.Class.extend({
	_landscape: !1,
	_nextDeltaTimeZero: !1,
	_paused: !1,
	_purgeDirectorInNextLoop: !1,
	_sendCleanupToScene: !1,
	_animationInterval: 0,
	_oldAnimationInterval: 0,
	_projection: 0,
	_accumDt: 0,
	_contentScaleFactor: 1,
	_displayStats: !1,
	_deltaTime: 0,
	_frameRate: 0,
	_FPSLabel: null,
	_SPFLabel: null,
	_drawsLabel: null,
	_winSizeInPoints: null,
	_lastUpdate: null,
	_nextScene: null,
	_notificationNode: null,
	_openGLView: null,
	_scenesStack: null,
	_projectionDelegate: null,
	_runningScene: null,
	_frames: 0,
	_totalFrames: 0,
	_secondsPerFrame: 0,
	_dirtyRegion: null,
	_scheduler: null,
	_actionManager: null,
	_eventProjectionChanged: null,
	_eventAfterDraw: null,
	_eventAfterVisit: null,
	_eventAfterUpdate: null,
	ctor: function() {
		var a = this;
		a._lastUpdate = Date.now();
		cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
			a._lastUpdate = Date.now()
		})
	},
	init: function() {
		this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
		this._scenesStack = [];
		this._projection = cc.Director.PROJECTION_DEFAULT;
		this._projectionDelegate = null;
		this._frameRate = this._accumDt =
			0;
		this._displayStats = !1;
		this._totalFrames = this._frames = 0;
		this._lastUpdate = Date.now();
		this._purgeDirectorInNextLoop = this._paused = !1;
		this._winSizeInPoints = cc.size(0, 0);
		this._openGLView = null;
		this._contentScaleFactor = 1;
		this._scheduler = new cc.Scheduler;
		cc.ActionManager ? (this._actionManager = new cc.ActionManager, this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null;
		this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
		this._eventAfterDraw.setUserData(this);
		this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
		this._eventAfterVisit.setUserData(this);
		this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
		this._eventAfterUpdate.setUserData(this);
		this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
		this._eventProjectionChanged.setUserData(this);
		return !0
	},
	calculateDeltaTime: function() {
		var a = Date.now();
		this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime =
			(a - this._lastUpdate) / 1E3;
		0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
		this._lastUpdate = a
	},
	convertToGL: null,
	convertToUI: null,
	drawScene: function() {
		var a = cc.renderer;
		this.calculateDeltaTime();
		this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
		this._clear();
		this._nextScene && this.setNextScene();
		this._beforeVisitScene && this._beforeVisitScene();
		this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(),
			this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
		this._notificationNode && this._notificationNode.visit();
		this._displayStats && this._showStats();
		this._afterVisitScene && this._afterVisitScene();
		a.rendering(cc._renderContext);
		cc.eventManager.dispatchEvent(this._eventAfterDraw);
		this._totalFrames++;
		this._displayStats && this._calculateMPF()
	},
	_beforeVisitScene: null,
	_afterVisitScene: null,
	end: function() {
		this._purgeDirectorInNextLoop = !0
	},
	getContentScaleFactor: function() {
		return this._contentScaleFactor
	},
	getNotificationNode: function() {
		return this._notificationNode
	},
	getWinSize: function() {
		return cc.size(this._winSizeInPoints)
	},
	getWinSizeInPixels: function() {
		return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
	},
	getVisibleSize: null,
	getVisibleOrigin: null,
	getZEye: null,
	pause: function() {
		this._paused || (this._oldAnimationInterval =
			this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
	},
	popScene: function() {
		cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
		this._scenesStack.pop();
		var a = this._scenesStack.length;
		0 === a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
	},
	purgeCachedData: function() {
		cc.animationCache._clear();
		cc.spriteFrameCache._clear();
		cc.textureCache._clear()
	},
	purgeDirector: function() {
		this.getScheduler().unscheduleAll();
		cc.eventManager && cc.eventManager.setEnabled(!1);
		this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
		this._nextScene = this._runningScene = null;
		this._scenesStack.length = 0;
		this.stopAnimation();
		this.purgeCachedData();
		cc.checkGLErrorDebug()
	},
	pushScene: function(a) {
		cc.assert(a, cc._LogInfos.Director_pushScene);
		this._sendCleanupToScene = !1;
		this._scenesStack.push(a);
		this._nextScene = a
	},
	runScene: function(a) {
		cc.assert(a, cc._LogInfos.Director_pushScene);
		if(this._runningScene) {
			var c = this._scenesStack.length;
			0 === c ? (this._sendCleanupToScene = !0, this._scenesStack[c] = a) : (this._sendCleanupToScene = !0, this._scenesStack[c - 1] = a);
			this._nextScene = a
		} else this.pushScene(a), this.startAnimation()
	},
	resume: function() {
		this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
	},
	setContentScaleFactor: function(a) {
		a !== this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
	},
	setDepthTest: null,
	setDefaultValues: function() {},
	setNextDeltaTimeZero: function(a) {
		this._nextDeltaTimeZero = a
	},
	setNextScene: function() {
		var a = !1,
			c = !1;
		cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, c = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
		if(!c) {
			if(c = this._runningScene) c.onExitTransitionDidStart(), c.onExit();
			this._sendCleanupToScene && c && c.cleanup()
		}
		this._runningScene = this._nextScene;
		cc.renderer.childrenOrderDirty = !0;
		this._nextScene = null;
		a || null ===
			this._runningScene || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
	},
	setNotificationNode: function(a) {
		this._notificationNode = a
	},
	getDelegate: function() {
		return this._projectionDelegate
	},
	setDelegate: function(a) {
		this._projectionDelegate = a
	},
	setOpenGLView: null,
	setProjection: null,
	setViewport: null,
	getOpenGLView: null,
	getProjection: null,
	setAlphaBlending: null,
	_showStats: function() {
		this._frames++;
		this._accumDt += this._deltaTime;
		this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt >
			cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
		cc.g_NumberOfDraws = 0
	},
	isSendCleanupToScene: function() {
		return this._sendCleanupToScene
	},
	getRunningScene: function() {
		return this._runningScene
	},
	getAnimationInterval: function() {
		return this._animationInterval
	},
	isDisplayStats: function() {
		return this._displayStats
	},
	setDisplayStats: function(a) {
		this._displayStats = a
	},
	getSecondsPerFrame: function() {
		return this._secondsPerFrame
	},
	isNextDeltaTimeZero: function() {
		return this._nextDeltaTimeZero
	},
	isPaused: function() {
		return this._paused
	},
	getTotalFrames: function() {
		return this._totalFrames
	},
	popToRootScene: function() {
		this.popToSceneStackLevel(1)
	},
	popToSceneStackLevel: function(a) {
		cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
		var c = this._scenesStack,
			b = c.length;
		if(0 === b) this.end();
		else if(!(a > b)) {
			for(; b > a;) {
				var d = c.pop();
				d.running && (d.onExitTransitionDidStart(), d.onExit());
				d.cleanup();
				b--
			}
			this._nextScene = c[c.length - 1];
			this._sendCleanupToScene = !1
		}
	},
	getScheduler: function() {
		return this._scheduler
	},
	setScheduler: function(a) {
		this._scheduler !== a && (this._scheduler = a)
	},
	getActionManager: function() {
		return this._actionManager
	},
	setActionManager: function(a) {
		this._actionManager !== a && (this._actionManager = a)
	},
	getDeltaTime: function() {
		return this._deltaTime
	},
	_createStatsLabel: null,
	_calculateMPF: function() {
		this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
	}
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
	invalid: !1,
	startAnimation: function() {
		this._nextDeltaTimeZero = !0;
		this.invalid = !1
	},
	mainLoop: function() {
		this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
	},
	stopAnimation: function() {
		this.invalid = !0
	},
	setAnimationInterval: function(a) {
		this._animationInterval = a;
		this.invalid || (this.stopAnimation(), this.startAnimation())
	}
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
	cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
	return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
	this._projection = a;
	cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setOpenGLView = function(a) {
	this._winSizeInPoints.width = cc._canvas.width;
	this._winSizeInPoints.height = cc._canvas.height;
	this._openGLView = a || cc.view;
	cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function() {
	var a = this._openGLView.getViewPortRect(),
		c = cc._renderContext.getContext();
	c.setTransform(1,
		0, 0, 1, 0, 0);
	cc.isInAndroidBlackList ? (c.clearRect(-a.x, a.y, a.width, a.height), c.canvas.width = c.canvas.width) : (c.save(), c.fillStyle = "#000000", c.fillRect(-a.x, a.y, a.width, a.height), c.restore())
}, _p._createStatsLabel = function() {
	var a = 0,
		a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | this._winSizeInPoints.height / 320 * 24 : 0 | this._winSizeInPoints.width / 320 * 24;
	this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
	this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
	this._drawsLabel = new cc.LabelTTF("0000",
		"Arial", a);
	a = cc.DIRECTOR_STATS_POSITION;
	this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
	this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
	this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function() {
	return this.getWinSize()
}, _p.getVisibleOrigin = function() {
	return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
	cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage));
cc._renderType === cc._RENDER_TYPE_WEBGL && function() {
	cc.DirectorDelegate = cc.Class.extend({
		updateProjection: function() {}
	});
	var a = cc.Director.prototype;
	a.setProjection = function(a) {
		var b = this._winSizeInPoints;
		this.setViewport();
		var d = this._openGLView,
			e = d._viewPortRect.x / d._scaleX,
			f = d._viewPortRect.y / d._scaleY;
		switch(a) {
			case cc.Director.PROJECTION_2D:
				cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
				cc.kmGLLoadIdentity();
				d = cc.math.Matrix4.createOrthographicProjection(-e, b.width - e, -f, b.height - f, -1024, 1024);
				cc.kmGLMultMatrix(d);
				cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
				cc.kmGLLoadIdentity();
				break;
			case cc.Director.PROJECTION_3D:
				var g = this.getZEye(),
					h = new cc.math.Matrix4,
					d = new cc.math.Matrix4;
				cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
				cc.kmGLLoadIdentity();
				h = cc.math.Matrix4.createPerspectiveProjection(60, b.width / b.height, 0.1, 2 * g);
				cc.kmGLMultMatrix(h);
				cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
				cc.kmGLLoadIdentity();
				g = new cc.math.Vec3(-e + b.width / 2, -f + b.height / 2, g);
				b = new cc.math.Vec3(-e + b.width / 2, -f + b.height / 2, 0);
				e = new cc.math.Vec3(0, 1, 0);
				d.lookAt(g, b, e);
				cc.kmGLMultMatrix(d);
				break;
			case cc.Director.PROJECTION_CUSTOM:
				this._projectionDelegate && this._projectionDelegate.updateProjection();
				break;
			default:
				cc.log(cc._LogInfos.Director_setProjection)
		}
		this._projection = a;
		cc.eventManager.dispatchEvent(this._eventProjectionChanged);
		cc.setProjectionMatrixDirty();
		cc.renderer.childrenOrderDirty = !0
	};
	a.setDepthTest = function(a) {
		var b = cc._renderContext;
		a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
	};
	a.setOpenGLView =
		function(a) {
			this._winSizeInPoints.width = cc._canvas.width;
			this._winSizeInPoints.height = cc._canvas.height;
			this._openGLView = a || cc.view;
			a = cc.configuration;
			a.gatherGPUInfo();
			a.dumpInfo();
			this._createStatsLabel();
			this.setGLDefaultValues();
			cc.eventManager && cc.eventManager.setEnabled(!0)
		};
	a._clear = function() {
		var a = cc._renderContext;
		a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
	};
	a._beforeVisitScene = function() {
		cc.kmGLPushMatrix()
	};
	a._afterVisitScene = function() {
		cc.kmGLPopMatrix()
	};
	a._createStatsLabel = function() {
		if(!cc.LabelAtlas) this._createStatsLabelForCanvas();
		else if(null != cc.Director._fpsImageLoaded && !1 !== cc.Director._fpsImageLoaded) {
			var a = new cc.Texture2D;
			a.initWithElement(cc.Director._fpsImage);
			a.handleLoadedTexture();
			var b = cc.view.getDesignResolutionSize().height / 320;
			0 === b && (b = this._winSizeInPoints.height / 320);
			var d = new cc.LabelAtlas;
			d._setIgnoreContentScaleFactor(!0);
			d.initWithString("00.0", a, 12, 32, ".");
			d.scale = b;
			this._FPSLabel = d;
			d = new cc.LabelAtlas;
			d._setIgnoreContentScaleFactor(!0);
			d.initWithString("0.000", a, 12, 32, ".");
			d.scale = b;
			this._SPFLabel =
				d;
			d = new cc.LabelAtlas;
			d._setIgnoreContentScaleFactor(!0);
			d.initWithString("000", a, 12, 32, ".");
			d.scale = b;
			this._drawsLabel = d;
			a = cc.DIRECTOR_STATS_POSITION;
			this._drawsLabel.setPosition(a.x, 34 * b + a.y);
			this._SPFLabel.setPosition(a.x, 17 * b + a.y);
			this._FPSLabel.setPosition(a)
		}
	};
	a._createStatsLabelForCanvas = function() {
		var a = 0,
			a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | this._winSizeInPoints.height / 320 * 24 : 0 | this._winSizeInPoints.width / 320 * 24;
		this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
		this._SPFLabel =
			new cc.LabelTTF("0.000", "Arial", a);
		this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
		a = cc.DIRECTOR_STATS_POSITION;
		this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
		this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
		this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
	};
	a.convertToGL = function(a) {
		var b = new cc.math.Matrix4;
		cc.GLToClipTransform(b);
		var d = b.inverse(),
			b = b.mat[14] / b.mat[15],
			e = this._openGLView.getDesignResolutionSize();
		a = new cc.math.Vec3(2 * a.x / e.width - 1, 1 - 2 * a.y / e.height, b);
		a.transformCoord(d);
		return cc.p(a.x, a.y)
	};
	a.convertToUI = function(a) {
		var b = new cc.math.Matrix4;
		cc.GLToClipTransform(b);
		a = new cc.math.Vec3(a.x, a.y, 0);
		a.transformCoord(b);
		b = this._openGLView.getDesignResolutionSize();
		return cc.p(b.width * (0.5 * a.x + 0.5), b.height * (0.5 * -a.y + 0.5))
	};
	a.getVisibleSize = function() {
		return this._openGLView.getVisibleSize()
	};
	a.getVisibleOrigin = function() {
		return this._openGLView.getVisibleOrigin()
	};
	a.getZEye = function() {
		return this._winSizeInPoints.height /
			1.1566
	};
	a.setViewport = function() {
		var a = this._openGLView;
		if(a) {
			var b = this._winSizeInPoints;
			a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, b.width, b.height)
		}
	};
	a.getOpenGLView = function() {
		return this._openGLView
	};
	a.getProjection = function() {
		return this._projection
	};
	a.setAlphaBlending = function(a) {
		a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
	};
	a.setGLDefaultValues = function() {
		this.setAlphaBlending(!0);
		this.setDepthTest(!1);
		this.setProjection(this._projection);
		cc._renderContext.clearColor(0, 0, 0, 1)
	}
}();
cc.Camera = cc.Class.extend({
	_eyeX: null,
	_eyeY: null,
	_eyeZ: null,
	_centerX: null,
	_centerY: null,
	_centerZ: null,
	_upX: null,
	_upY: null,
	_upZ: null,
	_dirty: !1,
	_lookupMatrix: null,
	ctor: function() {
		this._lookupMatrix = new cc.math.Matrix4;
		this.restore()
	},
	description: function() {
		return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
	},
	setDirty: function(a) {
		this._dirty = a
	},
	isDirty: function() {
		return this._dirty
	},
	restore: function() {
		this._eyeX = this._eyeY = 0;
		this._eyeZ = cc.Camera.getZEye();
		this._upX =
			this._centerX = this._centerY = this._centerZ = 0;
		this._upY = 1;
		this._upZ = 0;
		this._lookupMatrix.identity();
		this._dirty = !1
	},
	locate: function() {
		if(this._dirty) {
			var a = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
				c = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
				b = new cc.math.Vec3(this._upX, this._upY, this._upZ);
			this._lookupMatrix.lookAt(a, c, b);
			this._dirty = !1
		}
		cc.kmGLMultMatrix(this._lookupMatrix)
	},
	_locateForRenderer: function(a) {
		if(this._dirty) {
			var c = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
				b = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
				d = new cc.math.Vec3(this._upX, this._upY, this._upZ);
			this._lookupMatrix.lookAt(c, b, d);
			this._dirty = !1
		}
		a.multiply(this._lookupMatrix)
	},
	setEyeXYZ: function(a, c, b) {
		this.setEye(a, c, b)
	},
	setEye: function(a, c, b) {
		this._eyeX = a;
		this._eyeY = c;
		this._eyeZ = b;
		this._dirty = !0
	},
	setCenterXYZ: function(a, c, b) {
		this.setCenter(a, c, b)
	},
	setCenter: function(a, c, b) {
		this._centerX = a;
		this._centerY = c;
		this._centerZ = b;
		this._dirty = !0
	},
	setUpXYZ: function(a, c, b) {
		this.setUp(a, c, b)
	},
	setUp: function(a, c, b) {
		this._upX = a;
		this._upY = c;
		this._upZ = b;
		this._dirty = !0
	},
	getEyeXYZ: function(a, c, b) {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getEye: function() {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getCenterXYZ: function(a, c, b) {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getCenter: function() {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getUpXYZ: function(a, c, b) {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	getUp: function() {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	_DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
	return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(a, c, b, d, e, f, g) {
	this.prev = a;
	this.next = c;
	this.callback = b;
	this.target = d;
	this.priority = e;
	this.paused = f;
	this.markedForDeletion = g
};
cc.HashUpdateEntry = function(a, c, b, d, e) {
	this.list = a;
	this.entry = c;
	this.target = b;
	this.callback = d;
	this.hh = e
};
cc.HashTimerEntry = cc.hashSelectorEntry = function(a, c, b, d, e, f, g) {
	this.timers = a;
	this.target = c;
	this.timerIndex = b;
	this.currentTimer = d;
	this.currentTimerSalvaged = e;
	this.paused = f;
	this.hh = g
};
cc.Timer = cc.Class.extend({
	_scheduler: null,
	_elapsed: 0,
	_runForever: !1,
	_useDelay: !1,
	_timesExecuted: 0,
	_repeat: 0,
	_delay: 0,
	_interval: 0,
	getInterval: function() {
		return this._interval
	},
	setInterval: function(a) {
		this._interval = a
	},
	setupTimerWithInterval: function(a, c, b) {
		this._elapsed = -1;
		this._interval = a;
		this._delay = b;
		this._useDelay = 0 < this._delay;
		this._repeat = c;
		this._runForever = this._repeat === cc.REPEAT_FOREVER
	},
	trigger: function() {
		return 0
	},
	cancel: function() {
		return 0
	},
	ctor: function() {
		this._scheduler = null;
		this._elapsed = -1;
		this._useDelay = this._runForever = !1;
		this._interval = this._delay = this._repeat = this._timesExecuted = 0
	},
	update: function(a) {
		-1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted +=
			1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
	}
});
cc.TimerTargetSelector = cc.Timer.extend({
	_target: null,
	_selector: null,
	ctor: function() {
		this._selector = this._target = null
	},
	initWithSelector: function(a, c, b, d, e, f) {
		this._scheduler = a;
		this._target = b;
		this._selector = c;
		this.setupTimerWithInterval(d, e, f);
		return !0
	},
	getSelector: function() {
		return this._selector
	},
	trigger: function() {
		this._target && this._selector && this._target.call(this._selector, this._elapsed)
	},
	cancel: function() {
		this._scheduler.unschedule(this._selector, this._target)
	}
});
cc.TimerTargetCallback = cc.Timer.extend({
	_target: null,
	_callback: null,
	_key: null,
	ctor: function() {
		this._callback = this._target = null
	},
	initWithCallback: function(a, c, b, d, e, f, g) {
		this._scheduler = a;
		this._target = b;
		this._callback = c;
		this._key = d;
		this.setupTimerWithInterval(e, f, g);
		return !0
	},
	getCallback: function() {
		return this._callback
	},
	getKey: function() {
		return this._key
	},
	trigger: function() {
		this._callback && this._callback.call(this._target, this._elapsed)
	},
	cancel: function() {
		this._scheduler.unschedule(this._callback,
			this._target)
	}
});
cc.Scheduler = cc.Class.extend({
	_timeScale: 1,
	_updatesNegList: null,
	_updates0List: null,
	_updatesPosList: null,
	_hashForTimers: null,
	_arrayForTimers: null,
	_hashForUpdates: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_updateHashLocked: !1,
	ctor: function() {
		this._timeScale = 1;
		this._updatesNegList = [];
		this._updates0List = [];
		this._updatesPosList = [];
		this._hashForUpdates = {};
		this._hashForTimers = {};
		this._currentTarget = null;
		this._updateHashLocked = this._currentTargetSalvaged = !1;
		this._arrayForTimers = []
	},
	_schedulePerFrame: function(a,
		c, b, d) {
		var e = this._hashForUpdates[c.__instanceId];
		if(e && e.entry)
			if(e.entry.priority !== b) {
				if(this._updateHashLocked) {
					cc.log("warning: you CANNOT change update priority in scheduled function");
					e.entry.markedForDeletion = !1;
					e.entry.paused = d;
					return
				}
				this.unscheduleUpdate(c)
			} else {
				e.entry.markedForDeletion = !1;
				e.entry.paused = d;
				return
			}
		0 === b ? this._appendIn(this._updates0List, a, c, d) : 0 > b ? this._priorityIn(this._updatesNegList, a, c, b, d) : this._priorityIn(this._updatesPosList, a, c, b, d)
	},
	_removeHashElement: function(a) {
		delete this._hashForTimers[a.target.__instanceId];
		cc.arrayRemoveObject(this._arrayForTimers, a);
		a.Timer = null;
		a.target = null
	},
	_removeUpdateFromHash: function(a) {
		if(a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], a.entry = null, a.target = null
	},
	_priorityIn: function(a, c, b, d, e) {
		c = new cc.ListEntry(null, null, c, b, d, e, !1);
		if(a) {
			e = a.length - 1;
			for(var f = 0; f <= e && !(d < a[f].priority); f++);
			a.splice(f, 0, c)
		} else a = [], a.push(c);
		this._hashForUpdates[b.__instanceId] = new cc.HashUpdateEntry(a,
			c, b, null);
		return a
	},
	_appendIn: function(a, c, b, d) {
		c = new cc.ListEntry(null, null, c, b, 0, d, !1);
		a.push(c);
		this._hashForUpdates[b.__instanceId] = new cc.HashUpdateEntry(a, c, b, null, null)
	},
	setTimeScale: function(a) {
		this._timeScale = a
	},
	getTimeScale: function() {
		return this._timeScale
	},
	update: function(a) {
		this._updateHashLocked = !0;
		1 !== this._timeScale && (a *= this._timeScale);
		var c, b, d, e;
		c = 0;
		b = this._updatesNegList;
		for(d = b.length; c < d; c++) e = b[c], e.paused || e.markedForDeletion || e.callback(a);
		c = 0;
		b = this._updates0List;
		for(d =
			b.length; c < d; c++) e = b[c], e.paused || e.markedForDeletion || e.callback(a);
		c = 0;
		b = this._updatesPosList;
		for(d = b.length; c < d; c++) e = b[c], e.paused || e.markedForDeletion || e.callback(a);
		d = this._arrayForTimers;
		for(c = 0; c < d.length; c++) {
			this._currentTarget = b = d[c];
			this._currentTargetSalvaged = !1;
			if(!b.paused)
				for(b.timerIndex = 0; b.timerIndex < b.timers.length; ++b.timerIndex) b.currentTimer = b.timers[b.timerIndex], b.currentTimerSalvaged = !1, b.currentTimer.update(a), b.currentTimer = null;
			this._currentTargetSalvaged && 0 === this._currentTarget.timers.length &&
				this._removeHashElement(this._currentTarget)
		}
		c = 0;
		for(b = this._updatesNegList; c < b.length;) e = b[c], e.markedForDeletion ? this._removeUpdateFromHash(e) : c++;
		c = 0;
		for(b = this._updates0List; c < b.length;) e = b[c], e.markedForDeletion ? this._removeUpdateFromHash(e) : c++;
		c = 0;
		for(b = this._updatesPosList; c < b.length;) e = b[c], e.markedForDeletion ? this._removeUpdateFromHash(e) : c++;
		this._updateHashLocked = !1;
		this._currentTarget = null
	},
	scheduleCallbackForTarget: function(a, c, b, d, e, f) {
		this.schedule(c, a, b, d, e, f, a.__instanceId + "")
	},
	schedule: function(a, c, b, d, e, f, g) {
		var h = !1;
		if("function" !== typeof a) var k = a,
			h = !0;
		!1 === h ? 5 === arguments.length && (g = e, f = d, e = 0, d = cc.REPEAT_FOREVER) : 4 === arguments.length && (f = d, d = cc.REPEAT_FOREVER, e = 0);
		cc.assert(c, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
		!1 === h && cc.assert(g, "key should not be empty!");
		var m = this._hashForTimers[c.__instanceId];
		m ? cc.assert(m.paused === f, "") : (m = new cc.HashTimerEntry(null, c, 0, null, null, f, null), this._arrayForTimers.push(m), this._hashForTimers[c.__instanceId] = m);
		var n,
			p;
		if(null == m.timers) m.timers = [];
		else if(!1 === h)
			for(p = 0; p < m.timers.length; p++) {
				if(n = m.timers[p], a === n._callback) {
					cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, n.getInterval().toFixed(4), b.toFixed(4));
					n._interval = b;
					return
				}
			} else
				for(p = 0; p < m.timers.length; ++p)
					if((n = m.timers[p]) && k === n.getSelector()) {
						cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", n.getInterval(), b);
						n.setInterval(b);
						return
					}!1 === h ? (n = new cc.TimerTargetCallback, n.initWithCallback(this,
			a, c, g, b, d, e)) : (n = new cc.TimerTargetSelector, n.initWithSelector(this, k, c, b, d, e));
		m.timers.push(n)
	},
	scheduleUpdate: function(a, c, b) {
		this._schedulePerFrame(function(c) {
			a.update(c)
		}, a, c, b)
	},
	_getUnscheduleMark: function(a, c) {
		switch(typeof a) {
			case "number":
			case "string":
				return a === c.getKey();
			case "function":
				return a === c._callback;
			default:
				return a === c.getSelector()
		}
	},
	unschedule: function(a, c) {
		if(c && a) {
			var b = this._hashForTimers[c.__instanceId];
			if(b)
				for(var d = b.timers, e = 0, f = d.length; e < f; e++) {
					var g = d[e];
					if(this._getUnscheduleMark(a,
							g)) {
						g !== b.currentTimer || b.currentTimerSalvaged || (b.currentTimerSalvaged = !0);
						d.splice(e, 1);
						b.timerIndex >= e && b.timerIndex--;
						0 === d.length && (this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b));
						break
					}
				}
		}
	},
	unscheduleUpdate: function(a) {
		null != a && (a = this._hashForUpdates[a.__instanceId]) && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry))
	},
	unscheduleAllForTarget: function(a) {
		if(null != a) {
			var c = this._hashForTimers[a.__instanceId];
			c && (-1 < c.timers.indexOf(c.currentTimer) &&
				!c.currentTimerSalvaged && (c.currentTimerSalvaged = !0), c.timers.length = 0, this._currentTarget === c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
			this.unscheduleUpdate(a)
		}
	},
	unscheduleAll: function() {
		this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	unscheduleAllWithMinPriority: function(a) {
		var c, b, d = this._arrayForTimers;
		for(c = d.length - 1; 0 <= c; c--) b = d[c], this.unscheduleAllForTarget(b.target);
		d = 0;
		if(0 > a)
			for(c = 0; c < this._updatesNegList.length;) d = this._updatesNegList.length, (b = this._updatesNegList[c]) &&
				b.priority >= a && this.unscheduleUpdate(b.target), d == this._updatesNegList.length && c++;
		if(0 >= a)
			for(c = 0; c < this._updates0List.length;) d = this._updates0List.length, (b = this._updates0List[c]) && this.unscheduleUpdate(b.target), d == this._updates0List.length && c++;
		for(c = 0; c < this._updatesPosList.length;) d = this._updatesPosList.length, (b = this._updatesPosList[c]) && b.priority >= a && this.unscheduleUpdate(b.target), d == this._updatesPosList.length && c++
	},
	isScheduled: function(a, c) {
		cc.assert(a, "Argument key must not be empty");
		cc.assert(c, "Argument target must be non-nullptr");
		var b = this._hashForUpdates[c.__instanceId];
		if(!b) return !1;
		if(null != b.timers)
			for(var b = b.timers, d = 0; d < b.length; ++d)
				if(a === b[d].getKey()) return !0;
		return !1
	},
	pauseAllTargets: function() {
		return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	pauseAllTargetsWithMinPriority: function(a) {
		var c = [],
			b, d = this._arrayForTimers,
			e, f;
		e = 0;
		for(f = d.length; e < f; e++)
			if(b = d[e]) b.paused = !0, c.push(b.target);
		if(0 > a)
			for(e = 0; e < this._updatesNegList.length; e++)(b =
				this._updatesNegList[e]) && b.priority >= a && (b.paused = !0, c.push(b.target));
		if(0 >= a)
			for(e = 0; e < this._updates0List.length; e++)
				if(b = this._updates0List[e]) b.paused = !0, c.push(b.target);
		for(e = 0; e < this._updatesPosList.length; e++)(b = this._updatesPosList[e]) && b.priority >= a && (b.paused = !0, c.push(b.target));
		return c
	},
	resumeTargets: function(a) {
		if(a)
			for(var c = 0; c < a.length; c++) this.resumeTarget(a[c])
	},
	pauseTarget: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
		var c = this._hashForTimers[a.__instanceId];
		c &&
			(c.paused = !0);
		if(a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !0
	},
	resumeTarget: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
		var c = this._hashForTimers[a.__instanceId];
		c && (c.paused = !1);
		if(a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !1
	},
	isTargetPaused: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
		var c = this._hashForTimers[a.__instanceId];
		return c ? c.paused : (a = this._hashForUpdates[a.__instanceId]) ? a.entry.paused : !1
	},
	scheduleUpdateForTarget: function(a,
		c, b) {
		this.scheduleUpdate(a, c, b)
	},
	unscheduleCallbackForTarget: function(a, c) {
		this.unschedule(c, a)
	},
	unscheduleUpdateForTarget: function(a) {
		this.unscheduleUpdate(a)
	},
	unscheduleAllCallbacksForTarget: function(a) {
		this.unschedule(a.__instanceId + "", a)
	},
	unscheduleAllCallbacks: function() {
		this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	unscheduleAllCallbacksWithMinPriority: function(a) {
		this.unscheduleAllWithMinPriority(a)
	}
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
	_cacheArray: [],
	_renderContext: null,
	ctor: function(a) {
		this._renderContext = a
	},
	drawPoint: function(a, c) {
		c || (c = 1);
		var b = cc.view.getScaleX(),
			d = cc.view.getScaleY(),
			d = cc.p(a.x * b, a.y * d),
			e = this._renderContext.getContext();
		e.beginPath();
		e.arc(d.x, -d.y, c * b, 0, 2 * Math.PI, !1);
		e.closePath();
		e.fill()
	},
	drawPoints: function(a, c, b) {
		if(null != a) {
			b || (b = 1);
			c = this._renderContext.getContext();
			var d = cc.view.getScaleX(),
				e = cc.view.getScaleY();
			c.beginPath();
			for(var f = 0, g = a.length; f < g; f++) c.arc(a[f].x *
				d, -a[f].y * e, b * d, 0, 2 * Math.PI, !1);
			c.closePath();
			c.fill()
		}
	},
	drawLine: function(a, c) {
		var b = this._renderContext.getContext(),
			d = cc.view.getScaleX(),
			e = cc.view.getScaleY();
		b.beginPath();
		b.moveTo(a.x * d, -a.y * e);
		b.lineTo(c.x * d, -c.y * e);
		b.closePath();
		b.stroke()
	},
	drawRect: function(a, c) {
		this.drawLine(cc.p(a.x, a.y), cc.p(c.x, a.y));
		this.drawLine(cc.p(c.x, a.y), cc.p(c.x, c.y));
		this.drawLine(cc.p(c.x, c.y), cc.p(a.x, c.y));
		this.drawLine(cc.p(a.x, c.y), cc.p(a.x, a.y))
	},
	drawSolidRect: function(a, c, b) {
		a = [a, cc.p(c.x, a.y), c, cc.p(a.x,
			c.y)];
		this.drawSolidPoly(a, 4, b)
	},
	drawPoly: function(a, c, b, d) {
		d = d || !1;
		if(null != a) {
			if(3 > a.length) throw Error("Polygon's point must greater than 2");
			var e = a[0];
			c = this._renderContext.getContext();
			var f = cc.view.getScaleX(),
				g = cc.view.getScaleY();
			c.beginPath();
			c.moveTo(e.x * f, -e.y * g);
			for(var e = 1, h = a.length; e < h; e++) c.lineTo(a[e].x * f, -a[e].y * g);
			b && c.closePath();
			d ? c.fill() : c.stroke()
		}
	},
	drawSolidPoly: function(a, c, b) {
		this.setDrawColor(b.r, b.g, b.b, b.a);
		this.drawPoly(a, c, !0, !0)
	},
	drawCircle: function(a, c, b, d, e) {
		e =
			e || !1;
		d = this._renderContext.getContext();
		var f = cc.view.getScaleX(),
			g = cc.view.getScaleY();
		d.beginPath();
		d.arc(0 | a.x * f, 0 | -(a.y * g), c * f, -b, -(b - 2 * Math.PI), !1);
		e && d.lineTo(0 | a.x * f, 0 | -(a.y * g));
		d.stroke()
	},
	drawQuadBezier: function(a, c, b, d) {
		for(var e = this._cacheArray, f = e.length = 0, g = 0; g < d; g++) {
			var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * c.x + f * f * b.x,
				k = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * c.y + f * f * b.y;
			e.push(cc.p(h, k));
			f += 1 / d
		}
		e.push(cc.p(b.x, b.y));
		this.drawPoly(e, d + 1, !1, !1)
	},
	drawCubicBezier: function(a, c, b, d, e) {
		for(var f = this._cacheArray,
				g = f.length = 0, h = 0; h < e; h++) {
			var k = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * c.x + 3 * (1 - g) * g * g * b.x + g * g * g * d.x,
				m = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * c.y + 3 * (1 - g) * g * g * b.y + g * g * g * d.y;
			f.push(cc.p(k, m));
			g += 1 / e
		}
		f.push(cc.p(d.x, d.y));
		this.drawPoly(f, e + 1, !1, !1)
	},
	drawCatmullRom: function(a, c) {
		this.drawCardinalSpline(a, 0.5, c)
	},
	drawCardinalSpline: function(a, c, b) {
		cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
		var d = this._cacheArray;
		d.length = 0;
		for(var e, f, g = 1 / a.length, h = 0; h < b + 1; h++) f = h / b, 1 === f ? (e = a.length - 1,
			f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), c, f), d.push(e);
		this.drawPoly(d, b + 1, !1, !1)
	},
	drawImage: function(a, c, b, d, e) {
		var f = arguments.length,
			g = this._renderContext.getContext();
		switch(f) {
			case 2:
				g.drawImage(a, c.x, -(c.y + a.height));
				break;
			case 3:
				g.drawImage(a, c.x, -(c.y + b.height), b.width, b.height);
				break;
			case 5:
				g.drawImage(a, c.x, c.y, b.width, b.height, d.x, -(d.y + e.height), e.width, e.height);
				break;
			default:
				throw Error("Argument must be non-nil");
		}
	},
	drawStar: function(a, c, b) {
		a = a || this._renderContext;
		var d = a.getContext();
		c *= cc.view.getScaleX();
		b = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b);
		a.setFillStyle(b + ",1)");
		var e = c / 10;
		d.beginPath();
		d.moveTo(-c, c);
		d.lineTo(0, e);
		d.lineTo(c, c);
		d.lineTo(e, 0);
		d.lineTo(c, -c);
		d.lineTo(0, -e);
		d.lineTo(-c, -c);
		d.lineTo(-e, 0);
		d.lineTo(-c, c);
		d.closePath();
		d.fill();
		var f = d.createRadialGradient(0, 0, e, 0, 0, c);
		f.addColorStop(0, b + ", 1)");
		f.addColorStop(0.3, b + ", 0.8)");
		f.addColorStop(1,
			b + ", 0.0)");
		a.setFillStyle(f);
		d.beginPath();
		d.arc(0, 0, c - e, 0, cc.PI2, !1);
		d.closePath();
		d.fill()
	},
	drawColorBall: function(a, c, b) {
		a = a || this._renderContext;
		var d = a.getContext();
		c *= cc.view.getScaleX();
		b = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b);
		var e = d.createRadialGradient(0, 0, c / 10, 0, 0, c);
		e.addColorStop(0, b + ", 1)");
		e.addColorStop(0.3, b + ", 0.8)");
		e.addColorStop(0.6, b + ", 0.4)");
		e.addColorStop(1, b + ", 0.0)");
		a.setFillStyle(e);
		d.beginPath();
		d.arc(0, 0, c, 0, cc.PI2, !1);
		d.closePath();
		d.fill()
	},
	fillText: function(a, c,
		b) {
		this._renderContext.getContext().fillText(a, c, -b)
	},
	setDrawColor: function(a, c, b, d) {
		this._renderContext.setFillStyle("rgba(" + a + "," + c + "," + b + "," + d / 255 + ")");
		this._renderContext.setStrokeStyle("rgba(" + a + "," + c + "," + b + "," + d / 255 + ")")
	},
	setPointSize: function(a) {},
	setLineWidth: function(a) {
		this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
	}
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
	_renderContext: null,
	_initialized: !1,
	_shader: null,
	_colorLocation: -1,
	_colorArray: null,
	_pointSizeLocation: -1,
	_pointSize: -1,
	ctor: function(a) {
		null == a && (a = cc._renderContext);
		if(!a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
		this._renderContext = a;
		this._colorArray = new Float32Array([1, 1, 1, 1])
	},
	lazy_init: function() {
		this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
			this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
	},
	drawInit: function() {
		this._initialized = !1
	},
	drawPoint: function(a) {
		this.lazy_init();
		var c = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		c.uniform4fv(this._colorLocation,
			this._colorArray);
		this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
		var b = c.createBuffer();
		c.bindBuffer(c.ARRAY_BUFFER, b);
		c.bufferData(c.ARRAY_BUFFER, new Float32Array([a.x, a.y]), c.STATIC_DRAW);
		c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
		c.drawArrays(c.POINTS, 0, 1);
		c.deleteBuffer(b);
		cc.incrementGLDraws(1)
	},
	drawPoints: function(a, c) {
		if(a && 0 !== a.length) {
			this.lazy_init();
			var b = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			b.uniform4fv(this._colorLocation, this._colorArray);
			this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
			var d = b.createBuffer();
			b.bindBuffer(b.ARRAY_BUFFER, d);
			b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
			b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
			b.drawArrays(b.POINTS, 0, a.length);
			b.deleteBuffer(d);
			cc.incrementGLDraws(1)
		}
	},
	_pointsToTypeArray: function(a) {
		for(var c = new Float32Array(2 *
				a.length), b = 0; b < a.length; b++) c[2 * b] = a[b].x, c[2 * b + 1] = a[b].y;
		return c
	},
	drawLine: function(a, c) {
		this.lazy_init();
		var b = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		b.uniform4fv(this._colorLocation, this._colorArray);
		var d = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, d);
		b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray([a, c]), b.STATIC_DRAW);
		b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
			2, b.FLOAT, !1, 0, 0);
		b.drawArrays(b.LINES, 0, 2);
		b.deleteBuffer(d);
		cc.incrementGLDraws(1)
	},
	drawRect: function(a, c) {
		this.drawLine(cc.p(a.x, a.y), cc.p(c.x, a.y));
		this.drawLine(cc.p(c.x, a.y), cc.p(c.x, c.y));
		this.drawLine(cc.p(c.x, c.y), cc.p(a.x, c.y));
		this.drawLine(cc.p(a.x, c.y), cc.p(a.x, a.y))
	},
	drawSolidRect: function(a, c, b) {
		a = [a, cc.p(c.x, a.y), c, cc.p(a.x, c.y)];
		this.drawSolidPoly(a, 4, b)
	},
	drawPoly: function(a, c, b) {
		this.lazy_init();
		c = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		c.uniform4fv(this._colorLocation, this._colorArray);
		var d = c.createBuffer();
		c.bindBuffer(c.ARRAY_BUFFER, d);
		c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
		c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
		b ? c.drawArrays(c.LINE_LOOP, 0, a.length) : c.drawArrays(c.LINE_STRIP, 0, a.length);
		c.deleteBuffer(d);
		cc.incrementGLDraws(1)
	},
	drawSolidPoly: function(a, c, b) {
		this.lazy_init();
		b && this.setDrawColor(b.r, b.g, b.b, b.a);
		c = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		c.uniform4fv(this._colorLocation, this._colorArray);
		b = c.createBuffer();
		c.bindBuffer(c.ARRAY_BUFFER, b);
		c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
		c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
		c.drawArrays(c.TRIANGLE_FAN, 0, a.length);
		c.deleteBuffer(b);
		cc.incrementGLDraws(1)
	},
	drawCircle: function(a,
		c, b, d, e) {
		this.lazy_init();
		var f = 1;
		e && f++;
		var g = 2 * Math.PI / d;
		if(e = new Float32Array(2 * (d + 2))) {
			for(var h = 0; h <= d; h++) {
				var k = h * g,
					m = c * Math.cos(k + b) + a.x,
					k = c * Math.sin(k + b) + a.y;
				e[2 * h] = m;
				e[2 * h + 1] = k
			}
			e[2 * (d + 1)] = a.x;
			e[2 * (d + 1) + 1] = a.y;
			a = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			a.uniform4fv(this._colorLocation, this._colorArray);
			c = a.createBuffer();
			a.bindBuffer(a.ARRAY_BUFFER, c);
			a.bufferData(a.ARRAY_BUFFER,
				e, a.STATIC_DRAW);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
			a.drawArrays(a.LINE_STRIP, 0, d + f);
			a.deleteBuffer(c);
			cc.incrementGLDraws(1)
		}
	},
	drawQuadBezier: function(a, c, b, d) {
		this.lazy_init();
		for(var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; g < d; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * c.x + f * f * b.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * c.y + f * f * b.y, f += 1 / d;
		e[2 * d] = b.x;
		e[2 * d + 1] = b.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		c = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, c);
		a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, d + 1);
		a.deleteBuffer(c);
		cc.incrementGLDraws(1)
	},
	drawCubicBezier: function(a, c, b, d, e) {
		this.lazy_init();
		for(var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * c.x + 3 * (1 - g) * g * g * b.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 -
			g, 2) * g * c.y + 3 * (1 - g) * g * g * b.y + g * g * g * d.y, g += 1 / e;
		f[2 * e] = d.x;
		f[2 * e + 1] = d.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		c = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, c);
		a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, e + 1);
		a.deleteBuffer(c);
		cc.incrementGLDraws(1)
	},
	drawCatmullRom: function(a, c) {
		this.drawCardinalSpline(a, 0.5, c)
	},
	drawCardinalSpline: function(a, c, b) {
		this.lazy_init();
		for(var d = new Float32Array(2 * (b + 1)), e, f, g = 1 / a.length, h = 0; h < b + 1; h++) f = h / b, 1 === f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.cardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), c, f), d[2 * h] = e.x, d[2 * h + 1] = e.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		c = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, c);
		a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, b + 1);
		a.deleteBuffer(c);
		cc.incrementGLDraws(1)
	},
	setDrawColor: function(a, c, b, d) {
		this._colorArray[0] = a / 255;
		this._colorArray[1] = c / 255;
		this._colorArray[2] = b / 255;
		this._colorArray[3] = d / 255
	},
	setPointSize: function(a) {
		this._pointSize =
			a * cc.contentScaleFactor()
	},
	setLineWidth: function(a) {
		this._renderContext.lineWidth && this._renderContext.lineWidth(a)
	}
});
cc._tmp.PrototypeLabelTTF = function() {
	var a = cc.LabelTTF.prototype;
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "string", a.getString, a.setString);
	cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
	cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
	cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
	cc.defineGetterSetter(a,
		"fontName", a.getFontName, a.setFontName);
	cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
	cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
	cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
	cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
	cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
	cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
	cc.defineGetterSetter(a, "shadowOffsetX",
		a._getShadowOffsetX, a._setShadowOffsetX);
	cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
	cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
	cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
	_dimensions: null,
	_hAlignment: cc.TEXT_ALIGNMENT_CENTER,
	_vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
	_fontName: null,
	_fontSize: 0,
	_string: "",
	_originalText: null,
	_shadowEnabled: !1,
	_shadowOffset: null,
	_shadowOpacity: 0,
	_shadowBlur: 0,
	_shadowColor: null,
	_strokeEnabled: !1,
	_strokeColor: null,
	_strokeSize: 0,
	_textFillColor: null,
	_strokeShadowOffsetX: 0,
	_strokeShadowOffsetY: 0,
	_needUpdateTexture: !1,
	_lineWidths: null,
	_className: "LabelTTF",
	_fontStyle: "normal",
	_fontWeight: "normal",
	_lineHeight: "normal",
	initWithString: function(a, c, b, d, e, f) {
		a = a ? a + "" : "";
		b = b || 16;
		d = d || cc.size(0, 0);
		e = e || cc.TEXT_ALIGNMENT_LEFT;
		f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._dimensions = cc.size(d.width, d.height);
		this._fontName = c || "Arial";
		this._hAlignment = e;
		this._vAlignment = f;
		this._fontSize = b;
		this._renderCmd._setFontStyle(this._fontName, b, this._fontStyle, this._fontWeight);
		this.string = a;
		this._renderCmd._setColorsString();
		this._renderCmd._updateTexture();
		this._setUpdateTextureDirty();
		return !0
	},
	_setUpdateTextureDirty: function() {
		this._needUpdateTexture = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
	},
	ctor: function(a, c, b, d, e, f) {
		cc.Sprite.prototype.ctor.call(this);
		this._dimensions = cc.size(0, 0);
		this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
		this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._fontName = "Arial";
		this._shadowEnabled = !1;
		this._shadowOffset = cc.p(0, 0);
		this._shadowBlur = this._shadowOpacity = 0;
		this._strokeEnabled = !1;
		this._strokeColor = cc.color(255, 255, 255, 255);
		this._strokeSize = 0;
		this._textFillColor = cc.color(255,
			255, 255, 255);
		this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
		this._needUpdateTexture = !1;
		this._lineWidths = [];
		this._renderCmd._setColorsString();
		this._textureLoaded = !0;
		c && c instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, c) : cc.LabelTTF.prototype.initWithString.call(this, a, c, b, d, e, f)
	},
	init: function() {
		return this.initWithString(" ", this._fontName, this._fontSize)
	},
	description: function() {
		return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) +
			"\x3e"
	},
	getLineHeight: function() {
		return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
	},
	setLineHeight: function(a) {
		this._lineHeight = a
	},
	getString: function() {
		return this._string
	},
	getHorizontalAlignment: function() {
		return this._hAlignment
	},
	getVerticalAlignment: function() {
		return this._vAlignment
	},
	getDimensions: function() {
		return cc.size(this._dimensions)
	},
	getFontSize: function() {
		return this._fontSize
	},
	getFontName: function() {
		return this._fontName
	},
	initWithStringAndTextDefinition: function(a, c) {
		this._updateWithTextDefinition(c, !1);
		this.string = a;
		return !0
	},
	setTextDefinition: function(a) {
		a && this._updateWithTextDefinition(a, !0)
	},
	getTextDefinition: function() {
		return this._prepareTextDefinition(!1)
	},
	enableShadow: function(a, c, b, d) {
		null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, c, b) : this._enableShadowNoneColor(a, c, b, d)
	},
	_enableShadowNoneColor: function(a, c, b, d) {
		b = b || 0.5;
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		var e = this._shadowOffset;
		if(e && e.x !== a || e._y !== c) e.x = a, e.y = c;
		this._shadowOpacity !== b && (this._shadowOpacity = b);
		this._renderCmd._setColorsString();
		this._shadowBlur !== d && (this._shadowBlur = d);
		this._setUpdateTextureDirty()
	},
	_enableShadow: function(a, c, b) {
		this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
		this._shadowColor.r = a.r;
		this._shadowColor.g = a.g;
		this._shadowColor.b = a.b;
		this._enableShadowNoneColor(c.width || c.x || 0, c.height || c.y || 0, null != a.a ? a.a / 255 : 0.5, b)
	},
	_getShadowOffsetX: function() {
		return this._shadowOffset.x
	},
	_setShadowOffsetX: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset.x !== a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
	},
	_getShadowOffsetY: function() {
		return this._shadowOffset._y
	},
	_setShadowOffsetY: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset._y !== a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
	},
	_getShadowOffset: function() {
		return cc.p(this._shadowOffset.x, this._shadowOffset.y)
	},
	_setShadowOffset: function(a) {
		!1 ===
			this._shadowEnabled && (this._shadowEnabled = !0);
		if(this._shadowOffset.x !== a.x || this._shadowOffset.y !== a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
	},
	_getShadowOpacity: function() {
		return this._shadowOpacity
	},
	_setShadowOpacity: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOpacity !== a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
	},
	_getShadowBlur: function() {
		return this._shadowBlur
	},
	_setShadowBlur: function(a) {
		!1 ===
			this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowBlur !== a && (this._shadowBlur = a, this._setUpdateTextureDirty())
	},
	disableShadow: function() {
		this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
	},
	enableStroke: function(a, c) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var b = this._strokeColor;
		if(b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString();
		this._strokeSize !== c && (this._strokeSize = c || 0);
		this._setUpdateTextureDirty()
	},
	_getStrokeStyle: function() {
		return this._strokeColor
	},
	_setStrokeStyle: function(a) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var c = this._strokeColor;
		if(c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
	},
	_getLineWidth: function() {
		return this._strokeSize
	},
	_setLineWidth: function(a) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
	},
	disableStroke: function() {
		this._strokeEnabled && (this._strokeEnabled = !1,
			this._setUpdateTextureDirty())
	},
	setFontFillColor: function(a) {
		var c = this._textFillColor;
		if(c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
	},
	_getFillStyle: function() {
		return this._textFillColor
	},
	_updateWithTextDefinition: function(a, c) {
		a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
		this._hAlignment = a.textAlign;
		this._vAlignment = a.verticalAlign;
		this._fontName = a.fontName;
		this._fontSize = a.fontSize || 12;
		this._lineHeight = a.lineHeight ? a.lineHeight : this._fontSize;
		this._renderCmd._setFontStyle(a);
		a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
		a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
		this.setFontFillColor(a.fillStyle);
		c && this._renderCmd._updateTexture();
		var b = cc.Node._dirtyFlags;
		this._renderCmd.setDirtyFlag(b.colorDirty | b.opacityDirty | b.textDirty)
	},
	_prepareTextDefinition: function(a) {
		var c =
			new cc.FontDefinition;
		a ? (c.fontSize = this._fontSize, c.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, c.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (c.fontSize = this._fontSize, c.boundingWidth = this._dimensions.width, c.boundingHeight = this._dimensions.height);
		c.fontName = this._fontName;
		c.textAlign = this._hAlignment;
		c.verticalAlign = this._vAlignment;
		if(this._strokeEnabled) {
			c.strokeEnabled = !0;
			var b = this._strokeColor;
			c.strokeStyle = cc.color(b.r, b.g, b.b);
			c.lineWidth = this._strokeSize
		} else c.strokeEnabled = !1;
		this._shadowEnabled ? (c.shadowEnabled = !0, c.shadowBlur = this._shadowBlur, c.shadowOpacity = this._shadowOpacity, c.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, c.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : c._shadowEnabled = !1;
		a = this._textFillColor;
		c.fillStyle = cc.color(a.r, a.g, a.b);
		return c
	},
	setString: function(a) {
		a = String(a);
		this._originalText !== a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	_updateString: function() {
		this._string && "" !== this._string || this._string === this._originalText || (cc.renderer.childrenOrderDirty = !0);
		this._string = this._originalText
	},
	setHorizontalAlignment: function(a) {
		a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
	},
	setVerticalAlignment: function(a) {
		a !== this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
	},
	setDimensions: function(a, c) {
		var b;
		void 0 === c ? (b = a.width, c = a.height) : b = a;
		if(b !== this._dimensions.width || c !== this._dimensions.height) this._dimensions.width =
			b, this._dimensions.height = c, this._updateString(), this._setUpdateTextureDirty()
	},
	_getBoundingWidth: function() {
		return this._dimensions.width
	},
	_setBoundingWidth: function(a) {
		a !== this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
	},
	_getBoundingHeight: function() {
		return this._dimensions.height
	},
	_setBoundingHeight: function(a) {
		a !== this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._setUpdateTextureDirty())
	},
	setFontSize: function(a) {
		this._fontSize !==
			a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	setFontName: function(a) {
		this._fontName && this._fontName !== a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFont: function() {
		return this._renderCmd._getFontStyle()
	},
	_setFont: function(a) {
		if(a = cc.LabelTTF._fontStyleRE.exec(a)) this._fontSize = parseInt(a[1]), this._fontName =
			a[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty()
	},
	getContentSize: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype.getContentSize.call(this)
	},
	_getWidth: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getWidth.call(this)
	},
	_getHeight: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getHeight.call(this)
	},
	setTextureRect: function(a, c, b) {
		cc.Sprite.prototype.setTextureRect.call(this, a, c, b, !1)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LabelTTF.CanvasRenderCmd(this) : new cc.LabelTTF.WebGLRenderCmd(this)
	},
	_setFontStyle: function(a) {
		this._fontStyle !== a && (this._fontStyle = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFontStyle: function() {
		return this._fontStyle
	},
	_setFontWeight: function(a) {
		this._fontWeight !==
			a && (this._fontWeight = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFontWeight: function() {
		return this._fontWeight
	}
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, c, b, d, e, f) {
	return new cc.LabelTTF(a, c, b, d, e, f)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
	this.removeEventListener("load", arguments.callee, !1);
	document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, c) {
	if(a instanceof cc.FontDefinition) {
		var b = cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()];
		if(0 < b) return b;
		var d = cc.LabelTTF.__labelHeightDiv;
		d.innerHTML = "ajghl~!";
		d.style.fontFamily = a.fontName;
		d.style.fontSize = a.fontSize + "px";
		d.style.fontStyle = a.fontStyle;
		d.style.fontWeight = a.fontWeight;
		b = d.clientHeight;
		cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()] = b;
		d.innerHTML = "";
		return b
	}
	b = cc.LabelTTF.__fontHeightCache[a + "." + c];
	if(0 < b) return b;
	d = cc.LabelTTF.__labelHeightDiv;
	d.innerHTML = "ajghl~!";
	d.style.fontFamily = a;
	d.style.fontSize = c + "px";
	b = d.clientHeight;
	cc.LabelTTF.__fontHeightCache[a + "." + c] = b;
	d.innerHTML = "";
	return b
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
(function() {
	cc.LabelTTF.RenderCmd = function() {
		this._fontClientHeight = 18;
		this._fontStyleStr = "";
		this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
		this._strokeColorStr = "";
		this._fillColorStr = "rgba(255,255,255,1)";
		this._labelContext = this._labelCanvas = null;
		this._lineWidths = [];
		this._strings = [];
		this._isMultiLine = !1
	};
	var a = cc.LabelTTF.RenderCmd.prototype;
	a.constructor = cc.LabelTTF.RenderCmd;
	a._getLabelContext = function() {
		if(this._labelContext) return this._labelContext;
		var a = this._node;
		if(!this._labelCanvas) {
			var b =
				cc.newElement("canvas");
			b.width = 1;
			b.height = 1;
			var d = new cc.Texture2D;
			d.initWithElement(b);
			a.setTexture(d);
			this._labelCanvas = b
		}
		return this._labelContext = this._labelCanvas.getContext("2d")
	};
	a._setFontStyle = function(a, b, d, e) {
		a instanceof cc.FontDefinition ? (this._fontStyleStr = a._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a)) : (this._fontStyleStr = d + " " + e + " " + b + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, b))
	};
	a._getFontStyle = function() {
		return this._fontStyleStr
	};
	a._getFontClientHeight = function() {
		return this._fontClientHeight
	};
	a._updateTexture = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
		var a = this._node,
			b = this._getLabelContext(),
			d = this._labelCanvas,
			e = a._contentSize;
		if(0 === a._string.length) return d.width = 1, d.height = e.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, e.height)), !0;
		b.font = this._fontStyleStr;
		this._updateTTF();
		var f = e.width,
			e = e.height,
			g = d.width === f && d.height === e;
		d.width = f;
		d.height =
			e;
		g && b.clearRect(0, 0, f, e);
		this._drawTTFInCanvas(b);
		a._texture && a._texture.handleLoadedTexture();
		a.setTextureRect(cc.rect(0, 0, f, e));
		return !0
	};
	a._measureConfig = function() {
		this._getLabelContext().font = this._fontStyleStr
	};
	a._measure = function(a) {
		return this._getLabelContext().measureText(a).width
	};
	a._updateTTF = function() {
		var a = this._node,
			b = a._dimensions.width,
			d, e, f = this._lineWidths;
		f.length = 0;
		this._isMultiLine = !1;
		this._measureConfig();
		if(0 !== b)
			for(this._strings = a._string.split("\n"), d = 0; d < this._strings.length; d++) this._checkWarp(this._strings,
				d, b);
		else
			for(this._strings = a._string.split("\n"), d = 0, e = this._strings.length; d < e; d++) f.push(this._measure(this._strings[d]));
		1 < this._strings.length && (this._isMultiLine = !0);
		e = d = 0;
		a._strokeEnabled && (d = e = 2 * a._strokeSize);
		if(a._shadowEnabled) {
			var g = a._shadowOffset;
			d += 2 * Math.abs(g.x);
			e += 2 * Math.abs(g.y)
		}
		b = 0 === b ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, f) + d), Math.ceil(this._fontClientHeight * this._strings.length + e)) : cc.size(Math.ceil(this._measure(a._string) + d), Math.ceil(this._fontClientHeight +
			e)) : 0 === a._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(b + d), Math.ceil(a.getLineHeight() * this._strings.length + e)) : cc.size(Math.ceil(b + d), Math.ceil(a.getLineHeight() + e)) : cc.size(Math.ceil(b + d), Math.ceil(a._dimensions.height + e));
		"normal" !== a._getFontStyle() && (b.width = Math.ceil(b.width + 0.3 * a._fontSize));
		a.setContentSize(b);
		a._strokeShadowOffsetX = d;
		a._strokeShadowOffsetY = e;
		a = a._anchorPoint;
		this._anchorPointInPoints.x = 0.5 * d + (b.width - d) * a.x;
		this._anchorPointInPoints.y = 0.5 * e + (b.height - e) * a.y
	};
	a._drawTTFInCanvas =
		function(a) {
			if(a) {
				var b = this._node,
					d = b._strokeShadowOffsetX,
					e = b._strokeShadowOffsetY,
					f = b._contentSize.height - e,
					g = b._vAlignment,
					h = b._hAlignment,
					k = b._strokeSize;
				a.setTransform(1, 0, 0, 1, 0.5 * d, f + 0.5 * e);
				a.font !== this._fontStyleStr && (a.font = this._fontStyleStr);
				a.fillStyle = this._fillColorStr;
				var m = e = 0,
					n = b._strokeEnabled;
				n && (a.lineWidth = 2 * k, a.strokeStyle = this._strokeColorStr);
				b._shadowEnabled && (k = b._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = k.x, a.shadowOffsetY = -k.y, a.shadowBlur = b._shadowBlur);
				a.textBaseline = cc.LabelTTF._textBaseline[g];
				a.textAlign = cc.LabelTTF._textAlign[h];
				var p = b._contentSize.width - d,
					d = b.getLineHeight(),
					k = (d - this._fontClientHeight) / 2,
					e = h === cc.TEXT_ALIGNMENT_RIGHT ? e + p : h === cc.TEXT_ALIGNMENT_CENTER ? e + p / 2 : e + 0;
				if(this._isMultiLine)
					for(b = this._strings.length, g === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? m = d - 2 * k + f - d * b : g === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (m = (d - 2 * k) / 2 + (f - d * b) / 2), g = 0; g < b; g++) h = this._strings[g], p = -f + (d * g + k) + m, n && a.strokeText(h, e, p), a.fillText(h, e, p);
				else g !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM &&
					(m = g === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? m - f : m - 0.5 * f), n && a.strokeText(b._string, e, m), a.fillText(b._string, e, m)
			}
		};
	a._checkWarp = function(a, b, d) {
		var e = a[b],
			f = this._measure(e);
		if(f > d && 1 < e.length) {
			for(var g = d / f * e.length | 0, h = e.substr(g), k = f - this._measure(h), m, n = 0, p = 0; k > d && 100 > p++;) g *= d / k, g |= 0, h = e.substr(g), k = f - this._measure(h);
			for(p = 0; k < d && 100 > p++;) h && (n = (m = cc.LabelTTF._wordRex.exec(h)) ? m[0].length : 1, m = h), g += n, h = e.substr(g), k = f - this._measure(h);
			g -= n;
			0 === g && (g = 1, m = m.substr(1));
			d = e.substr(0, g);
			cc.LabelTTF.wrapInspection &&
				cc.LabelTTF._symbolRex.test(m || h) && (f = cc.LabelTTF._lastWordRex.exec(d), g -= f ? f[0].length : 0, m = e.substr(g), d = e.substr(0, g));
			cc.LabelTTF._firsrEnglish.test(m) && (f = cc.LabelTTF._lastEnglish.exec(d)) && d !== f[0] && (g -= f[0].length, m = e.substr(g), d = e.substr(0, g));
			a[b] = m || h;
			a.splice(b, 0, d)
		}
	}
})();
(function() {
	cc.LabelTTF.CanvasRenderCmd = function(a) {
		cc.Sprite.CanvasRenderCmd.call(this, a);
		cc.LabelTTF.RenderCmd.call(this)
	};
	cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
	var a = cc.LabelTTF.CanvasRenderCmd.prototype;
	a.constructor = cc.LabelTTF.CanvasRenderCmd;
	a.updateStatus = function() {
		var a = cc.Node._dirtyFlags,
			b = this._dirtyFlag,
			d = b & a.colorDirty,
			e = b & a.opacityDirty;
		d && this._updateDisplayColor();
		e && this._updateDisplayOpacity();
		d ? this._updateColor() : b & a.textDirty && this._updateTexture();
		this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	};
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag & b.transformDirty &&
			(d |= b.transformDirty);
		var e = d & b.colorDirty,
			f = d & b.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e ? this._updateColor() : d & b.textDirty && this._updateTexture();
		d & b.transformDirty && this.transform(a)
	};
	a._setColorsString = function() {
		var a = this._displayedColor,
			b = this._node,
			d = b._shadowColor || this._displayedColor,
			e = b._strokeColor,
			f = b._textFillColor,
			g = a.r / 255,
			h = a.g / 255,
			a = a.b / 255;
		this._shadowColorStr = "rgba(" + (0 | g * d.r) + "," + (0 | h * d.g) + "," + (0 | a * d.b) + "," + b._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | g * f.r) + "," + (0 | h * f.g) + "," + (0 | a * f.b) + ", 1)";
		this._strokeColorStr = "rgba(" + (0 | g * e.r) + "," + (0 | h * e.g) + "," + (0 | a * e.b) + ", 1)"
	};
	a._updateColor = function() {
		this._setColorsString();
		this._updateTexture()
	}
})();
(function() {
	cc.LabelTTF.WebGLRenderCmd = function(a) {
		cc.Sprite.WebGLRenderCmd.call(this, a);
		cc.LabelTTF.RenderCmd.call(this);
		this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
	};
	var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, a);
	a.constructor = cc.LabelTTF.WebGLRenderCmd;
	a._setColorsString = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
		var a = this._node,
			b = a._strokeColor,
			d = a._textFillColor,
			e = a._shadowColor || this._displayedColor;
		this._shadowColorStr = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + a._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + ", 1)";
		this._strokeColorStr = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ", 1)"
	};
	a.updateStatus = function() {
		var a = cc.Node._dirtyFlags,
			b = this._dirtyFlag,
			d = b & a.colorDirty,
			e = b & a.opacityDirty;
		d && this._updateDisplayColor();
		e && this._updateDisplayOpacity();
		d || e ? (this._setColorsString(), this._updateColor(), this._updateTexture()) :
			b & a.textDirty && this._updateTexture();
		this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	};
	a._syncStatus = function(a) {
		var b = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
		e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
		a && a._dirtyFlag & b.transformDirty && (d |= b.transformDirty);
		var e = d & b.colorDirty,
			f = d & b.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e || f ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : d & b.textDirty && this._updateTexture();
		this.transform(a)
	}
})();
cc.HashElement = cc.Class.extend({
	actions: null,
	target: null,
	actionIndex: 0,
	currentAction: null,
	currentActionSalvaged: !1,
	paused: !1,
	hh: null,
	ctor: function() {
		this.actions = [];
		this.target = null;
		this.actionIndex = 0;
		this.currentAction = null;
		this.paused = this.currentActionSalvaged = !1;
		this.hh = null
	}
});
cc.ActionManager = cc.Class.extend({
	_hashTargets: null,
	_arrayTargets: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_searchElementByTarget: function(a, c) {
		for(var b = 0; b < a.length; b++)
			if(c === a[b].target) return a[b];
		return null
	},
	ctor: function() {
		this._hashTargets = {};
		this._arrayTargets = [];
		this._currentTarget = null;
		this._currentTargetSalvaged = !1
	},
	addAction: function(a, c, b) {
		if(!a) throw "cc.ActionManager.addAction(): action must be non-null";
		if(!c) throw "cc.ActionManager.addAction(): action must be non-null";
		var d = this._hashTargets[c.__instanceId];
		d || (d = new cc.HashElement, d.paused = b, d.target = c, this._hashTargets[c.__instanceId] = d, this._arrayTargets.push(d));
		this._actionAllocWithHashElement(d);
		d.actions.push(a);
		a.startWithTarget(c)
	},
	removeAllActions: function() {
		for(var a = this._arrayTargets, c = 0; c < a.length; c++) {
			var b = a[c];
			b && this.removeAllActionsFromTarget(b.target, !0)
		}
	},
	removeAllActionsFromTarget: function(a, c) {
		if(null != a) {
			var b = this._hashTargets[a.__instanceId];
			b && (-1 === b.actions.indexOf(b.currentAction) ||
				b.currentActionSalvaged || (b.currentActionSalvaged = !0), b.actions.length = 0, this._currentTarget !== b || c ? this._deleteHashElement(b) : this._currentTargetSalvaged = !0)
		}
	},
	removeAction: function(a) {
		if(null != a) {
			var c = a.getOriginalTarget();
			if(c = this._hashTargets[c.__instanceId])
				for(var b = 0; b < c.actions.length; b++) {
					if(c.actions[b] === a) {
						c.actions.splice(b, 1);
						break
					}
				} else cc.log(cc._LogInfos.ActionManager_removeAction)
		}
	},
	removeActionByTag: function(a, c) {
		a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
		cc.assert(c, cc._LogInfos.ActionManager_addAction);
		var b = this._hashTargets[c.__instanceId];
		if(b)
			for(var d = b.actions.length, e = 0; e < d; ++e) {
				var f = b.actions[e];
				if(f && f.getTag() === a && f.getOriginalTarget() === c) {
					this._removeActionAtIndex(e, b);
					break
				}
			}
	},
	getActionByTag: function(a, c) {
		a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
		var b = this._hashTargets[c.__instanceId];
		if(b) {
			if(null != b.actions)
				for(var d = 0; d < b.actions.length; ++d) {
					var e = b.actions[d];
					if(e && e.getTag() === a) return e
				}
			cc.log(cc._LogInfos.ActionManager_getActionByTag_2,
				a)
		}
		return null
	},
	numberOfRunningActionsInTarget: function(a) {
		return(a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
	},
	pauseTarget: function(a) {
		if(a = this._hashTargets[a.__instanceId]) a.paused = !0
	},
	resumeTarget: function(a) {
		if(a = this._hashTargets[a.__instanceId]) a.paused = !1
	},
	pauseAllRunningActions: function() {
		for(var a = [], c = this._arrayTargets, b = 0; b < c.length; b++) {
			var d = c[b];
			d && !d.paused && (d.paused = !0, a.push(d.target))
		}
		return a
	},
	resumeTargets: function(a) {
		if(a)
			for(var c = 0; c < a.length; c++) a[c] &&
				this.resumeTarget(a[c])
	},
	purgeSharedManager: function() {
		cc.director.getScheduler().unscheduleUpdate(this)
	},
	_removeActionAtIndex: function(a, c) {
		c.actions[a] !== c.currentAction || c.currentActionSalvaged || (c.currentActionSalvaged = !0);
		c.actions.splice(a, 1);
		c.actionIndex >= a && c.actionIndex--;
		0 === c.actions.length && (this._currentTarget === c ? this._currentTargetSalvaged = !0 : this._deleteHashElement(c))
	},
	_deleteHashElement: function(a) {
		var c = !1;
		a && (this._hashTargets[a.target.__instanceId] && (delete this._hashTargets[a.target.__instanceId],
			cc.arrayRemoveObject(this._arrayTargets, a), c = !0), a.actions = null, a.target = null);
		return c
	},
	_actionAllocWithHashElement: function(a) {
		null == a.actions && (a.actions = [])
	},
	update: function(a) {
		for(var c = this._arrayTargets, b, d = 0; d < c.length; d++) {
			b = this._currentTarget = c[d];
			if(!b.paused)
				for(b.actionIndex = 0; b.actionIndex < (b.actions ? b.actions.length : 0); b.actionIndex++)
					if(b.currentAction = b.actions[b.actionIndex], b.currentAction) {
						b.currentActionSalvaged = !1;
						b.currentAction.step(a * (b.currentAction._speedMethod ? b.currentAction._speed :
							1));
						if(b.currentActionSalvaged) b.currentAction = null;
						else if(b.currentAction.isDone()) {
							b.currentAction.stop();
							var e = b.currentAction;
							b.currentAction = null;
							this.removeAction(e)
						}
						b.currentAction = null
					}
			this._currentTargetSalvaged && 0 === b.actions.length && this._deleteHashElement(b) && d--
		}
	}
});
(function() {
	var a = cc.sys,
		c = {
			common: {
				multichannel: !0,
				webAudio: cc.sys._supportWebAudio,
				auto: !0
			}
		};
	c[a.BROWSER_TYPE_IE] = {
		multichannel: !0,
		webAudio: cc.sys._supportWebAudio,
		auto: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_ANDROID] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1
	};
	c[a.BROWSER_TYPE_CHROME] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1
	};
	c[a.BROWSER_TYPE_FIREFOX] = {
		multichannel: !0,
		webAudio: !0,
		auto: !0,
		delay: !0
	};
	c[a.BROWSER_TYPE_UC] = {
		multichannel: !0,
		webAudio: !1,
		auto: !1
	};
	c[a.BROWSER_TYPE_QQ] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	c[a.BROWSER_TYPE_OUPENG] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_WECHAT] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_360] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	c[a.BROWSER_TYPE_MIUI] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	c[a.BROWSER_TYPE_LIEBAO] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_SOUGOU] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_BAIDU] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_BAIDU_APP] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	c[a.BROWSER_TYPE_SAFARI] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1,
		webAudioCallback: function(a) {
			document.createElement("audio").src = a
		}
	};
	var b, d;
	try {
		var e = navigator.userAgent.toLowerCase();
		switch(a.browserType) {
			case a.BROWSER_TYPE_IE:
				d = e.match(/(msie |rv:)([\d.]+)/);
				break;
			case a.BROWSER_TYPE_FIREFOX:
				d = e.match(/(firefox\/|rv:)([\d.]+)/);
				break;
			case a.BROWSER_TYPE_CHROME:
				d = e.match(/chrome\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_BAIDU:
				d = e.match(/baidubrowser\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_UC:
				d = e.match(/ucbrowser\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_QQ:
				d = e.match(/qqbrowser\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_OUPENG:
				d = e.match(/oupeng\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_WECHAT:
				d = e.match(/micromessenger\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_SAFARI:
				d = e.match(/safari\/([\d.]+)/);
				break;
			case a.BROWSER_TYPE_MIUI:
				d = e.match(/miuibrowser\/([\d.]+)/)
		}
		b = d ? d[1] : ""
	} catch(f) {
		console.log(f)
	}
	if(cc.sys.isMobile) cc.__audioSupport =
		cc.sys.os !== cc.sys.OS_IOS ? c[a.browserType] || c.common : c[a.BROWSER_TYPE_SAFARI];
	else switch(a.browserType) {
		case a.BROWSER_TYPE_IE:
			cc.__audioSupport = c[a.BROWSER_TYPE_IE];
			break;
		case a.BROWSER_TYPE_FIREFOX:
			cc.__audioSupport = c[a.BROWSER_TYPE_FIREFOX];
			break;
		default:
			cc.__audioSupport = c.common
	}
	if(b) switch(a.browserType) {
		case a.BROWSER_TYPE_CHROME:
			b = parseInt(b);
			30 > b ? cc.__audioSupport = {
				multichannel: !1,
				webAudio: !0,
				auto: !1
			} : 42 === b && (cc.__audioSupport.manualLoop = !0);
			break;
		case a.BROWSER_TYPE_MIUI:
			cc.sys.isMobile &&
				(b = b.match(/\d+/g), 2 > b[0] || 2 === b[0] && 0 === b[1] && 1 >= b[2]) && (cc.__audioSupport.auto = !1)
	}
})();
cc.Audio = cc.Class.extend({
	volume: 1,
	loop: !1,
	src: null,
	_touch: !1,
	_playing: !1,
	_AUDIO_TYPE: "AUDIO",
	_pause: !1,
	_buffer: null,
	_currentSource: null,
	_startTime: null,
	_currentTime: null,
	_context: null,
	_volume: null,
	_ignoreEnded: !1,
	_manualLoop: !1,
	_element: null,
	ctor: function(a, c, b) {
		a && (this._context = a);
		c && (this._volume = c);
		a && c && (this._AUDIO_TYPE = "WEBAUDIO");
		this.src = b
	},
	_setBufferCallback: null,
	setBuffer: function(a) {
		if(a) {
			var c = this._playing;
			this._AUDIO_TYPE = "WEBAUDIO";
			this._buffer && this._buffer !== a && this.getPlaying() &&
				this.stop();
			this._buffer = a;
			c && this.play();
			this._volume.gain.value = this.volume;
			this._setBufferCallback && this._setBufferCallback(a)
		}
	},
	_setElementCallback: null,
	setElement: function(a) {
		if(a) {
			var c = this._playing;
			this._AUDIO_TYPE = "AUDIO";
			this._element && this._element !== a && this.getPlaying() && this.stop();
			this._element = a;
			c && this.play();
			a.volume = this.volume;
			a.loop = this.loop;
			this._setElementCallback && this._setElementCallback(a)
		}
	},
	play: function(a, c) {
		this._playing = !0;
		this.loop = void 0 === c ? this.loop : c;
		"AUDIO" === this._AUDIO_TYPE ?
			this._playOfAudio(a) : this._playOfWebAudio(a)
	},
	getPlaying: function() {
		if(!this._playing) return this._playing;
		if("AUDIO" === this._AUDIO_TYPE) {
			var a = this._element;
			return !a || this._pause || a.ended ? this._playing = !1 : !0
		}
		return(a = this._currentSource) ? null == a.playbackState ? this._playing : this._currentTime + this._context.currentTime - this._startTime < this._currentSource.buffer.duration : !0
	},
	_playOfWebAudio: function(a) {
		var c = this._currentSource;
		if(this._buffer) {
			if(!this._pause && c)
				if(0 === this._context.currentTime || this._currentTime +
					this._context.currentTime - this._startTime > this._currentSource.buffer.duration) this._stopOfWebAudio();
				else return;
			c = this._context.createBufferSource();
			c.buffer = this._buffer;
			c.connect(this._volume);
			c.loop = this._manualLoop ? !1 : this.loop;
			this._startTime = this._context.currentTime;
			this._currentTime = a || 0;
			if(c.start) c.start(0, a || 0);
			else if(c.noteGrainOn) {
				var b = c.buffer.duration;
				this.loop ? c.noteGrainOn(0, a, b) : c.noteGrainOn(0, a, b - a)
			} else c.noteOn(0);
			this._currentSource = c;
			var d = this;
			c.onended = function() {
				d._manualLoop &&
					d._playing && d.loop ? (d.stop(), d.play()) : d._ignoreEnded ? d._ignoreEnded = !1 : d._pause ? d._playing = !1 : d.stop()
			}
		}
	},
	_playOfAudio: function() {
		var a = this._element;
		a && (a.loop = this.loop, a.play())
	},
	stop: function() {
		this._playing = !1;
		"AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
	},
	_stopOfWebAudio: function() {
		var a = this._currentSource;
		this._ignoreEnded = !0;
		a && (a.stop(0), this._currentSource = null)
	},
	_stopOfAudio: function() {
		var a = this._element;
		a && (a.pause(), a.duration && Infinity !== a.duration && (a.currentTime =
			0))
	},
	pause: function() {
		!1 !== this.getPlaying() && (this._playing = !1, this._pause = !0, "AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio())
	},
	_pauseOfWebAudio: function() {
		this._currentTime += this._context.currentTime - this._startTime;
		var a = this._currentSource;
		a && a.stop(0)
	},
	_pauseOfAudio: function() {
		var a = this._element;
		a && a.pause()
	},
	resume: function() {
		this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(), this._pause = !1, this._playing = !0)
	},
	_resumeOfWebAudio: function() {
		var a =
			this._currentSource;
		a && (this._startTime = this._context.currentTime, this._playOfWebAudio(this._currentTime % a.buffer.duration))
	},
	_resumeOfAudio: function() {
		var a = this._element;
		a && a.play()
	},
	setVolume: function(a) {
		1 < a && (a = 1);
		0 > a && (a = 0);
		this.volume = a;
		"AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = a) : this._volume && (this._volume.gain.value = a)
	},
	getVolume: function() {
		return this.volume
	},
	cloneNode: function() {
		var a, c;
		if("AUDIO" === this._AUDIO_TYPE) {
			a = new cc.Audio;
			var b = document.createElement("audio");
			b.src = this.src;
			a.setElement(b)
		} else b = this._context.createGain(), b.gain.value = 1, b.connect(this._context.destination), a = new cc.Audio(this._context, b, this.src), this._buffer ? a.setBuffer(this._buffer) : (c = this, this._setBufferCallback = function(b) {
			a.setBuffer(b);
			c._setBufferCallback = null
		}), a._manualLoop = this._manualLoop;
		a._AUDIO_TYPE = this._AUDIO_TYPE;
		return a
	}
});
(function(a) {
	var c = a.webAudio,
		b = a.multichannel,
		d = a.auto,
		e = [];
	(function() {
		var a = document.createElement("audio");
		if(a.canPlayType) {
			var c = a.canPlayType('audio/ogg; codecs\x3d"vorbis"');
			c && "" !== c && e.push(".ogg");
			(c = a.canPlayType("audio/mpeg")) && "" !== c && e.push(".mp3");
			(c = a.canPlayType('audio/wav; codecs\x3d"1"')) && "" !== c && e.push(".wav");
			(c = a.canPlayType("audio/mp4")) && "" !== c && e.push(".mp4");
			(a = a.canPlayType("audio/x-m4a")) && "" !== a && e.push(".m4a")
		}
	})();
	try {
		if(c) {
			var f = new(window.AudioContext || window.webkitAudioContext ||
				window.mozAudioContext);
			a.delay && setTimeout(function() {
				f = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
			}, 0)
		}
	} catch(g) {
		c = !1, cc.log("browser don't support webAudio")
	}
	var h = {
		cache: {},
		load: function(b, d, g, k) {
			if(0 === e.length) return k("can not support audio!");
			cc.loader.audioPath && (b = cc.path.join(cc.loader.audioPath, b));
			var q = cc.path.extname(b),
				t = [q];
			for(g = 0; g < e.length; g++) q !== e[g] && t.push(e[g]);
			var r;
			if(h.cache[d]) return k(null, h.cache[d]);
			if(c) try {
				var u = f.createGain();
				u.gain.value =
					1;
				u.connect(f.destination);
				r = new cc.Audio(f, u, b);
				a.manualLoop && (r._manualLoop = !0)
			} catch(v) {
				c = !1, cc.log("browser don't support webAudio"), r = new cc.Audio(null, null, b)
			} else r = new cc.Audio(null, null, b);
			this.loadAudioFromExtList(b, t, r, k);
			h.cache[d] = r
		},
		loadAudioFromExtList: function(b, d, g, k) {
			if(0 === d.length) {
				var q = "can not found the resource of audio! Last match url is : ",
					q = q + b.replace(/\.(.*)?$/, "(");
				e.forEach(function(a) {
					q += a + "|"
				});
				q = q.replace(/\|$/, ")");
				return k(q)
			}
			b = cc.path.changeExtname(b, d.splice(0,
				1));
			if(c) {
				a.webAudioCallback && a.webAudioCallback(b);
				var t = new XMLHttpRequest;
				t.open("GET", b, !0);
				t.responseType = "arraybuffer";
				t.onload = function() {
					f.decodeAudioData(t.response, function(a) {
						g.setBuffer(a);
						k(null, g)
					}, function() {
						h.loadAudioFromExtList(b, d, g, k)
					})
				};
				t.send()
			} else {
				var r = document.createElement("audio"),
					u = !1,
					v = !1,
					w = setTimeout(function() {
						0 === r.readyState ? y() : (v = !0, r.pause(), document.body.removeChild(r), k("audio load timeout : " + b, g))
					}, 1E4),
					x = function() {
						if(!u) {
							r.pause();
							try {
								r.currentTime = 0, r.volume =
									1
							} catch(a) {}
							g.setElement(r);
							r.removeEventListener("canplaythrough", x, !1);
							r.removeEventListener("error", z, !1);
							r.removeEventListener("emptied", y, !1);
							!v && k(null, g);
							u = !0;
							clearTimeout(w)
						}
					},
					z = function() {
						u && (r.pause(), r.removeEventListener("canplaythrough", x, !1), r.removeEventListener("error", z, !1), r.removeEventListener("emptied", y, !1), !v && h.loadAudioFromExtList(b, d, g, k), u = !0, clearTimeout(w))
					},
					y = function() {
						v = !0;
						x();
						k(null, g)
					};
				cc._addEventListener(r, "canplaythrough", x, !1);
				cc._addEventListener(r, "error", z, !1);
				a.emptied && cc._addEventListener(r, "emptied", y, !1);
				r.src = b;
				document.body.appendChild(r);
				r.volume = 0;
				r.play()
			}
		}
	};
	cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], h);
	cc.audioEngine = {
		_currMusic: null,
		_musicVolume: 1,
		willPlayMusic: function() {
			return !1
		},
		playMusic: function(a, c) {
			var b = this._currMusic;
			b && b.src !== a && b.getPlaying() && b.stop();
			b = h.cache[a];
			b || (cc.loader.load(a), b = h.cache[a]);
			b.play(0, c);
			b.setVolume(this._musicVolume);
			this._currMusic = b
		},
		stopMusic: function(a) {
			var c = this._currMusic;
			c && (c.stop(),
				a && cc.loader.release(c.src))
		},
		pauseMusic: function() {
			var a = this._currMusic;
			a && a.pause()
		},
		resumeMusic: function() {
			var a = this._currMusic;
			a && a.resume()
		},
		rewindMusic: function() {
			var a = this._currMusic;
			a && (a.stop(), a.play())
		},
		getMusicVolume: function() {
			return this._musicVolume
		},
		setMusicVolume: function(a) {
			a -= 0;
			isNaN(a) && (a = 1);
			1 < a && (a = 1);
			0 > a && (a = 0);
			this._musicVolume = a;
			var c = this._currMusic;
			c && c.setVolume(a)
		},
		isMusicPlaying: function() {
			var a = this._currMusic;
			return a ? a.getPlaying() : !1
		},
		_audioPool: {},
		_maxAudioInstance: 5,
		_effectVolume: 1,
		playEffect: function(a, d) {
			if(!b) return null;
			var e = this._audioPool[a];
			e || (e = this._audioPool[a] = []);
			var f;
			for(f = 0; f < e.length && e[f].getPlaying(); f++);
			if(e[f]) g = e[f], g.setVolume(this._effectVolume), g.play(0, d);
			else if(!c && f > this._maxAudioInstance) cc.log("Error: %s greater than %d", a, this._maxAudioInstance);
			else {
				var g = h.cache[a];
				g || (cc.loader.load(a), g = h.cache[a]);
				g = g.cloneNode();
				g.setVolume(this._effectVolume);
				g.loop = d || !1;
				g.play();
				e.push(g)
			}
			return g
		},
		setEffectsVolume: function(a) {
			a -= 0;
			isNaN(a) && (a = 1);
			1 < a && (a = 1);
			0 > a && (a = 0);
			this._effectVolume = a;
			var c = this._audioPool,
				b;
			for(b in c) {
				var d = c[b];
				if(Array.isArray(d))
					for(var e = 0; e < d.length; e++) d[e].setVolume(a)
			}
		},
		getEffectsVolume: function() {
			return this._effectVolume
		},
		pauseEffect: function(a) {
			a && a.pause()
		},
		pauseAllEffects: function() {
			var a = this._audioPool,
				c;
			for(c in a)
				for(var b = a[c], d = 0; d < a[c].length; d++) b[d].getPlaying() && b[d].pause()
		},
		resumeEffect: function(a) {
			a && a.resume()
		},
		resumeAllEffects: function() {
			var a = this._audioPool,
				c;
			for(c in a)
				for(var b =
						a[c], d = 0; d < a[c].length; d++) b[d].resume()
		},
		stopEffect: function(a) {
			a && a.stop()
		},
		stopAllEffects: function() {
			var a = this._audioPool,
				c;
			for(c in a)
				for(var b = a[c], d = 0; d < a[c].length; d++) b[d].stop()
		},
		unloadEffect: function(a) {
			if(a) {
				cc.loader.release(a);
				var c = this._audioPool[a];
				c && (c.length = 0);
				delete this._audioPool[a];
				delete h.cache[a]
			}
		},
		end: function() {
			this.stopMusic();
			this.stopAllEffects()
		},
		_pauseCache: [],
		_pausePlaying: function() {
			var a = this._currMusic;
			a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
			var a = this._audioPool,
				c;
			for(c in a)
				for(var b = a[c], d = 0; d < a[c].length; d++) b[d].getPlaying() && (b[d].pause(), this._pauseCache.push(b[d]))
		},
		_resumePlaying: function() {
			for(var a = this._pauseCache, c = 0; c < a.length; c++) a[c].resume();
			a.length = 0
		}
	};
	if(!d) {
		var k = function() {
			var c = cc.audioEngine._currMusic;
			c && !1 === c._touch && c._playing && c.getPlaying() && (c._touch = !0, c.play(0, c.loop), !a.replay && cc._canvas.removeEventListener("touchstart", k))
		};
		setTimeout(function() {
			cc._canvas && cc._canvas.addEventListener("touchstart",
				k, !1)
		}, 150)
	}
	cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
		cc.audioEngine._pausePlaying()
	});
	cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
		cc.audioEngine._resumePlaying()
	})
})(cc.__audioSupport);
cc.LabelAtlas = cc.AtlasNode.extend({
	_string: null,
	_mapStartChar: null,
	_textureLoaded: !1,
	_className: "LabelAtlas",
	ctor: function(a, c, b, d, e) {
		cc.AtlasNode.prototype.ctor.call(this);
		this._renderCmd.setCascade();
		c && cc.LabelAtlas.prototype.initWithString.call(this, a, c, b, d, e)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a,
		c) {
		this.addEventListener("load", a, c)
	},
	initWithString: function(a, c, b, d, e) {
		var f = a + "",
			g, h;
		if(void 0 === b) {
			b = cc.loader.getRes(c);
			if(1 !== parseInt(b.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
			c = cc.path.changeBasename(c, b.textureFilename);
			d = cc.contentScaleFactor();
			g = parseInt(b.itemWidth, 10) / d;
			h = parseInt(b.itemHeight, 10) / d;
			b = String.fromCharCode(parseInt(b.firstChar, 10))
		} else g = b || 0, h = d || 0, b = e || " ";
		var k = null,
			k = c instanceof cc.Texture2D ? c : cc.textureCache.addImage(c);
		this._textureLoaded = c = k.isLoaded();
		c || (this._string = f, k.addEventListener("load", function(a) {
			this.initWithTexture(k, g, h, f.length);
			this.string = this._string;
			this.setColor(this._renderCmd._displayedColor);
			this.dispatchEvent("load")
		}, this));
		return this.initWithTexture(k, g, h, f.length) ? (this._mapStartChar = b, this.string = f, !0) : !1
	},
	setColor: function(a) {
		cc.AtlasNode.prototype.setColor.call(this, a);
		this._renderCmd.updateAtlasValues()
	},
	getString: function() {
		return this._string
	},
	addChild: function(a, c, b) {
		this._renderCmd._addChild(a);
		cc.Node.prototype.addChild.call(this, a, c, b)
	},
	updateAtlasValues: function() {
		this._renderCmd.updateAtlasValues()
	},
	setString: function(a) {
		a = String(a);
		var c = a.length;
		this._string = a;
		this.setContentSize(c * this._itemWidth, this._itemHeight);
		this._renderCmd.setString(a);
		this._renderCmd.updateAtlasValues();
		this.quadsToDraw = c
	}
});
(function() {
	var a = cc.LabelAtlas.prototype;
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "string", a.getString, a.setString)
})();
cc.LabelAtlas.create = function(a, c, b, d, e) {
	return new cc.LabelAtlas(a, c, b, d, e)
};
(function() {
	cc.LabelAtlas.CanvasRenderCmd = function(a) {
		cc.AtlasNode.CanvasRenderCmd.call(this, a);
		this._needDraw = !1
	};
	var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
	a.constructor = cc.LabelAtlas.CanvasRenderCmd;
	a.setCascade = function() {
		var a = this._node;
		a._cascadeOpacityEnabled = !0;
		a._cascadeColorEnabled = !1
	};
	a.updateAtlasValues = function() {
		for(var a = this._node, b = a._string || "", d = b.length, e = this._texture, f = a._itemWidth, g = a._itemHeight, h = 0, k = -1; h < d; h++) {
			var m =
				b.charCodeAt(h) - a._mapStartChar.charCodeAt(0),
				n = parseInt(m % a._itemsPerRow, 10),
				m = parseInt(m / a._itemsPerRow, 10);
			if(!(0 > n || 0 > m)) {
				k++;
				var n = cc.rect(n * f, m * g, f, g),
					m = b.charCodeAt(h),
					p = a.getChildByTag(h);
				p ? 32 === m ? (p.init(), p.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (p.initWithTexture(e, n), p.visible = !0) : (p = new cc.Sprite, 32 === m ? (p.init(), p.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : p.initWithTexture(e, n), cc.Node.prototype.addChild.call(a, p, 0, h));
				p.setPosition(k * f + f / 2, g / 2)
			}
		}
	};
	a.setString =
		function(a) {
			a = this._node;
			if(a._children) {
				a = a._children;
				for(var b = a.length, d = 0; d < b; d++) {
					var e = a[d];
					e && !e._lateChild && (e.visible = !1)
				}
			}
		};
	a._addChild = function() {
		child._lateChild = !0
	}
})();
(function() {
	cc.LabelAtlas.WebGLRenderCmd = function(a) {
		cc.AtlasNode.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
	a.constructor = cc.LabelAtlas.WebGLRenderCmd;
	a.setCascade = function() {
		var a = this._node;
		a._cascadeOpacityEnabled = !0;
		a._cascadeColorEnabled = !0
	};
	a.rendering = function(a) {
		cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a);
		cc.LABELATLAS_DEBUG_DRAW && (a = this._node.getContentSize(), a = [cc.p(0,
			0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
	};
	a.updateAtlasValues = function() {
		var a = this._node,
			b = a._string,
			d = b.length,
			e = this._textureAtlas,
			f = e.texture,
			g = f.pixelsWidth,
			f = f.pixelsHeight,
			h = a._itemWidth,
			k = a._itemHeight;
		a._ignoreContentScaleFactor || (h = a._itemWidth * cc.contentScaleFactor(), k = a._itemHeight * cc.contentScaleFactor());
		d > e.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
		for(var m = e.quads, n = this._displayedColor,
				n = {
					r: n.r,
					g: n.g,
					b: n.b,
					a: a._displayedOpacity
				}, p = a._itemWidth, s = 0, q = -1; s < d; s++) {
			var t = b.charCodeAt(s) - a._mapStartChar.charCodeAt(0),
				r = t % a._itemsPerRow,
				u = 0 | t / a._itemsPerRow;
			if(!(0 > r || 0 > u)) {
				q++;
				var v;
				cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (r = (2 * r * h + 1) / (2 * g), t = r + (2 * h - 2) / (2 * g), u = (2 * u * k + 1) / (2 * f), v = u + (2 * k - 2) / (2 * f)) : (r = r * h / g, t = r + h / g, u = u * k / f, v = u + k / f);
				var w = m[s],
					x = w.tl,
					z = w.tr,
					y = w.bl,
					w = w.br;
				x.texCoords.u = r;
				x.texCoords.v = u;
				z.texCoords.u = t;
				z.texCoords.v = u;
				y.texCoords.u = r;
				y.texCoords.v = v;
				w.texCoords.u = t;
				w.texCoords.v =
					v;
				y.vertices.x = q * p;
				y.vertices.y = 0;
				y.vertices.z = 0;
				w.vertices.x = q * p + p;
				w.vertices.y = 0;
				w.vertices.z = 0;
				x.vertices.x = q * p;
				x.vertices.y = a._itemHeight;
				x.vertices.z = 0;
				z.vertices.x = q * p + p;
				z.vertices.y = a._itemHeight;
				z.vertices.z = 0;
				x.colors = n;
				z.colors = n;
				y.colors = n;
				w.colors = n
			}
		}
		0 < d && (e.dirty = !0, a = e.totalQuads, d > a && e.increaseTotalQuadsWith(d - a))
	};
	a.setString = function(a) {
		a = a.length;
		a > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(a)
	};
	a._addChild = function() {}
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
	_opacityModifyRGB: !1,
	_string: "",
	_config: null,
	_fntFile: "",
	_initialString: "",
	_alignment: cc.TEXT_ALIGNMENT_CENTER,
	_width: -1,
	_lineBreakWithoutSpaces: !1,
	_imageOffset: null,
	_reusedChar: null,
	_textureLoaded: !1,
	_className: "LabelBMFont",
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
	},
	_setString: function(a, c) {
		c ? this._initialString = a : this._string = a;
		var b = this._children;
		if(b)
			for(var d = 0; d < b.length; d++) {
				var e = b[d];
				e && e.setVisible(!1)
			}
		this._textureLoaded && (this.createFontChars(), c && this.updateLabel())
	},
	ctor: function(a, c, b, d, e) {
		cc.SpriteBatchNode.prototype.ctor.call(this);
		this._imageOffset = cc.p(0, 0);
		this._reusedChar = [];
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
		this.initWithString(a, c, b, d, e)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, c) {
		this.addEventListener("load", a, c)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setOpacityModifyRGB: function(a) {
		this._opacityModifyRGB = a;
		if(a = this._children)
			for(var c = 0; c < a.length; c++) {
				var b = a[c];
				b && (b.opacityModifyRGB = this._opacityModifyRGB)
			}
	},
	_changeTextureColor: function() {
		this._renderCmd._changeTextureColor()
	},
	init: function() {
		return this.initWithString(null, null, null, null, null)
	},
	initWithString: function(a, c, b, d, e) {
		a = a || "";
		this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
		if(c) {
			var f = cc.loader.getRes(c);
			if(!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
			this._config = f;
			this._fntFile = c;
			c = cc.textureCache.addImage(f.atlasName);
			(this._textureLoaded = f = c.isLoaded()) || c.addEventListener("load", function(a) {
				this._textureLoaded = !0;
				this.initWithTexture(a, this._initialString.length);
				this.setString(this._initialString, !0);
				this.dispatchEvent("load")
			}, this)
		} else c = new cc.Texture2D, f = new Image, c.initWithElement(f), this._textureLoaded = !1;
		return this.initWithTexture(c, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width =
			null == b ? -1 : b, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), this._renderCmd._initBatchTexture(), this.setString(a, !0), !0) : !1
	},
	createFontChars: function() {
		var a = this._renderCmd._texture || this.textureAtlas.texture,
			c = 0,
			b = cc.size(0, 0),
			d = 0,
			e = 1,
			f = this._string,
			g = f ? f.length : 0;
		if(0 !== g) {
			var h, k = this._config,
				m = k.kerningDict,
				n = k.commonHeight,
				p = k.fontDefDictionary;
			for(h = 0; h < g - 1; h++) 10 === f.charCodeAt(h) && e++;
			var s =
				n * e,
				e = -(n - n * e),
				q = -1;
			for(h = 0; h < g; h++)
				if(n = f.charCodeAt(h), 0 !== n)
					if(10 === n) c = 0, e -= k.commonHeight;
					else {
						var q = m[q << 16 | n & 65535] || 0,
							t = p[n];
						t || (cc.log("cocos2d: LabelBMFont: character not found " + f[h]), t = {
							rect: {
								x: 0,
								y: 0,
								width: 0,
								height: 0
							},
							xOffset: 0,
							yOffset: 0,
							xAdvance: 0
						});
						var r = cc.rect(t.rect.x, t.rect.y, t.rect.width, t.rect.height),
							r = cc.rectPixelsToPoints(r);
						r.x += this._imageOffset.x;
						r.y += this._imageOffset.y;
						var u = this.getChildByTag(h);
						u ? this._renderCmd._updateCharTexture(u, r, n) : (u = new cc.Sprite, u.initWithTexture(a,
							r, !1), u._newTextureWhenChangeColor = !0, this.addChild(u, 0, h));
						u.opacityModifyRGB = this._opacityModifyRGB;
						this._renderCmd._updateCharColorAndOpacity(u);
						r = cc.p(c + t.xOffset + 0.5 * t.rect.width + q, e + (k.commonHeight - t.yOffset) - 0.5 * r.height * cc.contentScaleFactor());
						u.setPosition(cc.pointPixelsToPoints(r));
						c += t.xAdvance + q;
						q = n;
						d < c && (d = c)
					}
			b.width = t && t.xAdvance < t.rect.width ? d - t.xAdvance + t.rect.width : d;
			b.height = s;
			this.setContentSize(cc.sizePixelsToPoints(b))
		}
	},
	updateString: function(a) {
		var c = this._children;
		if(c)
			for(var b =
					0, d = c.length; b < d; b++) {
				var e = c[b];
				e && (e.visible = !1)
			}
		this._config && this.createFontChars();
		a || this.updateLabel()
	},
	getString: function() {
		return this._initialString
	},
	setString: function(a, c) {
		a = String(a);
		null == c && (c = !0);
		null != a && cc.isString(a) || (a += "");
		this._initialString = a;
		this._setString(a, c)
	},
	_setStringForSetter: function(a) {
		this.setString(a, !1)
	},
	setCString: function(a) {
		this.setString(a, !0)
	},
	_getCharsWidth: function(a, c) {
		if(0 >= c) return 0;
		var b = this.getChildByTag(a),
			d = this.getChildByTag(a + c);
		return this._getLetterPosXLeft(d) -
			this._getLetterPosXLeft(b)
	},
	_checkWarp: function(a, c, b, d) {
		for(var e = a[c], f = 0, g = 0; g < c; g++) f += a[g].length;
		var f = f + c - d,
			h = this._getCharsWidth(f, a[c].length - 1);
		if(h > b && 1 < e.length) {
			d = b / h * e.length | 0;
			for(var g = e.substr(d), k = h - this._getCharsWidth(f + d, g.length - 1), m, n = 0, p = 0; k > b && 100 > p++;) d *= b / k, d |= 0, g = e.substr(d), k = h - this._getCharsWidth(f + d, g.length - 1);
			for(p = 0; k < b && 100 > p++;) g && (n = (m = cc.LabelTTF._wordRex.exec(g)) ? m[0].length : 1, m = g), this._lineBreakWithoutSpaces && (n = 0), d += n, g = e.substr(d), k = h - this._getCharsWidth(f +
				d, g.length - 1);
			d -= n;
			0 === d && (d = 1, m = m.substr(1));
			b = e.substr(0, d);
			cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(m || g) && (n = (f = cc.LabelTTF._lastWordRex.exec(b)) ? f[0].length : 0, this._lineBreakWithoutSpaces && (n = 0), d -= n, m = e.substr(d), b = e.substr(0, d));
			cc.LabelTTF._firsrEnglish.test(m) && (f = cc.LabelTTF._lastEnglish.exec(b)) && b !== f[0] && (n = f[0].length, this._lineBreakWithoutSpaces && (n = 0), d -= n, m = e.substr(d), b = e.substr(0, d));
			a[c] = m || g;
			a.splice(c, 0, b)
		}
	},
	updateLabel: function() {
		this.string = this._initialString;
		var a, c, b;
		if(0 < this._width) {
			var d = this.string.split("\n"),
				e = "",
				f = 0,
				g = 0;
			for(a = 0; a < d.length; a++) g = d.length, this._checkWarp(d, a, this._width * this._scaleX, f), g < d.length && f++, 0 < a && (e += "\n"), e += d[a];
			e += String.fromCharCode(0);
			this._setString(e, !1)
		}
		if(this._alignment !== cc.TEXT_ALIGNMENT_LEFT)
			for(d = a = 0, e = this._string.length, f = [], g = 0; g < e; g++)
				if(10 === this._string[g].charCodeAt(0) || 0 === this._string[g].charCodeAt(0)) {
					c = 0;
					var h = f.length;
					if(0 === h) d++;
					else if(b = a + h - 1 + d, !(0 > b)) {
						var k = this.getChildByTag(b);
						if(null !=
							k) {
							c = k.getPositionX() + k._getWidth() / 2;
							k = 0;
							switch(this._alignment) {
								case cc.TEXT_ALIGNMENT_CENTER:
									k = this.width / 2 - c / 2;
									break;
								case cc.TEXT_ALIGNMENT_RIGHT:
									k = this.width - c
							}
							if(0 !== k)
								for(c = 0; c < h; c++) b = a + c + d, 0 > b || (b = this.getChildByTag(b)) && (b.x += k);
							a += h;
							d++;
							f.length = 0
						}
					}
				} else f.push(this._string[a])
	},
	setAlignment: function(a) {
		this._alignment = a;
		this.updateLabel()
	},
	_getAlignment: function() {
		return this._alignment
	},
	setBoundingWidth: function(a) {
		this._width = a;
		this.updateLabel()
	},
	_getBoundingWidth: function() {
		return this._width
	},
	setLineBreakWithoutSpace: function(a) {
		this._lineBreakWithoutSpaces = a;
		this.updateLabel()
	},
	setScale: function(a, c) {
		cc.Node.prototype.setScale.call(this, a, c);
		this.updateLabel()
	},
	setScaleX: function(a) {
		cc.Node.prototype.setScaleX.call(this, a);
		this.updateLabel()
	},
	setScaleY: function(a) {
		cc.Node.prototype.setScaleY.call(this, a);
		this.updateLabel()
	},
	setFntFile: function(a) {
		if(null != a && a !== this._fntFile) {
			var c = cc.loader.getRes(a);
			c ? (this._fntFile = a, this._config = c, a = cc.textureCache.addImage(c.atlasName), this._textureLoaded =
				c = a.isLoaded(), this.texture = a, this._renderCmd._updateFntFileTexture(), c ? this.createFontChars() : a.addEventListener("load", function(a) {
					this._textureLoaded = !0;
					this.texture = a;
					this.createFontChars();
					this._changeTextureColor();
					this.updateLabel();
					this.dispatchEvent("load")
				}, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
		}
	},
	getFntFile: function() {
		return this._fntFile
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	setAnchorPoint: function(a, c) {
		cc.Node.prototype.setAnchorPoint.call(this,
			a, c);
		this.updateLabel()
	},
	_setAnchorX: function(a) {
		cc.Node.prototype._setAnchorX.call(this, a);
		this.updateLabel()
	},
	_setAnchorY: function(a) {
		cc.Node.prototype._setAnchorY.call(this, a);
		this.updateLabel()
	},
	_atlasNameFromFntFile: function(a) {},
	_kerningAmountForFirst: function(a, c) {
		var b = 0;
		if(this._configuration.kerningDictionary) {
			var d = this._configuration.kerningDictionary[(a << 16 | c & 65535).toString()];
			d && (b = d.amount)
		}
		return b
	},
	_getLetterPosXLeft: function(a) {
		return a.getPositionX() * this._scaleX - a._getWidth() *
			this._scaleX * a._getAnchorX()
	},
	_getLetterPosXRight: function(a) {
		return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
	},
	_isspace_unicode: function(a) {
		a = a.charCodeAt(0);
		return 9 <= a && 13 >= a || 32 === a || 133 === a || 160 === a || 5760 === a || 8192 <= a && 8202 >= a || 8232 === a || 8233 === a || 8239 === a || 8287 === a || 12288 === a
	},
	_utf8_trim_ws: function(a) {
		var c = a.length;
		if(!(0 >= c) && (c -= 1, this._isspace_unicode(a[c]))) {
			for(var b = c - 1; 0 <= b; --b)
				if(this._isspace_unicode(a[b])) c = b;
				else break;
			this._utf8_trim_from(a, c)
		}
	},
	_utf8_trim_from: function(a, c) {
		var b = a.length;
		c >= b || 0 > c || a.splice(c, b)
	}
});
(function() {
	var a = cc.LabelBMFont.prototype;
	cc.EventHelper.prototype.apply(a);
	cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter);
	cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth);
	cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
})();
cc.LabelBMFont.create = function(a, c, b, d, e) {
	return new cc.LabelBMFont(a, c, b, d, e)
};
cc._fntLoader = {
	INFO_EXP: /info [^\n]*(\n|$)/gi,
	COMMON_EXP: /common [^\n]*(\n|$)/gi,
	PAGE_EXP: /page [^\n]*(\n|$)/gi,
	CHAR_EXP: /char [^\n]*(\n|$)/gi,
	KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
	ITEM_EXP: /\w+=[^ \r\n]+/gi,
	INT_EXP: /^[\-]?\d+$/,
	_parseStrToObj: function(a) {
		a = a.match(this.ITEM_EXP);
		var c = {};
		if(a)
			for(var b = 0, d = a.length; b < d; b++) {
				var e = a[b],
					f = e.indexOf("\x3d"),
					g = e.substring(0, f),
					e = e.substring(f + 1);
				e.match(this.INT_EXP) ? e = parseInt(e) : '"' === e[0] && (e = e.substring(1, e.length - 1));
				c[g] = e
			}
		return c
	},
	parseFnt: function(a,
		c) {
		var b = {},
			d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
		parseInt(d[0]);
		parseInt(d[1]);
		parseInt(d[2]);
		parseInt(d[3]);
		d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
		b.commonHeight = d.lineHeight;
		if(cc._renderType === cc._RENDER_TYPE_WEBGL) {
			var e = cc.configuration.getMaxTextureSize();
			(d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
		}
		1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
		d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
		0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
		b.atlasName = cc.path.changeBasename(c, d.file);
		for(var f = a.match(this.CHAR_EXP), g = b.fontDefDictionary = {}, d = 0, e = f.length; d < e; d++) {
			var h = this._parseStrToObj(f[d]);
			g[h.id] = {
				rect: {
					x: h.x,
					y: h.y,
					width: h.width,
					height: h.height
				},
				xOffset: h.xoffset,
				yOffset: h.yoffset,
				xAdvance: h.xadvance
			}
		}
		f = b.kerningDict = {};
		if(g = a.match(this.KERNING_EXP))
			for(d = 0, e = g.length; d < e; d++) h = this._parseStrToObj(g[d]),
				f[h.first << 16 | h.second & 65535] = h.amount;
		return b
	},
	load: function(a, c, b, d) {
		var e = this;
		cc.loader.loadTxt(a, function(a, b) {
			if(a) return d(a);
			d(null, e.parseFnt(b, c))
		})
	}
};
cc.loader.register(["fnt"], cc._fntLoader);
(function() {
	cc.LabelBMFont.CanvasRenderCmd = function(a) {
		cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
	a.constructor = cc.LabelBMFont.CanvasRenderCmd;
	a.rendering = function() {
		void 0
	};
	a._updateCharTexture = function(a, b, d) {
		32 === d ? a.setTextureRect(b, !1, cc.size(0, 0)) : (a.setTextureRect(b, !1), a.visible = !0)
	};
	a._updateCharColorAndOpacity = function(a) {
		a._displayedColor = this._displayedColor;
		a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		a._displayedOpacity = this._displayedOpacity;
		a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	};
	a._updateFntFileTexture = function() {
		var a = this._node;
		a._originalTexture = a.texture
	};
	a.setTexture = function(a) {
		for(var b = this._node._children, d = this._displayedColor, e = 0; e < b.length; e++) {
			var f = b[e],
				g = f._renderCmd,
				h = g._displayedColor;
			if(this._texture === g._texture || h.r === d.r && h.g === d.g && h.b === d.b) f.texture = a
		}
		this._texture = a
	};
	a._changeTextureColor =
		cc.sys._supportCanvasNewBlendModes ? function() {
			var a = this._node,
				b = a.getTexture();
			if(b && 0 < b.getContentSize().width) {
				var d = this._originalTexture.getHtmlElementObj();
				if(d) {
					var e = b.getHtmlElementObj(),
						f = cc.rect(0, 0, d.width, d.height);
					e instanceof HTMLCanvasElement && !a._rectRotated ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._displayedColor, f, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._displayedColor, f), b = new cc.Texture2D, b.initWithElement(e), b.handleLoadedTexture());
					a.setTexture(b)
				}
			}
		} : function() {
			var a = this._node,
				b, d = a.getTexture();
			if(d && 0 < d.getContentSize().width && (b = d.getHtmlElementObj())) {
				var e = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
				e && (b instanceof HTMLCanvasElement && !this._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImage(b, e, this._displayedColor, null, b), this.setTexture(d)) : (b = cc.Sprite.CanvasRenderCmd._generateTintImage(b, e, this._displayedColor), d = new cc.Texture2D, d.initWithElement(b), d.handleLoadedTexture(),
					a.setTexture(d)))
			}
		};
	a._updateChildrenDisplayedOpacity = function(a) {
		cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
	};
	a._updateChildrenDisplayedColor = function(a) {
		cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
	};
	a._initBatchTexture = function() {}
})();
(function() {
	cc.LabelBMFont.WebGLRenderCmd = function(a) {
		cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
	a.constructor = cc.LabelBMFont.WebGLRenderCmd;
	a._updateCharTexture = function(a, b, d) {
		a.setTextureRect(b, !1);
		a.visible = !0
	};
	a._updateFntFileTexture = function() {};
	a._changeTextureColor = function() {};
	a._updateChildrenDisplayedOpacity = function(a) {
		a.updateDisplayedOpacity(this._displayedOpacity)
	};
	a._updateChildrenDisplayedColor = function(a) {
		a.updateDisplayedColor(this._displayedColor)
	};
	a._initBatchTexture = function() {
		var a = this._node,
			b = a.textureAtlas.texture;
		a._opacityModifyRGB = b.hasPremultipliedAlpha();
		var d = a._reusedChar = new cc.Sprite;
		d.initWithTexture(b, cc.rect(0, 0, 0, 0), !1);
		d.batchNode = a
	};
	a.rendering = function(a) {
		cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
		a = this._node;
		if(cc.LABELBMFONT_DEBUG_DRAW) {
			a = a.getContentSize();
			var b = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
			a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)];
			cc._drawingUtil.setDrawColor(0, 255, 0, 255);
			cc._drawingUtil.drawPoly(a, 4, !0)
		}
	};
	a._updateCharColorAndOpacity = function() {}
})();
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
	originalTarget: null,
	target: null,
	tag: cc.ACTION_TAG_INVALID,
	ctor: function() {
		this.target = this.originalTarget = null;
		this.tag = cc.ACTION_TAG_INVALID
	},
	copy: function() {
		cc.log("copy is deprecated. Please use clone instead.");
		return this.clone()
	},
	clone: function() {
		var a = new cc.Action;
		a.originalTarget = null;
		a.target = null;
		a.tag = this.tag;
		return a
	},
	isDone: function() {
		return !0
	},
	startWithTarget: function(a) {
		this.target = this.originalTarget = a
	},
	stop: function() {
		this.target = null
	},
	step: function(a) {
		cc.log("[Action step]. override me")
	},
	update: function(a) {
		cc.log("[Action update]. override me")
	},
	getTarget: function() {
		return this.target
	},
	setTarget: function(a) {
		this.target = a
	},
	getOriginalTarget: function() {
		return this.originalTarget
	},
	setOriginalTarget: function(a) {
		this.originalTarget = a
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(a) {
		this.tag = a
	},
	retain: function() {},
	release: function() {}
});
cc.action = function() {
	return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
	_duration: 0,
	ctor: function() {
		cc.Action.prototype.ctor.call(this);
		this._duration = 0
	},
	getDuration: function() {
		return this._duration * (this._timesForRepeat || 1)
	},
	setDuration: function(a) {
		this._duration = a
	},
	reverse: function() {
		cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
		return null
	},
	clone: function() {
		return new cc.FiniteTimeAction
	}
});
cc.Speed = cc.Action.extend({
	_speed: 0,
	_innerAction: null,
	ctor: function(a, c) {
		cc.Action.prototype.ctor.call(this);
		this._speed = 0;
		this._innerAction = null;
		a && this.initWithAction(a, c)
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(a) {
		this._speed = a
	},
	initWithAction: function(a, c) {
		if(!a) throw "cc.Speed.initWithAction(): action must be non nil";
		this._innerAction = a;
		this._speed = c;
		return !0
	},
	clone: function() {
		var a = new cc.Speed;
		a.initWithAction(this._innerAction.clone(), this._speed);
		return a
	},
	startWithTarget: function(a) {
		cc.Action.prototype.startWithTarget.call(this,
			a);
		this._innerAction.startWithTarget(a)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	step: function(a) {
		this._innerAction.step(a * this._speed)
	},
	isDone: function() {
		return this._innerAction.isDone()
	},
	reverse: function() {
		return new cc.Speed(this._innerAction.reverse(), this._speed)
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.speed = function(a, c) {
	return new cc.Speed(a, c)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
	_followedNode: null,
	_boundarySet: !1,
	_boundaryFullyCovered: !1,
	_halfScreenSize: null,
	_fullScreenSize: null,
	_worldRect: null,
	leftBoundary: 0,
	rightBoundary: 0,
	topBoundary: 0,
	bottomBoundary: 0,
	ctor: function(a, c) {
		cc.Action.prototype.ctor.call(this);
		this._followedNode = null;
		this._boundaryFullyCovered = this._boundarySet = !1;
		this._fullScreenSize = this._halfScreenSize = null;
		this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
		this._worldRect = cc.rect(0, 0, 0, 0);
		a && (c ? this.initWithTarget(a,
			c) : this.initWithTarget(a))
	},
	clone: function() {
		var a = new cc.Follow,
			c = this._worldRect,
			c = new cc.Rect(c.x, c.y, c.width, c.height);
		a.initWithTarget(this._followedNode, c);
		return a
	},
	isBoundarySet: function() {
		return this._boundarySet
	},
	setBoudarySet: function(a) {
		this._boundarySet = a
	},
	initWithTarget: function(a, c) {
		if(!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
		c = c || cc.rect(0, 0, 0, 0);
		this._followedNode = a;
		this._worldRect = c;
		this._boundarySet = !cc._rectEqualToZero(c);
		this._boundaryFullyCovered = !1;
		var b = cc.director.getWinSize();
		this._fullScreenSize = cc.p(b.width, b.height);
		this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
		this._boundarySet && (this.leftBoundary = -(c.x + c.width - this._fullScreenSize.x), this.rightBoundary = -c.x, this.topBoundary = -c.y, this.bottomBoundary = -(c.y + c.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary =
			(this.topBoundary + this.bottomBoundary) / 2), this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0));
		return !0
	},
	step: function(a) {
		a = this._followedNode.x;
		var c = this._followedNode.y;
		a = this._halfScreenSize.x - a;
		c = this._halfScreenSize.y - c;
		this.target._renderCmd._dirtyFlag = 0;
		this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(c, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a,
			c)
	},
	isDone: function() {
		return !this._followedNode.running
	},
	stop: function() {
		this.target = null;
		cc.Action.prototype.stop.call(this)
	}
});
cc.follow = function(a, c) {
	return new cc.Follow(a, c)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
	_elapsed: 0,
	_firstTick: !1,
	_easeList: null,
	_timesForRepeat: 1,
	_repeatForever: !1,
	_repeatMethod: !1,
	_speed: 1,
	_speedMethod: !1,
	ctor: function(a) {
		this._timesForRepeat = this._speed = 1;
		this._repeatForever = !1;
		this.MAX_VALUE = 2;
		this._speedMethod = this._repeatMethod = !1;
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && this.initWithDuration(a)
	},
	getElapsed: function() {
		return this._elapsed
	},
	initWithDuration: function(a) {
		this._duration = 0 === a ? cc.FLT_EPSILON : a;
		this._elapsed =
			0;
		return this._firstTick = !0
	},
	isDone: function() {
		return this._elapsed >= this._duration
	},
	_cloneDecoration: function(a) {
		a._repeatForever = this._repeatForever;
		a._speed = this._speed;
		a._timesForRepeat = this._timesForRepeat;
		a._easeList = this._easeList;
		a._speedMethod = this._speedMethod;
		a._repeatMethod = this._repeatMethod
	},
	_reverseEaseList: function(a) {
		if(this._easeList) {
			a._easeList = [];
			for(var c = 0; c < this._easeList.length; c++) a._easeList.push(this._easeList[c].reverse())
		}
	},
	clone: function() {
		var a = new cc.ActionInterval(this._duration);
		this._cloneDecoration(a);
		return a
	},
	easing: function(a) {
		this._easeList ? this._easeList.length = 0 : this._easeList = [];
		for(var c = 0; c < arguments.length; c++) this._easeList.push(arguments[c]);
		return this
	},
	_computeEaseTime: function(a) {
		var c = this._easeList;
		if(!c || 0 === c.length) return a;
		for(var b = 0, d = c.length; b < d; b++) a = c[b].easing(a);
		return a
	},
	step: function(a) {
		this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
		a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
		a = 1 > a ?
			a : 1;
		this.update(0 < a ? a : 0);
		this._repeatMethod && 1 < this._timesForRepeat && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
	},
	startWithTarget: function(a) {
		cc.Action.prototype.startWithTarget.call(this, a);
		this._elapsed = 0;
		this._firstTick = !0
	},
	reverse: function() {
		cc.log("cc.IntervalAction: reverse not implemented.");
		return null
	},
	setAmplitudeRate: function(a) {
		cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
	},
	getAmplitudeRate: function() {
		cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
		return 0
	},
	speed: function(a) {
		if(0 >= a) return cc.log("The speed parameter error"), this;
		this._speedMethod = !0;
		this._speed *= a;
		return this
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(a) {
		this._speed = a;
		return this
	},
	repeat: function(a) {
		a = Math.round(a);
		if(isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
		this._repeatMethod = !0;
		this._timesForRepeat *= a;
		return this
	},
	repeatForever: function() {
		this._repeatMethod = !0;
		this._timesForRepeat = this.MAX_VALUE;
		this._repeatForever = !0;
		return this
	}
});
cc.actionInterval = function(a) {
	return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
	_actions: null,
	_split: null,
	_last: 0,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._actions = [];
		var c = a instanceof Array ? a : arguments,
			b = c.length - 1;
		0 <= b && null == c[b] && cc.log("parameters should not be ending with null in Javascript");
		if(0 <= b) {
			for(var d = c[0], e = 1; e < b; e++) c[e] && (d = cc.Sequence._actionOneTwo(d, c[e]));
			this.initWithTwoActions(d, c[b])
		}
	},
	initWithTwoActions: function(a, c) {
		if(!a || !c) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
		this.initWithDuration(a._duration + c._duration);
		this._actions[0] = a;
		this._actions[1] = c;
		return !0
	},
	clone: function() {
		var a = new cc.Sequence;
		this._cloneDecoration(a);
		a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._split = this._actions[0]._duration / this._duration;
		this._last = -1
	},
	stop: function() {
		-1 !== this._last && this._actions[this._last].stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		var c =
			0,
			b = this._split,
			d = this._actions,
			e = this._last;
		a = this._computeEaseTime(a);
		a < b ? (a = 0 !== b ? a / b : 1, 0 === c && 1 === e && (d[1].update(0), d[1].stop())) : (c = 1, a = 1 === b ? 1 : (a - b) / (1 - b), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()), e || (d[0].update(1), d[0].stop()));
		d = d[c];
		e === c && d.isDone() || (e !== c && d.startWithTarget(this.target), a *= d._timesForRepeat, d.update(1 < a ? a % 1 : a), this._last = c)
	},
	reverse: function() {
		var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.sequence = function(a) {
	var c = a instanceof Array ? a : arguments;
	0 < c.length && null == c[c.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for(var b, d, e, f; c && 0 < c.length;)
		for(d = Array.prototype.shift.call(c), f = d._timesForRepeat || 1, d._repeatMethod = !1, d._timesForRepeat = 1, e = 0, b || (b = d, e = 1), e; e < f; e++) b = cc.Sequence._actionOneTwo(b, d);
	return b
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, c) {
	var b = new cc.Sequence;
	b.initWithTwoActions(a, c);
	return b
};
cc.Repeat = cc.ActionInterval.extend({
	_times: 0,
	_total: 0,
	_nextDt: 0,
	_actionInstant: !1,
	_innerAction: null,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithAction(a, c)
	},
	initWithAction: function(a, c) {
		return this.initWithDuration(a._duration * c) ? (this._times = c, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
	},
	clone: function() {
		var a = new cc.Repeat;
		this._cloneDecoration(a);
		a.initWithAction(this._innerAction.clone(),
			this._times);
		return a
	},
	startWithTarget: function(a) {
		this._total = 0;
		this._nextDt = this._innerAction._duration / this._duration;
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._innerAction.startWithTarget(a)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var c = this._innerAction,
			b = this._duration,
			d = this._times,
			e = this._nextDt;
		if(a >= e) {
			for(; a > e && this._total < d;) c.update(1), this._total++, c.stop(), c.startWithTarget(this.target),
				this._nextDt = e += c._duration / b;
			1 <= a && this._total < d && this._total++;
			this._actionInstant || (this._total === d ? (c.update(1), c.stop()) : c.update(a - (e - c._duration / b)))
		} else c.update(a * d % 1)
	},
	isDone: function() {
		return this._total === this._times
	},
	reverse: function() {
		var a = new cc.Repeat(this._innerAction.reverse(), this._times);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeat = function(a, c) {
	return new cc.Repeat(a, c)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
	_innerAction: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._innerAction = null;
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if(!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
		this._innerAction = a;
		return !0
	},
	clone: function() {
		var a = new cc.RepeatForever;
		this._cloneDecoration(a);
		a.initWithAction(this._innerAction.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		this._innerAction.startWithTarget(a)
	},
	step: function(a) {
		var c = this._innerAction;
		c.step(a);
		c.isDone() && (c.startWithTarget(this.target), c.step(c.getElapsed() - c._duration))
	},
	isDone: function() {
		return !1
	},
	reverse: function() {
		var a = new cc.RepeatForever(this._innerAction.reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeatForever = function(a) {
	return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
	_one: null,
	_two: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._two = this._one = null;
		var c = a instanceof Array ? a : arguments,
			b = c.length - 1;
		0 <= b && null == c[b] && cc.log("parameters should not be ending with null in Javascript");
		if(0 <= b) {
			for(var d = c[0], e = 1; e < b; e++) c[e] && (d = cc.Spawn._actionOneTwo(d, c[e]));
			this.initWithTwoActions(d, c[b])
		}
	},
	initWithTwoActions: function(a, c) {
		if(!a || !c) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
		var b = !1,
			d = a._duration,
			e = c._duration;
		this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = c, d > e ? this._two = cc.Sequence._actionOneTwo(c, cc.delayTime(d - e)) : d < e && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), b = !0);
		return b
	},
	clone: function() {
		var a = new cc.Spawn;
		this._cloneDecoration(a);
		a.initWithTwoActions(this._one.clone(), this._two.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._one.startWithTarget(a);
		this._two.startWithTarget(a)
	},
	stop: function() {
		this._one.stop();
		this._two.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._one && this._one.update(a);
		this._two && this._two.update(a)
	},
	reverse: function() {
		var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.spawn = function(a) {
	var c = a instanceof Array ? a : arguments;
	0 < c.length && null == c[c.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for(var b = c[0], d = 1; d < c.length; d++) null != c[d] && (b = cc.Spawn._actionOneTwo(b, c[d]));
	return b
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, c) {
	var b = new cc.Spawn;
	b.initWithTwoActions(a, c);
	return b
};
cc.RotateTo = cc.ActionInterval.extend({
	_dstAngleX: 0,
	_startAngleX: 0,
	_diffAngleX: 0,
	_dstAngleY: 0,
	_startAngleY: 0,
	_diffAngleY: 0,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = c || 0, this._dstAngleY = b || this._dstAngleX, !0) : !1
	},
	clone: function() {
		var a = new cc.RotateTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._dstAngleX,
			this._dstAngleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var c = a.rotationX % 360,
			b = this._dstAngleX - c;
		180 < b && (b -= 360); - 180 > b && (b += 360);
		this._startAngleX = c;
		this._diffAngleX = b;
		this._startAngleY = a.rotationY % 360;
		a = this._dstAngleY - this._startAngleY;
		180 < a && (a -= 360); - 180 > a && (a += 360);
		this._diffAngleY = a
	},
	reverse: function() {
		cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.rotationX =
			this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
	}
});
cc.rotateTo = function(a, c, b) {
	return new cc.RotateTo(a, c, b)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
	_angleX: 0,
	_startAngleX: 0,
	_angleY: 0,
	_startAngleY: 0,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = c || 0, this._angleY = b || this._angleX, !0) : !1
	},
	clone: function() {
		var a = new cc.RotateBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._angleX, this._angleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		this._startAngleX = a.rotationX;
		this._startAngleY = a.rotationY
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
	},
	reverse: function() {
		var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.rotateBy = function(a, c, b) {
	return new cc.RotateBy(a, c, b)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
	_positionDelta: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._positionDelta = cc.p(0, 0);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		void 0 !== c && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== c.x && (b = c.y, c = c.x), this._positionDelta.x = c, this._positionDelta.y = b, !0) : !1
	},
	clone: function() {
		var a =
			new cc.MoveBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._positionDelta);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var c = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = c;
		this._previousPosition.y = a;
		this._startPosition.x = c;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if(this.target) {
			var c = this._positionDelta.x * a;
			a *= this._positionDelta.y;
			var b = this._startPosition;
			if(cc.ENABLE_STACKABLE_ACTIONS) {
				var d =
					this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				b.x = b.x + d - f.x;
				b.y = b.y + e - f.y;
				c += b.x;
				a += b.y;
				f.x = c;
				f.y = a;
				this.target.setPosition(c, a)
			} else this.target.setPosition(b.x + c, b.y + a)
		}
	},
	reverse: function() {
		var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.moveBy = function(a, c, b) {
	return new cc.MoveBy(a, c, b)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
	_endPosition: null,
	ctor: function(a, c, b) {
		cc.MoveBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== c && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.MoveBy.prototype.initWithDuration.call(this, a, c, b) ? (void 0 !== c.x && (b = c.y, c = c.x), this._endPosition.x = c, this._endPosition.y = b, !0) : !1
	},
	clone: function() {
		var a = new cc.MoveTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endPosition);
		return a
	},
	startWithTarget: function(a) {
		cc.MoveBy.prototype.startWithTarget.call(this,
			a);
		this._positionDelta.x = this._endPosition.x - a.getPositionX();
		this._positionDelta.y = this._endPosition.y - a.getPositionY()
	}
});
cc.moveTo = function(a, c, b) {
	return new cc.MoveTo(a, c, b)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
	_skewX: 0,
	_skewY: 0,
	_startSkewX: 0,
	_startSkewY: 0,
	_endSkewX: 0,
	_endSkewY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		var d = !1;
		cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = c, this._endSkewY = b, d = !0);
		return d
	},
	clone: function() {
		var a = new cc.SkewTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._startSkewX = a.skewX % 180;
		this._deltaX = this._endSkewX - this._startSkewX;
		180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
		this._startSkewY = a.skewY % 360;
		this._deltaY = this._endSkewY - this._startSkewY;
		180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target.skewX = this._startSkewX + this._deltaX * a;
		this.target.skewY =
			this._startSkewY + this._deltaY * a
	}
});
cc.skewTo = function(a, c, b) {
	return new cc.SkewTo(a, c, b)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
	ctor: function(a, c, b) {
		cc.SkewTo.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		var d = !1;
		cc.SkewTo.prototype.initWithDuration.call(this, a, c, b) && (this._skewX = c, this._skewY = b, d = !0);
		return d
	},
	clone: function() {
		var a = new cc.SkewBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._skewX, this._skewY);
		return a
	},
	startWithTarget: function(a) {
		cc.SkewTo.prototype.startWithTarget.call(this, a);
		this._deltaX = this._skewX;
		this._deltaY = this._skewY;
		this._endSkewX = this._startSkewX + this._deltaX;
		this._endSkewY = this._startSkewY + this._deltaY
	},
	reverse: function() {
		var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.skewBy = function(a, c, b) {
	return new cc.SkewBy(a, c, b)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
	_startPosition: null,
	_delta: null,
	_height: 0,
	_jumps: 0,
	_previousPosition: null,
	ctor: function(a, c, b, d, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		this._delta = cc.p(0, 0);
		void 0 !== d && this.initWithDuration(a, c, b, d, e)
	},
	initWithDuration: function(a, c, b, d, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = b, b = c.y, c = c.x), this._delta.x = c, this._delta.y = b, this._height = d, this._jumps =
			e, !0) : !1
	},
	clone: function() {
		var a = new cc.JumpBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var c = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = c;
		this._previousPosition.y = a;
		this._startPosition.x = c;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if(this.target) {
			var c = a * this._jumps % 1,
				c = 4 * this._height * c * (1 - c),
				c = c + this._delta.y *
				a;
			a *= this._delta.x;
			var b = this._startPosition;
			if(cc.ENABLE_STACKABLE_ACTIONS) {
				var d = this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				b.x = b.x + d - f.x;
				b.y = b.y + e - f.y;
				a += b.x;
				c += b.y;
				f.x = a;
				f.y = c;
				this.target.setPosition(a, c)
			} else this.target.setPosition(b.x + a, b.y + c)
		}
	},
	reverse: function() {
		var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.jumpBy = function(a, c, b, d, e) {
	return new cc.JumpBy(a, c, b, d, e)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
	_endPosition: null,
	ctor: function(a, c, b, d, e) {
		cc.JumpBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== d && this.initWithDuration(a, c, b, d, e)
	},
	initWithDuration: function(a, c, b, d, e) {
		return cc.JumpBy.prototype.initWithDuration.call(this, a, c, b, d, e) ? (void 0 === e && (b = c.y, c = c.x), this._endPosition.x = c, this._endPosition.y = b, !0) : !1
	},
	startWithTarget: function(a) {
		cc.JumpBy.prototype.startWithTarget.call(this, a);
		this._delta.x = this._endPosition.x - this._startPosition.x;
		this._delta.y =
			this._endPosition.y - this._startPosition.y
	},
	clone: function() {
		var a = new cc.JumpTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
		return a
	}
});
cc.jumpTo = function(a, c, b, d, e) {
	return new cc.JumpTo(a, c, b, d, e)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, c, b, d, e) {
	return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * c + 3 * Math.pow(e, 2) * (1 - e) * b + Math.pow(e, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({
	_config: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._config = [];
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = c, !0) : !1
	},
	clone: function() {
		var a = new cc.BezierBy;
		this._cloneDecoration(a);
		for(var c = [], b = 0; b < this._config.length; b++) {
			var d =
				this._config[b];
			c.push(cc.p(d.x, d.y))
		}
		a.initWithDuration(this._duration, c);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var c = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = c;
		this._previousPosition.y = a;
		this._startPosition.x = c;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if(this.target) {
			var c = this._config,
				b = c[0].y,
				d = c[1].y,
				e = c[2].y,
				c = cc.bezierAt(0, c[0].x, c[1].x, c[2].x, a);
			a = cc.bezierAt(0, b, d, e, a);
			b = this._startPosition;
			if(cc.ENABLE_STACKABLE_ACTIONS) {
				var d = this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				b.x = b.x + d - f.x;
				b.y = b.y + e - f.y;
				c += b.x;
				a += b.y;
				f.x = c;
				f.y = a;
				this.target.setPosition(c, a)
			} else this.target.setPosition(b.x + c, b.y + a)
		}
	},
	reverse: function() {
		var a = this._config,
			a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
			a = new cc.BezierBy(this._duration, a);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.bezierBy = function(a, c) {
	return new cc.BezierBy(a, c)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
	_toConfig: null,
	ctor: function(a, c) {
		cc.BezierBy.prototype.ctor.call(this);
		this._toConfig = [];
		c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = c, !0) : !1
	},
	clone: function() {
		var a = new cc.BezierTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toConfig);
		return a
	},
	startWithTarget: function(a) {
		cc.BezierBy.prototype.startWithTarget.call(this, a);
		a = this._startPosition;
		var c =
			this._toConfig,
			b = this._config;
		b[0] = cc.pSub(c[0], a);
		b[1] = cc.pSub(c[1], a);
		b[2] = cc.pSub(c[2], a)
	}
});
cc.bezierTo = function(a, c) {
	return new cc.BezierTo(a, c)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
	_scaleX: 1,
	_scaleY: 1,
	_startScaleX: 1,
	_startScaleY: 1,
	_endScaleX: 0,
	_endScaleY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = c, this._endScaleY = null != b ? b : c, !0) : !1
	},
	clone: function() {
		var a = new cc.ScaleTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endScaleX,
			this._endScaleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._startScaleX = a.scaleX;
		this._startScaleY = a.scaleY;
		this._deltaX = this._endScaleX - this._startScaleX;
		this._deltaY = this._endScaleY - this._startScaleY
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
	}
});
cc.scaleTo = function(a, c, b) {
	return new cc.ScaleTo(a, c, b)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
	startWithTarget: function(a) {
		cc.ScaleTo.prototype.startWithTarget.call(this, a);
		this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
		this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
	},
	reverse: function() {
		var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.ScaleBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endScaleX,
			this._endScaleY);
		return a
	}
});
cc.scaleBy = function(a, c, b) {
	return new cc.ScaleBy(a, c, b)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
	_times: 0,
	_originalState: !1,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = c, !0) : !1
	},
	clone: function() {
		var a = new cc.Blink;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._times);
		return a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if(this.target && !this.isDone()) {
			var c = 1 / this._times;
			this.target.visible =
				a % c > c / 2
		}
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._originalState = a.visible
	},
	stop: function() {
		this.target.visible = this._originalState;
		cc.ActionInterval.prototype.stop.call(this)
	},
	reverse: function() {
		var a = new cc.Blink(this._duration, this._times);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.blink = function(a, c) {
	return new cc.Blink(a, c)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
	_toOpacity: 0,
	_fromOpacity: 0,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = c, !0) : !1
	},
	clone: function() {
		var a = new cc.FadeTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var c = void 0 !== this._fromOpacity ? this._fromOpacity :
			255;
		this.target.opacity = c + (this._toOpacity - c) * a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._fromOpacity = a.opacity
	}
});
cc.fadeTo = function(a, c) {
	return new cc.FadeTo(a, c)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
	_reverseAction: null,
	ctor: function(a) {
		cc.FadeTo.prototype.ctor.call(this);
		null == a && (a = 0);
		this.initWithDuration(a, 255)
	},
	reverse: function() {
		var a = new cc.FadeOut;
		a.initWithDuration(this._duration, 0);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.FadeIn;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	},
	startWithTarget: function(a) {
		this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
		cc.FadeTo.prototype.startWithTarget.call(this, a)
	}
});
cc.fadeIn = function(a) {
	return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
	ctor: function(a) {
		cc.FadeTo.prototype.ctor.call(this);
		null == a && (a = 0);
		this.initWithDuration(a, 0)
	},
	reverse: function() {
		var a = new cc.FadeIn;
		a._reverseAction = this;
		a.initWithDuration(this._duration, 255);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.FadeOut;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	}
});
cc.fadeOut = function(a) {
	return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
	_to: null,
	_from: null,
	ctor: function(a, c, b, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._to = cc.color(0, 0, 0);
		this._from = cc.color(0, 0, 0);
		void 0 !== d && this.initWithDuration(a, c, b, d)
	},
	initWithDuration: function(a, c, b, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(c, b, d), !0) : !1
	},
	clone: function() {
		var a = new cc.TintTo;
		this._cloneDecoration(a);
		var c = this._to;
		a.initWithDuration(this._duration, c.r, c.g, c.b);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		this._from = this.target.color
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var c = this._from,
			b = this._to;
		c && this.target.setColor(cc.color(c.r + (b.r - c.r) * a, c.g + (b.g - c.g) * a, c.b + (b.b - c.b) * a))
	}
});
cc.tintTo = function(a, c, b, d) {
	return new cc.TintTo(a, c, b, d)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
	_deltaR: 0,
	_deltaG: 0,
	_deltaB: 0,
	_fromR: 0,
	_fromG: 0,
	_fromB: 0,
	ctor: function(a, c, b, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, c, b, d)
	},
	initWithDuration: function(a, c, b, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = c, this._deltaG = b, this._deltaB = d, !0) : !1
	},
	clone: function() {
		var a = new cc.TintBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		a = a.color;
		this._fromR = a.r;
		this._fromG = a.g;
		this._fromB = a.b
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
	},
	reverse: function() {
		var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.tintBy = function(a, c, b, d) {
	return new cc.TintBy(a, c, b, d)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
	update: function(a) {},
	reverse: function() {
		var a = new cc.DelayTime(this._duration);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.DelayTime;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration);
		return a
	}
});
cc.delayTime = function(a) {
	return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
	_other: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._other = null;
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if(!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
		if(a === this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
		return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
	},
	clone: function() {
		var a = new cc.ReverseTime;
		this._cloneDecoration(a);
		a.initWithAction(this._other.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._other.startWithTarget(a)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._other && this._other.update(1 - a)
	},
	reverse: function() {
		return this._other.clone()
	},
	stop: function() {
		this._other.stop();
		cc.Action.prototype.stop.call(this)
	}
});
cc.reverseTime = function(a) {
	return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
	_animation: null,
	_nextFrame: 0,
	_origFrame: null,
	_executedLoops: 0,
	_splitTimes: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._splitTimes = [];
		a && this.initWithAnimation(a)
	},
	getAnimation: function() {
		return this._animation
	},
	setAnimation: function(a) {
		this._animation = a
	},
	initWithAnimation: function(a) {
		if(!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
		var c = a.getDuration();
		if(this.initWithDuration(c * a.getLoops())) {
			this._nextFrame =
				0;
			this.setAnimation(a);
			this._origFrame = null;
			this._executedLoops = 0;
			var b = this._splitTimes,
				d = b.length = 0,
				e = c / a.getTotalDelayUnits();
			a = a.getFrames();
			cc.arrayVerifyType(a, cc.AnimationFrame);
			for(var f = 0; f < a.length; f++) {
				var g = d * e / c,
					d = d + a[f].getDelayUnits();
				b.push(g)
			}
			return !0
		}
		return !1
	},
	clone: function() {
		var a = new cc.Animate;
		this._cloneDecoration(a);
		a.initWithAnimation(this._animation.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._animation.getRestoreOriginalFrame() &&
			(this._origFrame = a.displayFrame());
		this._executedLoops = this._nextFrame = 0
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
		for(var c = this._animation.getFrames(), b = c.length, d = this._splitTimes, e = this._nextFrame; e < b; e++)
			if(d[e] <= a) this.target.setSpriteFrame(c[e].getSpriteFrame()), this._nextFrame = e + 1;
			else break
	},
	reverse: function() {
		var a = this._animation,
			c = a.getFrames(),
			b = [];
		cc.arrayVerifyType(c,
			cc.AnimationFrame);
		if(0 < c.length)
			for(var d = c.length - 1; 0 <= d; d--) {
				var e = c[d];
				if(!e) break;
				b.push(e.clone())
			}
		c = new cc.Animation(b, a.getDelayPerUnit(), a.getLoops());
		c.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
		a = new cc.Animate(c);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	stop: function() {
		this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
		cc.Action.prototype.stop.call(this)
	}
});
cc.animate = function(a) {
	return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
	_action: null,
	_forcedTarget: null,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		c && this.initWithTarget(a, c)
	},
	initWithTarget: function(a, c) {
		return this.initWithDuration(c._duration) ? (this._forcedTarget = a, this._action = c, !0) : !1
	},
	clone: function() {
		var a = new cc.TargetedAction;
		this._cloneDecoration(a);
		a.initWithTarget(this._forcedTarget, this._action.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._action.startWithTarget(this._forcedTarget)
	},
	stop: function() {
		this._action.stop()
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._action.update(a)
	},
	getForcedTarget: function() {
		return this._forcedTarget
	},
	setForcedTarget: function(a) {
		this._forcedTarget !== a && (this._forcedTarget = a)
	}
});
cc.targetedAction = function(a, c) {
	return new cc.TargetedAction(a, c)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
	isDone: function() {
		return !0
	},
	step: function(a) {
		this.update(1)
	},
	update: function(a) {},
	reverse: function() {
		return this.clone()
	},
	clone: function() {
		return new cc.ActionInstant
	}
});
cc.Show = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !0
	},
	reverse: function() {
		return new cc.Hide
	},
	clone: function() {
		return new cc.Show
	}
});
cc.show = function() {
	return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !1
	},
	reverse: function() {
		return new cc.Show
	},
	clone: function() {
		return new cc.Hide
	}
});
cc.hide = function() {
	return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !this.target.visible
	},
	reverse: function() {
		return new cc.ToggleVisibility
	},
	clone: function() {
		return new cc.ToggleVisibility
	}
});
cc.toggleVisibility = function() {
	return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
	_isNeedCleanUp: !0,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && this.init(a)
	},
	update: function(a) {
		this.target.removeFromParent(this._isNeedCleanUp)
	},
	init: function(a) {
		this._isNeedCleanUp = a;
		return !0
	},
	reverse: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	},
	clone: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	}
});
cc.removeSelf = function(a) {
	return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
	_flippedX: !1,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedX = !1;
		void 0 !== a && this.initWithFlipX(a)
	},
	initWithFlipX: function(a) {
		this._flippedX = a;
		return !0
	},
	update: function(a) {
		this.target.flippedX = this._flippedX
	},
	reverse: function() {
		return new cc.FlipX(!this._flippedX)
	},
	clone: function() {
		var a = new cc.FlipX;
		a.initWithFlipX(this._flippedX);
		return a
	}
});
cc.flipX = function(a) {
	return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
	_flippedY: !1,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedY = !1;
		void 0 !== a && this.initWithFlipY(a)
	},
	initWithFlipY: function(a) {
		this._flippedY = a;
		return !0
	},
	update: function(a) {
		this.target.flippedY = this._flippedY
	},
	reverse: function() {
		return new cc.FlipY(!this._flippedY)
	},
	clone: function() {
		var a = new cc.FlipY;
		a.initWithFlipY(this._flippedY);
		return a
	}
});
cc.flipY = function(a) {
	return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
	_x: 0,
	_y: 0,
	ctor: function(a, c) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._y = this._x = 0;
		void 0 !== a && (void 0 !== a.x && (c = a.y, a = a.x), this.initWithPosition(a, c))
	},
	initWithPosition: function(a, c) {
		this._x = a;
		this._y = c;
		return !0
	},
	update: function(a) {
		this.target.setPosition(this._x, this._y)
	},
	clone: function() {
		var a = new cc.Place;
		a.initWithPosition(this._x, this._y);
		return a
	}
});
cc.place = function(a, c) {
	return new cc.Place(a, c)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
	_selectorTarget: null,
	_callFunc: null,
	_function: null,
	_data: null,
	ctor: function(a, c, b) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && (void 0 === c ? this.initWithFunction(a) : this.initWithFunction(a, c, b))
	},
	initWithFunction: function(a, c, b) {
		c ? (this._data = b, this._callFunc = a, this._selectorTarget = c) : a && (this._function = a);
		return !0
	},
	execute: function() {
		null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null,
			this.target)
	},
	update: function(a) {
		this.execute()
	},
	getTargetCallback: function() {
		return this._selectorTarget
	},
	setTargetCallback: function(a) {
		a !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
	},
	clone: function() {
		var a = new cc.CallFunc;
		this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
		return a
	}
});
cc.callFunc = function(a, c, b) {
	return new cc.CallFunc(a, c, b)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
	_centerXOrig: 0,
	_centerYOrig: 0,
	_centerZOrig: 0,
	_eyeXOrig: 0,
	_eyeYOrig: 0,
	_eyeZOrig: 0,
	_upXOrig: 0,
	_upYOrig: 0,
	_upZOrig: 0,
	ctor: function() {
		cc.ActionInterval.prototype.ctor.call(this);
		this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		a = a.getCamera();
		var c = a.getCenter();
		this._centerXOrig = c.x;
		this._centerYOrig = c.y;
		this._centerZOrig = c.z;
		c = a.getEye();
		this._eyeXOrig = c.x;
		this._eyeYOrig = c.y;
		this._eyeZOrig = c.z;
		a = a.getUp();
		this._upXOrig = a.x;
		this._upYOrig = a.y;
		this._upZOrig = a.z
	},
	clone: function() {
		return new cc.ActionCamera
	},
	reverse: function() {
		return new cc.ReverseTime(this)
	}
});
cc.OrbitCamera = cc.ActionCamera.extend({
	_radius: 0,
	_deltaRadius: 0,
	_angleZ: 0,
	_deltaAngleZ: 0,
	_angleX: 0,
	_deltaAngleX: 0,
	_radZ: 0,
	_radDeltaZ: 0,
	_radX: 0,
	_radDeltaX: 0,
	ctor: function(a, c, b, d, e, f, g) {
		cc.ActionCamera.prototype.ctor.call(this);
		void 0 !== g && this.initWithDuration(a, c, b, d, e, f, g)
	},
	initWithDuration: function(a, c, b, d, e, f, g) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = c, this._deltaRadius = b, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = g, this._radDeltaZ =
			cc.degreesToRadians(e), this._radDeltaX = cc.degreesToRadians(g), !0) : !1
	},
	sphericalRadius: function() {
		var a, c;
		c = this.target.getCamera();
		var b = c.getEye();
		a = c.getCenter();
		c = b.x - a.x;
		var d = b.y - a.y;
		a = b.z - a.z;
		var b = Math.sqrt(Math.pow(c, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
			e = Math.sqrt(Math.pow(c, 2) + Math.pow(d, 2));
		0 === e && (e = cc.FLT_EPSILON);
		0 === b && (b = cc.FLT_EPSILON);
		a = Math.acos(a / b);
		c = 0 > c ? Math.PI - Math.asin(d / e) : Math.asin(d / e);
		return {
			newRadius: b / cc.Camera.getZEye(),
			zenith: a,
			azimuth: c
		}
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		a = this.sphericalRadius();
		isNaN(this._radius) && (this._radius = a.newRadius);
		isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
		isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
		this._radZ = cc.degreesToRadians(this._angleZ);
		this._radX = cc.degreesToRadians(this._angleX)
	},
	clone: function() {
		var a = new cc.OrbitCamera;
		a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
		return a
	},
	update: function(a) {
		a =
			this._computeEaseTime(a);
		var c = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
			b = this._radZ + this._radDeltaZ * a,
			d = this._radX + this._radDeltaX * a;
		a = Math.sin(b) * Math.cos(d) * c + this._centerXOrig;
		d = Math.sin(b) * Math.sin(d) * c + this._centerYOrig;
		c = Math.cos(b) * c + this._centerZOrig;
		this.target.getCamera().setEye(a, d, c);
		this.target.setNodeDirty()
	}
});
cc.orbitCamera = function(a, c, b, d, e, f, g) {
	return new cc.OrbitCamera(a, c, b, d, e, f, g)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
	_inner: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if(!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
		return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
	},
	clone: function() {
		var a = new cc.ActionEase;
		a.initWithAction(this._inner.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._inner.startWithTarget(this.target)
	},
	stop: function() {
		this._inner.stop();
		cc.ActionInterval.prototype.stop.call(this)
	},
	update: function(a) {
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.ActionEase(this._inner.reverse())
	},
	getInnerAction: function() {
		return this._inner
	}
});
cc.actionEase = function(a) {
	return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
	_rate: 0,
	ctor: function(a, c) {
		cc.ActionEase.prototype.ctor.call(this);
		void 0 !== c && this.initWithAction(a, c)
	},
	setRate: function(a) {
		this._rate = a
	},
	getRate: function() {
		return this._rate
	},
	initWithAction: function(a, c) {
		return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = c, !0) : !1
	},
	clone: function() {
		var a = new cc.EaseRateAction;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	},
	reverse: function() {
		return new cc.EaseRateAction(this._inner.reverse(),
			1 / this._rate)
	}
});
cc.easeRateAction = function(a, c) {
	return new cc.EaseRateAction(a, c)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
	update: function(a) {
		this._inner.update(Math.pow(a, this._rate))
	},
	reverse: function() {
		return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var a = new cc.EaseIn;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	}
});
cc.EaseIn.create = function(a, c) {
	return new cc.EaseIn(a, c)
};
cc.easeIn = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			return Math.pow(a, this._rate)
		},
		reverse: function() {
			return cc.easeIn(1 / this._rate)
		}
	}
};
cc.EaseOut = cc.EaseRateAction.extend({
	update: function(a) {
		this._inner.update(Math.pow(a, 1 / this._rate))
	},
	reverse: function() {
		return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var a = new cc.EaseOut;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	}
});
cc.EaseOut.create = function(a, c) {
	return new cc.EaseOut(a, c)
};
cc.easeOut = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			return Math.pow(a, 1 / this._rate)
		},
		reverse: function() {
			return cc.easeOut(1 / this._rate)
		}
	}
};
cc.EaseInOut = cc.EaseRateAction.extend({
	update: function(a) {
		a *= 2;
		1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
	},
	clone: function() {
		var a = new cc.EaseInOut;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	},
	reverse: function() {
		return new cc.EaseInOut(this._inner.reverse(), this._rate)
	}
});
cc.EaseInOut.create = function(a, c) {
	return new cc.EaseInOut(a, c)
};
cc.easeInOut = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			a *= 2;
			return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
		},
		reverse: function() {
			return cc.easeInOut(this._rate)
		}
	}
};
cc.EaseExponentialIn = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
	},
	reverse: function() {
		return new cc.EaseExponentialOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialIn.create = function(a) {
	return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
	easing: function(a) {
		return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
	},
	reverse: function() {
		return cc._easeExponentialOutObj
	}
};
cc.easeExponentialIn = function() {
	return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(1 === a ? 1 : -Math.pow(2, -10 * a) + 1)
	},
	reverse: function() {
		return new cc.EaseExponentialIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialOut.create = function(a) {
	return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
	easing: function(a) {
		return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
	},
	reverse: function() {
		return cc._easeExponentialInObj
	}
};
cc.easeExponentialOut = function() {
	return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
	update: function(a) {
		1 !== a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseExponentialInOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialInOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialInOut.create = function(a) {
	return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
	easing: function(a) {
		return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
	},
	reverse: function() {
		return cc._easeExponentialInOutObj
	}
};
cc.easeExponentialInOut = function() {
	return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseSineOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseSineIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseSineIn.create = function(a) {
	return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
	},
	reverse: function() {
		return cc._easeSineOutObj
	}
};
cc.easeSineIn = function() {
	return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseSineIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseSineOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseSineOut.create = function(a) {
	return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2)
	},
	reverse: function() {
		return cc._easeSineInObj
	}
};
cc.easeSineOut = function() {
	return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
		this._inner.update(a)
	},
	clone: function() {
		var a = new cc.EaseSineInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseSineInOut(this._inner.reverse())
	}
});
cc.EaseSineInOut.create = function(a) {
	return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
	},
	reverse: function() {
		return cc._easeSineInOutObj
	}
};
cc.easeSineInOut = function() {
	return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
	_period: 0.3,
	ctor: function(a, c) {
		cc.ActionEase.prototype.ctor.call(this);
		a && this.initWithAction(a, c)
	},
	getPeriod: function() {
		return this._period
	},
	setPeriod: function(a) {
		this._period = a
	},
	initWithAction: function(a, c) {
		cc.ActionEase.prototype.initWithAction.call(this, a);
		this._period = null == c ? 0.3 : c;
		return !0
	},
	reverse: function() {
		cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
		return null
	},
	clone: function() {
		var a = new cc.EaseElastic;
		a.initWithAction(this._inner.clone(),
			this._period);
		return a
	}
});
cc.EaseElastic.create = function(a, c) {
	return new cc.EaseElastic(a, c)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
	update: function(a) {
		var c = 0;
		0 === a || 1 === a ? c = a : (c = this._period / 4, a -= 1, c = -Math.pow(2, 10 * a) * Math.sin((a - c) * Math.PI * 2 / this._period));
		this._inner.update(c)
	},
	reverse: function() {
		return new cc.EaseElasticOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticIn;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticIn.create = function(a, c) {
	return new cc.EaseElasticIn(a, c)
};
cc._easeElasticInObj = {
	easing: function(a) {
		if(0 === a || 1 === a) return a;
		a -= 1;
		return -Math.pow(2, 10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3)
	},
	reverse: function() {
		return cc._easeElasticOutObj
	}
};
cc.easeElasticIn = function(a) {
	return a && 0.3 !== a ? {
		_period: a,
		easing: function(a) {
			if(0 === a || 1 === a) return a;
			a -= 1;
			return -Math.pow(2, 10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period)
		},
		reverse: function() {
			return cc.easeElasticOut(this._period)
		}
	} : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
	update: function(a) {
		var c = 0;
		0 === a || 1 === a ? c = a : (c = this._period / 4, c = Math.pow(2, -10 * a) * Math.sin((a - c) * Math.PI * 2 / this._period) + 1);
		this._inner.update(c)
	},
	reverse: function() {
		return new cc.EaseElasticIn(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticOut;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticOut.create = function(a, c) {
	return new cc.EaseElasticOut(a, c)
};
cc._easeElasticOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3) + 1
	},
	reverse: function() {
		return cc._easeElasticInObj
	}
};
cc.easeElasticOut = function(a) {
	return a && 0.3 !== a ? {
		_period: a,
		easing: function(a) {
			return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period) + 1
		},
		reverse: function() {
			return cc.easeElasticIn(this._period)
		}
	} : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
	update: function(a) {
		var c = 0,
			c = this._period;
		if(0 === a || 1 === a) c = a;
		else {
			c || (c = this._period = 0.3 * 1.5);
			var b = c / 4;
			a = 2 * a - 1;
			c = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - b) * Math.PI * 2 / c) : Math.pow(2, -10 * a) * Math.sin((a - b) * Math.PI * 2 / c) * 0.5 + 1
		}
		this._inner.update(c)
	},
	reverse: function() {
		return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticInOut;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticInOut.create = function(a, c) {
	return new cc.EaseElasticInOut(a, c)
};
cc.easeElasticInOut = function(a) {
	return {
		_period: a || 0.3,
		easing: function(a) {
			var b = 0,
				b = this._period;
			if(0 === a || 1 === a) b = a;
			else {
				b || (b = this._period = 0.3 * 1.5);
				var d = b / 4;
				a = 2 * a - 1;
				b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * Math.PI * 2 / b) : Math.pow(2, -10 * a) * Math.sin((a - d) * Math.PI * 2 / b) * 0.5 + 1
			}
			return b
		},
		reverse: function() {
			return cc.easeElasticInOut(this._period)
		}
	}
};
cc.EaseBounce = cc.ActionEase.extend({
	bounceTime: function(a) {
		if(a < 1 / 2.75) return 7.5625 * a * a;
		if(a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
		if(a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
		a -= 2.625 / 2.75;
		return 7.5625 * a * a + 0.984375
	},
	clone: function() {
		var a = new cc.EaseBounce;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBounce(this._inner.reverse())
	}
});
cc.EaseBounce.create = function(a) {
	return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
	update: function(a) {
		a = 1 - this.bounceTime(1 - a);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseBounceOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBounceIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBounceIn.create = function(a) {
	return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
	if(a < 1 / 2.75) return 7.5625 * a * a;
	if(a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
	if(a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
	a -= 2.625 / 2.75;
	return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
	easing: function(a) {
		return 1 - cc._bounceTime(1 - a)
	},
	reverse: function() {
		return cc._easeBounceOutObj
	}
};
cc.easeBounceIn = function() {
	return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
	update: function(a) {
		a = this.bounceTime(a);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseBounceIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBounceOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBounceOut.create = function(a) {
	return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
	easing: function(a) {
		return cc._bounceTime(a)
	},
	reverse: function() {
		return cc._easeBounceInObj
	}
};
cc.easeBounceOut = function() {
	return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
	update: function(a) {
		var c = 0,
			c = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
		this._inner.update(c)
	},
	clone: function() {
		var a = new cc.EaseBounceInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBounceInOut(this._inner.reverse())
	}
});
cc.EaseBounceInOut.create = function(a) {
	return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
	easing: function(a) {
		return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
	},
	reverse: function() {
		return cc._easeBounceInOutObj
	}
};
cc.easeBounceInOut = function() {
	return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158))
	},
	reverse: function() {
		return new cc.EaseBackOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBackIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBackIn.create = function(a) {
	return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
	},
	reverse: function() {
		return cc._easeBackOutObj
	}
};
cc.easeBackIn = function() {
	return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
	update: function(a) {
		a -= 1;
		this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
	},
	reverse: function() {
		return new cc.EaseBackIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBackOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBackOut.create = function(a) {
	return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
	easing: function(a) {
		a -= 1;
		return a * a * (2.70158 * a + 1.70158) + 1
	},
	reverse: function() {
		return cc._easeBackInObj
	}
};
cc.easeBackOut = function() {
	return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
	update: function(a) {
		a *= 2;
		1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
	},
	clone: function() {
		var a = new cc.EaseBackInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBackInOut(this._inner.reverse())
	}
});
cc.EaseBackInOut.create = function(a) {
	return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
	easing: function(a) {
		a *= 2;
		if(1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
		a -= 2;
		return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
	},
	reverse: function() {
		return cc._easeBackInOutObj
	}
};
cc.easeBackInOut = function() {
	return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
	_p0: null,
	_p1: null,
	_p2: null,
	_p3: null,
	ctor: function(a) {
		cc.ActionEase.prototype.ctor.call(this, a)
	},
	_updateTime: function(a, c, b, d, e) {
		return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * c + 3 * Math.pow(e, 2) * (1 - e) * b + Math.pow(e, 3) * d
	},
	update: function(a) {
		a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
		this._inner.update(a)
	},
	clone: function() {
		var a = new cc.EaseBezierAction;
		a.initWithAction(this._inner.clone());
		a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
		return a
	},
	reverse: function() {
		var a = new cc.EaseBezierAction(this._inner.reverse());
		a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
		return a
	},
	setBezierParamer: function(a, c, b, d) {
		this._p0 = a || 0;
		this._p1 = c || 0;
		this._p2 = b || 0;
		this._p3 = d || 0
	}
});
cc.EaseBezierAction.create = function(a) {
	return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, c, b, d) {
	return {
		easing: function(e) {
			return cc.EaseBezierAction.prototype._updateTime(a, c, b, d, e)
		},
		reverse: function() {
			return cc.easeBezierAction(d, b, c, a)
		}
	}
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return Math.pow(a, 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionIn(this._inner.reverse())
	}
});
cc.EaseQuadraticActionIn.create = function(a) {
	return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
	easing: cc.EaseQuadraticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionIn
	}
};
cc.easeQuadraticActionIn = function() {
	return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		return -a * (a - 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionOut;
		a.initWithAction();
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionOut.create = function(a) {
	return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
	easing: cc.EaseQuadraticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionOut
	}
};
cc.easeQuadraticActionOut = function() {
	return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		var c = a;
		a *= 2;
		1 > a ? c = a * a * 0.5 : (--a, c = -0.5 * (a * (a - 2) - 1));
		return c
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionInOut.create = function(a) {
	return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
	easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionInOut
	}
};
cc.easeQuadraticActionInOut = function() {
	return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionIn(this._inner.reverse())
	}
});
cc.EaseQuarticActionIn.create = function(a) {
	return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
	easing: cc.EaseQuarticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionIn
	}
};
cc.easeQuarticActionIn = function() {
	return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return -(a * a * a * a - 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionOut.create = function(a) {
	return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
	easing: cc.EaseQuarticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionOut
	}
};
cc.easeQuarticActionOut = function() {
	return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if(1 > a) return 0.5 * a * a * a * a;
		a -= 2;
		return -0.5 * (a * a * a * a - 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionInOut.create = function(a) {
	return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
	easing: cc.EaseQuarticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionInOut
	}
};
cc.easeQuarticActionInOut = function() {
	return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionIn(this._inner.reverse())
	}
});
cc.EaseQuinticActionIn.create = function(a) {
	return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
	easing: cc.EaseQuinticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionIn
	}
};
cc.easeQuinticActionIn = function() {
	return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return a * a * a * a * a + 1
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionOut.create = function(a) {
	return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
	easing: cc.EaseQuinticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionOut
	}
};
cc.easeQuinticActionOut = function() {
	return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if(1 > a) return 0.5 * a * a * a * a * a;
		a -= 2;
		return 0.5 * (a * a * a * a * a + 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionInOut.create = function(a) {
	return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
	easing: cc.EaseQuinticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionInOut
	}
};
cc.easeQuinticActionInOut = function() {
	return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return -1 * (Math.sqrt(1 - a * a) - 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionIn(this._inner.reverse())
	}
});
cc.EaseCircleActionIn.create = function(a) {
	return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
	easing: cc.EaseCircleActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionIn
	}
};
cc.easeCircleActionIn = function() {
	return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return Math.sqrt(1 - a * a)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionOut(this._inner.reverse())
	}
});
cc.EaseCircleActionOut.create = function(a) {
	return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
	easing: cc.EaseCircleActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionOut
	}
};
cc.easeCircleActionOut = function() {
	return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if(1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
		a -= 2;
		return 0.5 * (Math.sqrt(1 - a * a) + 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionInOut(this._inner.reverse())
	}
});
cc.EaseCircleActionInOut.create = function(a) {
	return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
	easing: cc.EaseCircleActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionInOut
	}
};
cc.easeCircleActionInOut = function() {
	return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCubicActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionIn(this._inner.reverse())
	}
});
cc.EaseCubicActionIn.create = function(a) {
	return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
	easing: cc.EaseCubicActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionIn
	}
};
cc.easeCubicActionIn = function() {
	return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return a * a * a + 1
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCubicActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionOut(this._inner.reverse())
	}
});
cc.EaseCubicActionOut.create = function(a) {
	return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
	easing: cc.EaseCubicActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionOut
	}
};
cc.easeCubicActionOut = function() {
	return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if(1 > a) return 0.5 * a * a * a;
		a -= 2;
		return 0.5 * (a * a * a + 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCubicActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionInOut(this._inner.reverse())
	}
});
cc.EaseCubicActionInOut.create = function(a) {
	return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
	easing: cc.EaseCubicActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionInOut
	}
};
cc.easeCubicActionInOut = function() {
	return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, c, b, d, e, f) {
	var g = f * f,
		h = g * f,
		k = (1 - e) / 2;
	e = k * (-h + 2 * g - f);
	var m = k * (-h + g) + (2 * h - 3 * g + 1);
	f = k * (h - 2 * g + f) + (-2 * h + 3 * g);
	g = k * (h - g);
	return cc.p(a.x * e + c.x * m + b.x * f + d.x * g, a.y * e + c.y * m + b.y * f + d.y * g)
};
cc.reverseControlPoints = function(a) {
	for(var c = [], b = a.length - 1; 0 <= b; b--) c.push(cc.p(a[b].x, a[b].y));
	return c
};
cc.cloneControlPoints = function(a) {
	for(var c = [], b = 0; b < a.length; b++) c.push(cc.p(a[b].x, a[b].y));
	return c
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(a, c) {
	var b = Math.min(a.length - 1, Math.max(c, 0));
	return a[b]
};
cc.reverseControlPointsInline = function(a) {
	for(var c = a.length, b = 0 | c / 2, d = 0; d < b; ++d) {
		var e = a[d];
		a[d] = a[c - d - 1];
		a[c - d - 1] = e
	}
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
	_points: null,
	_deltaT: 0,
	_tension: 0,
	_previousPosition: null,
	_accumulatedDiff: null,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._points = [];
		void 0 !== b && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		if(!c || 0 === c.length) throw "Invalid configuration. It must at least have one control point";
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(c), this._tension = b, !0) : !1
	},
	clone: function() {
		var a =
			new cc.CardinalSplineTo;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._deltaT = 1 / (this._points.length - 1);
		this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
		this._accumulatedDiff = cc.p(0, 0)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var c, b = this._points;
		if(1 === a) c = b.length - 1, a = 1;
		else {
			var d = this._deltaT;
			c = 0 | a / d;
			a = (a - d * c) / d
		}
		c = cc.cardinalSplineAt(cc.getControlPointAt(b,
			c - 1), cc.getControlPointAt(b, c - 0), cc.getControlPointAt(b, c + 1), cc.getControlPointAt(b, c + 2), this._tension, a);
		cc.ENABLE_STACKABLE_ACTIONS && (b = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 !== b || 0 !== a) && (d = this._accumulatedDiff, b = d.x + b, a = d.y + a, d.x = b, d.y = a, c.x += b, c.y += a);
		this.updatePosition(c)
	},
	reverse: function() {
		var a = cc.reverseControlPoints(this._points);
		return cc.cardinalSplineTo(this._duration, a, this._tension)
	},
	updatePosition: function(a) {
		this.target.setPosition(a);
		this._previousPosition = a
	},
	getPoints: function() {
		return this._points
	},
	setPoints: function(a) {
		this._points = a
	}
});
cc.cardinalSplineTo = function(a, c, b) {
	return new cc.CardinalSplineTo(a, c, b)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
	_startPosition: null,
	ctor: function(a, c, b) {
		cc.CardinalSplineTo.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		void 0 !== b && this.initWithDuration(a, c, b)
	},
	startWithTarget: function(a) {
		cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
		this._startPosition.x = a.getPositionX();
		this._startPosition.y = a.getPositionY()
	},
	reverse: function() {
		for(var a = this._points.slice(), c, b = a[0], d = 1; d < a.length; ++d) c = a[d], a[d] = cc.pSub(c, b), b = c;
		a = cc.reverseControlPoints(a);
		b = a[a.length - 1];
		a.pop();
		b.x = -b.x;
		b.y = -b.y;
		a.unshift(b);
		for(d = 1; d < a.length; ++d) c = a[d], c.x = -c.x, c.y = -c.y, c.x += b.x, c.y += b.y, b = a[d] = c;
		return cc.cardinalSplineBy(this._duration, a, this._tension)
	},
	updatePosition: function(a) {
		var c = this._startPosition,
			b = a.x + c.x;
		a = a.y + c.y;
		this._previousPosition.x = b;
		this._previousPosition.y = a;
		this.target.setPosition(b, a)
	},
	clone: function() {
		var a = new cc.CardinalSplineBy;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return a
	}
});
cc.cardinalSplineBy = function(a, c, b) {
	return new cc.CardinalSplineBy(a, c, b)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
	ctor: function(a, c) {
		c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, c, 0.5)
	},
	clone: function() {
		var a = new cc.CatmullRomTo;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return a
	}
});
cc.catmullRomTo = function(a, c) {
	return new cc.CatmullRomTo(a, c)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
	ctor: function(a, c) {
		cc.CardinalSplineBy.prototype.ctor.call(this);
		c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, c, 0.5)
	},
	clone: function() {
		var a = new cc.CatmullRomBy;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return a
	}
});
cc.catmullRomBy = function(a, c) {
	return new cc.CatmullRomBy(a, c)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
	updateTweenAction: function(a, c) {}
});
cc.ActionTween = cc.ActionInterval.extend({
	key: "",
	from: 0,
	to: 0,
	delta: 0,
	ctor: function(a, c, b, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		this.key = "";
		void 0 !== d && this.initWithDuration(a, c, b, d)
	},
	initWithDuration: function(a, c, b, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = c, this.to = d, this.from = b, !0) : !1
	},
	startWithTarget: function(a) {
		if(!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		this.delta = this.to - this.from
	},
	update: function(a) {
		this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
	},
	reverse: function() {
		return new cc.ActionTween(this.duration, this.key, this.to, this.from)
	},
	clone: function() {
		var a = new cc.ActionTween;
		a.initWithDuration(this._duration, this.key, this.from, this.to);
		return a
	}
});
cc.actionTween = function(a, c, b, d) {
	return new cc.ActionTween(a, c, b, d)
};
cc.ActionTween.create = cc.actionTween;
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
	_enabled: !1,
	_target: null,
	_callback: null,
	_isSelected: !1,
	_className: "MenuItem",
	ctor: function(a, c) {
		var b = cc.Node.prototype;
		b.ctor.call(this);
		this._callback = this._target = null;
		this._enabled = this._isSelected = !1;
		b.setAnchorPoint.call(this, 0.5, 0.5);
		this._target = c || null;
		if(this._callback = a || null) this._enabled = !0
	},
	isSelected: function() {
		return this._isSelected
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	setTarget: function(a, c) {
		this._target = c;
		this._callback =
			a
	},
	isEnabled: function() {
		return this._enabled
	},
	setEnabled: function(a) {
		this._enabled = a
	},
	initWithCallback: function(a, c) {
		this.anchorY = this.anchorX = 0.5;
		this._target = c;
		this._callback = a;
		this._enabled = !0;
		this._isSelected = !1;
		return !0
	},
	rect: function() {
		var a = this._position,
			c = this._contentSize,
			b = this._anchorPoint;
		return cc.rect(a.x - c.width * b.x, a.y - c.height * b.y, c.width, c.height)
	},
	selected: function() {
		this._isSelected = !0
	},
	unselected: function() {
		this._isSelected = !1
	},
	setCallback: function(a, c) {
		this._target = c;
		this._callback =
			a
	},
	activate: function() {
		if(this._enabled) {
			var a = this._target,
				c = this._callback;
			if(c)
				if(a && cc.isString(c)) a[c](this);
				else a && cc.isFunction(c) ? c.call(a, this) : c(this)
		}
	}
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, c) {
	return new cc.MenuItem(a, c)
};
cc.MenuItemLabel = cc.MenuItem.extend({
	_disabledColor: null,
	_label: null,
	_originalScale: 0,
	_colorBackup: null,
	ctor: function(a, c, b) {
		cc.MenuItem.prototype.ctor.call(this, c, b);
		this._colorBackup = this._label = this._disabledColor = null;
		a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0))
	},
	getDisabledColor: function() {
		return this._disabledColor
	},
	setDisabledColor: function(a) {
		this._disabledColor =
			a
	},
	getLabel: function() {
		return this._label
	},
	setLabel: function(a) {
		a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height, a.setCascadeColorEnabled(!0));
		this._label && this.removeChild(this._label, !0);
		this._label = a
	},
	setEnabled: function(a) {
		this._enabled !== a && (a ? this.setColor(this._colorBackup) : (this._colorBackup = this.color, this.setColor(this._disabledColor)));
		cc.MenuItem.prototype.setEnabled.call(this, a)
	},
	initWithLabel: function(a, c, b) {
		this.initWithCallback(c, b);
		this._originalScale =
			1;
		this._colorBackup = cc.color.WHITE;
		this._disabledColor = cc.color(126, 126, 126);
		this.setLabel(a);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	setString: function(a) {
		this._label.string = a;
		this.width = this._label.width;
		this.height = this._label.height
	},
	getString: function() {
		return this._label.string
	},
	activate: function() {
		this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
	},
	selected: function() {
		if(this._enabled) {
			cc.MenuItem.prototype.selected.call(this);
			var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
			a ? this.stopAction(a) : this._originalScale = this.scale;
			a = cc.scaleTo(0.1, 1.2 * this._originalScale);
			a.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(a)
		}
	},
	unselected: function() {
		if(this._enabled) {
			cc.MenuItem.prototype.unselected.call(this);
			this.stopActionByTag(cc.ZOOM_ACTION_TAG);
			var a = cc.scaleTo(0.1, this._originalScale);
			a.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(a)
		}
	}
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, c, b) {
	return new cc.MenuItemLabel(a, c, b)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
	ctor: function(a, c, b, d, e, f, g) {
		var h;
		a && 0 < a.length && (h = new cc.LabelAtlas(a, c, b, d, e));
		cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
	},
	initWithString: function(a, c, b, d, e, f, g) {
		if(!a || 0 === a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
		var h = new cc.LabelAtlas;
		h.initWithString(a, c, b, d, e);
		this.initWithLabel(h, f, g);
		return !0
	}
});
cc.MenuItemAtlasFont.create = function(a, c, b, d, e, f, g) {
	return new cc.MenuItemAtlasFont(a, c, b, d, e, f, g)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
	_fontSize: null,
	_fontName: null,
	ctor: function(a, c, b) {
		var d;
		a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
		cc.MenuItemLabel.prototype.ctor.call(this, d, c, b)
	},
	initWithString: function(a, c, b) {
		if(!a || 0 === a.length) throw "Value should be non-null and its length should be greater than 0";
		this._fontName = cc._globalFontName;
		this._fontSize = cc._globalFontSize;
		a = new cc.LabelTTF(a, this._fontName, this._fontSize);
		this.initWithLabel(a, c, b);
		return !0
	},
	setFontSize: function(a) {
		this._fontSize = a;
		this._recreateLabel()
	},
	getFontSize: function() {
		return this._fontSize
	},
	setFontName: function(a) {
		this._fontName = a;
		this._recreateLabel()
	},
	getFontName: function() {
		return this._fontName
	},
	_recreateLabel: function() {
		var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
		this.setLabel(a)
	}
});
cc.MenuItemFont.setFontSize = function(a) {
	cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
	return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
	cc._globalFontNameRelease && (cc._globalFontName = "");
	cc._globalFontName = a;
	cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
	return cc._globalFontName
};
cc.MenuItemFont.create = function(a, c, b) {
	return new cc.MenuItemFont(a, c, b)
};
cc.MenuItemSprite = cc.MenuItem.extend({
	_normalImage: null,
	_selectedImage: null,
	_disabledImage: null,
	ctor: function(a, c, b, d, e) {
		cc.MenuItem.prototype.ctor.call(this);
		this._disabledImage = this._selectedImage = this._normalImage = null;
		if(void 0 !== c) {
			var f, g, h;
			void 0 !== e ? (f = b, h = d, g = e) : void 0 !== d && cc.isFunction(d) ? (f = b, h = d) : void 0 !== d && cc.isFunction(b) ? (g = d, h = b, f = null) : void 0 === b && (f = null);
			this.initWithNormalSprite(a, c, f, h, g)
		}
	},
	getNormalImage: function() {
		return this._normalImage
	},
	setNormalImage: function(a) {
		this._normalImage !==
			a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
				this.width = a.width;
				this.height = a.height
			}, this))
	},
	getSelectedImage: function() {
		return this._selectedImage
	},
	setSelectedImage: function(a) {
		this._selectedImage !== a && (a && (this.addChild(a,
			0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
	},
	getDisabledImage: function() {
		return this._disabledImage
	},
	setDisabledImage: function(a) {
		this._disabledImage !== a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
	},
	initWithNormalSprite: function(a, c, b, d, e) {
		this.initWithCallback(d,
			e);
		this.setNormalImage(a);
		this.setSelectedImage(c);
		this.setDisabledImage(b);
		if(a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
			this.width = a.width;
			this.height = a.height;
			this.setCascadeColorEnabled(!0);
			this.setCascadeOpacityEnabled(!0)
		}, this);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this._normalImage && (this._disabledImage &&
			(this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
	},
	setEnabled: function(a) {
		this._enabled !== a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
	},
	_updateImagesVisibility: function() {
		var a =
			this._normalImage,
			c = this._selectedImage,
			b = this._disabledImage;
		this._enabled ? (a && (a.visible = !0), c && (c.visible = !1), b && (b.visible = !1)) : b ? (a && (a.visible = !1), c && (c.visible = !1), b && (b.visible = !0)) : (a && (a.visible = !0), c && (c.visible = !1))
	}
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, c, b, d, e) {
	return new cc.MenuItemSprite(a, c, b, d, e || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
	ctor: function(a, c, b, d, e) {
		var f = null,
			g = null,
			h = null,
			k = null,
			m = null;
		void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = new cc.Sprite(a), c && (g = new cc.Sprite(c)), void 0 === d ? k = b : void 0 === e ? (k = b, m = d) : e && (h = new cc.Sprite(b), k = d, m = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, k, m))
	},
	setNormalSpriteFrame: function(a) {
		this.setNormalImage(new cc.Sprite(a))
	},
	setSelectedSpriteFrame: function(a) {
		this.setSelectedImage(new cc.Sprite(a))
	},
	setDisabledSpriteFrame: function(a) {
		this.setDisabledImage(new cc.Sprite(a))
	},
	initWithNormalImage: function(a, c, b, d, e) {
		var f = null,
			g = null,
			h = null;
		a && (f = new cc.Sprite(a));
		c && (g = new cc.Sprite(c));
		b && (h = new cc.Sprite(b));
		return this.initWithNormalSprite(f, g, h, d, e)
	}
});
cc.MenuItemImage.create = function(a, c, b, d, e) {
	return new cc.MenuItemImage(a, c, b, d, e)
};
cc.MenuItemToggle = cc.MenuItem.extend({
	subItems: null,
	_selectedIndex: 0,
	_opacity: null,
	_color: null,
	ctor: function() {
		cc.MenuItem.prototype.ctor.call(this);
		this._selectedIndex = 0;
		this.subItems = [];
		this._opacity = 0;
		this._color = cc.color.WHITE;
		0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
	},
	getOpacity: function() {
		return this._opacity
	},
	setOpacity: function(a) {
		this._opacity = a;
		if(this.subItems && 0 < this.subItems.length)
			for(var c = 0; c < this.subItems.length; c++) this.subItems[c].opacity = a;
		this._color.a = a
	},
	getColor: function() {
		var a = this._color;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	setColor: function(a) {
		var c = this._color;
		c.r = a.r;
		c.g = a.g;
		c.b = a.b;
		if(this.subItems && 0 < this.subItems.length)
			for(c = 0; c < this.subItems.length; c++) this.subItems[c].setColor(a);
		void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
	},
	getSelectedIndex: function() {
		return this._selectedIndex
	},
	setSelectedIndex: function(a) {
		if(a !== this._selectedIndex) {
			this._selectedIndex = a;
			(a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
			a = this.subItems[this._selectedIndex];
			this.addChild(a, 0, cc.CURRENT_ITEM);
			var c = a.width,
				b = a.height;
			this.width = c;
			this.height = b;
			a.setPosition(c / 2, b / 2)
		}
	},
	getSubItems: function() {
		return this.subItems
	},
	setSubItems: function(a) {
		this.subItems = a
	},
	initWithItems: function(a) {
		var c = a.length;
		cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), c -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), c -= 1) : this.initWithCallback(null, null);
		for(var b = this.subItems, d = b.length =
				0; d < c; d++) a[d] && b.push(a[d]);
		this._selectedIndex = cc.UINT_MAX;
		this.setSelectedIndex(0);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	addSubItem: function(a) {
		this.subItems.push(a)
	},
	activate: function() {
		this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
		cc.MenuItem.prototype.activate.call(this)
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this.subItems[this._selectedIndex].selected()
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this.subItems[this._selectedIndex].unselected()
	},
	setEnabled: function(a) {
		if(this._enabled !== a) {
			cc.MenuItem.prototype.setEnabled.call(this, a);
			var c = this.subItems;
			if(c && 0 < c.length)
				for(var b = 0; b < c.length; b++) c[b].enabled = a
		}
	},
	selectedItem: function() {
		return this.subItems[this._selectedIndex]
	},
	getSelectedItem: function() {
		return this.subItems[this._selectedIndex]
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.setSelectedIndex(this._selectedIndex)
	}
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
	0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	var a = new cc.MenuItemToggle;
	a.initWithItems(Array.prototype.slice.apply(arguments));
	return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
	enabled: !1,
	_selectedItem: null,
	_state: -1,
	_touchListener: null,
	_className: "Menu",
	ctor: function(a) {
		cc.Layer.prototype.ctor.call(this);
		this._color = cc.color.WHITE;
		this.enabled = !1;
		this._opacity = 255;
		this._selectedItem = null;
		this._state = -1;
		this._touchListener = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this._onTouchBegan,
			onTouchMoved: this._onTouchMoved,
			onTouchEnded: this._onTouchEnded,
			onTouchCancelled: this._onTouchCancelled
		});
		0 < arguments.length &&
			null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var c = arguments.length,
			b;
		if(0 === c) b = [];
		else if(1 === c) b = a instanceof Array ? a : [a];
		else if(1 < c) {
			b = [];
			for(var d = 0; d < c; d++) arguments[d] && b.push(arguments[d])
		}
		this.initWithArray(b)
	},
	onEnter: function() {
		var a = this._touchListener;
		a._isRegistered() || cc.eventManager.addListener(a, this);
		cc.Node.prototype.onEnter.call(this)
	},
	isEnabled: function() {
		return this.enabled
	},
	setEnabled: function(a) {
		this.enabled = a
	},
	initWithItems: function(a) {
		var c = [];
		if(a)
			for(var b = 0; b < a.length; b++) a[b] && c.push(a[b]);
		return this.initWithArray(c)
	},
	initWithArray: function(a) {
		if(cc.Layer.prototype.init.call(this)) {
			this.enabled = !0;
			var c = cc.winSize;
			this.setPosition(c.width / 2, c.height / 2);
			this.setContentSize(c);
			this.setAnchorPoint(0.5, 0.5);
			this.ignoreAnchorPointForPosition(!0);
			if(a)
				for(c = 0; c < a.length; c++) this.addChild(a[c], c);
			this._selectedItem = null;
			this._state = cc.MENU_STATE_WAITING;
			return this.cascadeOpacity = this.cascadeColor = !0
		}
		return !1
	},
	addChild: function(a, c, b) {
		if(!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
		cc.Layer.prototype.addChild.call(this, a, c, b)
	},
	alignItemsVertically: function() {
		this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsVerticallyWithPadding: function(a) {
		var c = -a,
			b = this._children,
			d, e, f, g;
		if(b && 0 < b.length) {
			e = 0;
			for(d = b.length; e < d; e++) c += b[e].height * b[e].scaleY + a;
			var h = c / 2;
			e = 0;
			for(d = b.length; e < d; e++) g = b[e], f = g.height, c = g.scaleY, g.setPosition(0, h - f * c / 2), h -= f * c + a
		}
	},
	alignItemsHorizontally: function() {
		this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsHorizontallyWithPadding: function(a) {
		var c = -a,
			b = this._children,
			d, e, f, g;
		if(b && 0 < b.length) {
			d = 0;
			for(e = b.length; d < e; d++) c += b[d].width * b[d].scaleX + a;
			var h = -c / 2;
			d = 0;
			for(e = b.length; d < e; d++) g = b[d], c = g.scaleX, f = b[d].width, g.setPosition(h + f * c / 2, 0), h += f * c + a
		}
	},
	alignItemsInColumns: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		for(var a = [], c = 0; c < arguments.length; c++) a.push(arguments[c]);
		var b = -5,
			d = 0,
			e = 0,
			f = 0,
			g, h, k, m =
			this._children;
		if(m && 0 < m.length)
			for(c = 0, k = m.length; c < k; c++) d >= a.length || !(g = a[d]) || (h = m[c].height, e = e >= h || isNaN(h) ? e : h, ++f, f >= g && (b += e + 5, e = f = 0, ++d));
		var n = cc.director.getWinSize(),
			p = g = e = d = 0,
			s = 0,
			b = b / 2;
		if(m && 0 < m.length)
			for(c = 0, k = m.length; c < k; c++) {
				var q = m[c];
				0 === g && (g = a[d], s = p = n.width / (1 + g));
				h = q._getHeight();
				e = e >= h || isNaN(h) ? e : h;
				q.setPosition(s - n.width / 2, b - h / 2);
				s += p;
				++f;
				f >= g && (b -= e + 5, e = g = f = 0, ++d)
			}
	},
	alignItemsInRows: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var a = [],
			c;
		for(c = 0; c < arguments.length; c++) a.push(arguments[c]);
		var b = [],
			d = [],
			e = -10,
			f = -5,
			g = 0,
			h = 0,
			k = 0,
			m, n, p, s, q = this._children;
		if(q && 0 < q.length)
			for(c = 0, p = q.length; c < p; c++)(n = q[c], g >= a.length || !(m = a[g])) || (s = n.width, h = h >= s || isNaN(s) ? h : s, f += n.height + 5, ++k, k >= m && (b.push(h), d.push(f), e += h + 10, h = k = 0, f = -5, ++g));
		f = cc.director.getWinSize();
		m = h = g = 0;
		var e = -e / 2,
			t = 0;
		if(q && 0 < q.length)
			for(c = 0, p = q.length; c < p; c++) n = q[c], 0 === m && (m = a[g], t = d[g]), s = n._getWidth(), h = h >= s || isNaN(s) ? h : s, n.setPosition(e + b[g] / 2, t - f.height / 2),
				t -= n.height + 10, ++k, k >= m && (e += h + 5, h = m = k = 0, ++g)
	},
	removeChild: function(a, c) {
		null != a && (a instanceof cc.MenuItem ? (this._selectedItem === a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, c)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
	},
	_onTouchBegan: function(a, c) {
		var b = c.getCurrentTarget();
		if(b._state !== cc.MENU_STATE_WAITING || !b._visible || !b.enabled) return !1;
		for(var d = b.parent; null != d; d = d.parent)
			if(!d.isVisible()) return !1;
		b._selectedItem = b._itemForTouch(a);
		return b._selectedItem ? (b._state = cc.MENU_STATE_TRACKING_TOUCH, b._selectedItem.selected(), b._selectedItem.setNodeDirty(), !0) : !1
	},
	_onTouchEnded: function(a, c) {
		var b = c.getCurrentTarget();
		b._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (b._selectedItem && (b._selectedItem.unselected(), b._selectedItem.setNodeDirty(), b._selectedItem.activate()), b._state = cc.MENU_STATE_WAITING)
	},
	_onTouchCancelled: function(a, c) {
		var b = c.getCurrentTarget();
		b._state !== cc.MENU_STATE_TRACKING_TOUCH ?
			cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && (b._selectedItem.unselected(), b._selectedItem.setNodeDirty()), b._state = cc.MENU_STATE_WAITING)
	},
	_onTouchMoved: function(a, c) {
		var b = c.getCurrentTarget();
		if(b._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
		else {
			var d = b._itemForTouch(a);
			d !== b._selectedItem && (b._selectedItem && (b._selectedItem.unselected(), b._selectedItem.setNodeDirty()), b._selectedItem = d, b._selectedItem && (b._selectedItem.selected(),
				b._selectedItem.setNodeDirty()))
		}
	},
	onExit: function() {
		this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
		cc.Node.prototype.onExit.call(this)
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_itemForTouch: function(a) {
		a = a.getLocation();
		var c = this._children,
			b;
		if(c && 0 < c.length)
			for(var d = c.length - 1; 0 <= d; d--)
				if(b = c[d], b.isVisible() && b.isEnabled()) {
					var e = b.convertToNodeSpace(a),
						f = b.rect();
					f.x = 0;
					f.y = 0;
					if(cc.rectContainsPoint(f, e)) return b
				}
		return null
	}
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
	var c = arguments.length;
	0 < c && null == arguments[c - 1] && cc.log("parameters should not be ending with null in Javascript");
	return 0 === c ? new cc.Menu : 1 === c ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.ProgressTimer = cc.Node.extend({
	_type: null,
	_percentage: 0,
	_sprite: null,
	_midPoint: null,
	_barChangeRate: null,
	_reverseDirection: !1,
	_className: "ProgressTimer",
	ctor: function(a) {
		cc.Node.prototype.ctor.call(this);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._percentage = 0;
		this._midPoint = cc.p(0, 0);
		this._barChangeRate = cc.p(0, 0);
		this._reverseDirection = !1;
		this._sprite = null;
		a && this.initWithSprite(a)
	},
	getMidpoint: function() {
		return cc.p(this._midPoint.x, this._midPoint.y)
	},
	setMidpoint: function(a) {
		this._midPoint = cc.pClamp(a,
			cc.p(0, 0), cc.p(1, 1))
	},
	getBarChangeRate: function() {
		return cc.p(this._barChangeRate.x, this._barChangeRate.y)
	},
	setBarChangeRate: function(a) {
		this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
	},
	getType: function() {
		return this._type
	},
	getPercentage: function() {
		return this._percentage
	},
	getSprite: function() {
		return this._sprite
	},
	setPercentage: function(a) {
		this._percentage !== a && (this._percentage = cc.clampf(a, 0, 100), this._renderCmd._updateProgress())
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	isReverseDirection: function() {
		return this._reverseDirection
	},
	setColor: function(a) {
		this._sprite.color = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setOpacity: function(a) {
		this._sprite.opacity = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getColor: function() {
		return this._sprite.color
	},
	getOpacity: function() {
		return this._sprite.opacity
	},
	setReverseProgress: function(a) {
		this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
	},
	setSprite: function(a) {
		this._sprite !==
			a && ((this._sprite = a) ? this.setContentSize(a.width, a.height) : this.setContentSize(0, 0), this._renderCmd.releaseData())
	},
	setType: function(a) {
		a !== this._type && (this._type = a, this._renderCmd.releaseData())
	},
	setReverseDirection: function(a) {
		this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
	},
	initWithSprite: function(a) {
		this.percentage = 0;
		this.setAnchorPoint(0.5, 0.5);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._reverseDirection = !1;
		this.midPoint = cc.p(0.5, 0.5);
		this.barChangeRate =
			cc.p(1, 1);
		this.setSprite(a);
		this._renderCmd.initCmd();
		return !0
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
	}
});
_p = cc.ProgressTimer.prototype;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(a) {
	return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(a, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== c && this.initWithDuration(a, c)
	},
	initWithDuration: function(a, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, !0) : !1
	},
	clone: function() {
		var a = new cc.ProgressTo;
		a.initWithDuration(this._duration, this._to);
		return a
	},
	reverse: function() {
		cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
		return null
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this,
			a);
		this._from = a.percentage
	},
	update: function(a) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
	}
});
cc.progressTo = function(a, c) {
	return new cc.ProgressTo(a, c)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(a, c, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== b && this.initWithDuration(a, c, b)
	},
	initWithDuration: function(a, c, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, this._from = c, !0) : !1
	},
	clone: function() {
		var a = new cc.ProgressFromTo;
		a.initWithDuration(this._duration, this._from, this._to);
		return a
	},
	reverse: function() {
		return cc.progressFromTo(this._duration, this._to, this._from)
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a)
	},
	update: function(a) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
	}
});
cc.progressFromTo = function(a, c, b) {
	return new cc.ProgressFromTo(a, c, b)
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function() {
	cc.ProgressTimer.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._PI180 = Math.PI / 180;
		this._barRect = cc.rect(0, 0, 0, 0);
		this._origin = cc.p(0, 0);
		this._radius = 0;
		this._endAngle = this._startAngle = 270;
		this._counterClockWise = !1
	};
	var a = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ProgressTimer.CanvasRenderCmd;
	a.rendering = function(a, b, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			g = f._sprite,
			h = g._renderCmd._textureCoord,
			k = g._renderCmd._displayedOpacity / 255;
		if(0 !== h.width && 0 !== h.height && g._texture && h.validRect && 0 !== k) {
			a.setTransform(this._worldTransform, b, d);
			a.setCompositeOperation(g._blendFuncStr);
			a.setGlobalAlpha(k);
			var m = g._rect,
				n = g._offsetPosition,
				k = n.x,
				p = -n.y - m.height,
				s = m.width,
				m = m.height;
			a.save();
			g._flippedX && (k = -k - s, e.scale(-1, 1));
			g._flippedY && (p = n.y, e.scale(1, -1));
			f._type === cc.ProgressTimer.TYPE_BAR ? (f = this._barRect, e.beginPath(), e.rect(f.x * b, f.y * d, f.width * b, f.height * d), e.clip(),
				e.closePath()) : f._type === cc.ProgressTimer.TYPE_RADIAL && (f = this._origin.x * b, n = this._origin.y * d, e.beginPath(), e.arc(f, n, this._radius * d, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), e.lineTo(f, n), e.clip(), e.closePath());
			f = g._texture.getHtmlElementObj();
			g._renderCmd._colorized ? e.drawImage(f, 0, 0, h.width, h.height, k * b, p * d, s * b, m * d) : e.drawImage(f, h.renderX, h.renderY, h.width, h.height, k * b, p * d, s * b, m * d);
			a.restore();
			cc.g_NumberOfDraws++
		}
	};
	a.releaseData = function() {};
	a.initCmd = function() {};
	a._updateProgress = function() {
		var a = this._node,
			b = a._sprite,
			d = b.width,
			e = b.height,
			f = a._midPoint;
		if(a._type === cc.ProgressTimer.TYPE_RADIAL) {
			this._radius = Math.round(Math.sqrt(d * d + e * e));
			var g, h = !1,
				k = this._origin;
			k.x = d * f.x;
			k.y = -e * f.y;
			a._reverseDirection ? (g = 270, f = 270 - 3.6 * a._percentage) : (f = -90, g = -90 + 3.6 * a._percentage);
			b._flippedX && (k.x -= 2 * d * a._midPoint.x, f = -f - 180, g = -g - 180, h = !h);
			b._flippedY && (k.y += 2 * e * a._midPoint.y, h = !h, f = -f, g = -g);
			this._startAngle = f;
			this._endAngle = g;
			this._counterClockWise = h
		} else h = a._barChangeRate,
			k = a._percentage / 100, a = this._barRect, h = cc.size(d * (1 - h.x), e * (1 - h.y)), k = cc.size((d - h.width) * k, (e - h.height) * k), h = cc.size(h.width + k.width, h.height + k.height), g = cc.p(d * f.x, e * f.y), k = g.x - h.width / 2, 0.5 < f.x && h.width / 2 >= d - g.x && (k = d - h.width), d = g.y - h.height / 2, 0.5 < f.y && h.height / 2 >= e - g.y && (d = e - h.height), a.x = 0, e = 1, b._flippedX && (a.x -= h.width, e = -1), 0 < k && (a.x += k * e), a.y = 0, e = 1, b._flippedY && (a.y += h.height, e = -1), 0 < d && (a.y -= d * e), a.width = h.width, a.height = -h.height
	};
	a._updateColor = function() {};
	a._syncStatus = function(a) {
		var b =
			this._node;
		if(b._sprite) {
			var d = cc.Node._dirtyFlags,
				e = this._dirtyFlag,
				f = a ? a._node : null;
			f && f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty && (e |= d.colorDirty);
			f && f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty && (e |= d.opacityDirty);
			a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
			this._dirtyFlag = e;
			var b = b._sprite._renderCmd,
				g = b._dirtyFlag,
				f = g & d.colorDirty,
				g = g & d.opacityDirty;
			f && b._syncDisplayColor();
			g && b._syncDisplayOpacity();
			(f || g) && b._updateColor();
			e & d.transformDirty && this.transform(a)
		}
	};
	a.updateStatus = function() {
		var a = this._node;
		if(a._sprite) {
			var b = cc.Node._dirtyFlags,
				d = this._dirtyFlag,
				a = a._sprite._renderCmd,
				e = a._dirtyFlag,
				f = e & b.colorDirty,
				e = e & b.opacityDirty;
			f && a._updateDisplayColor();
			e && a._updateDisplayOpacity();
			(f || e) && a._updateColor();
			d & b.transformDirty && this.transform(this.getParentRenderCmd(), !0);
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.ProgressTimer.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._vertexWebGLBuffer = cc._renderContext.createBuffer();
		this._vertexDataCount = 0;
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataDirty = !1
	};
	var a = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.ProgressTimer.WebGLRenderCmd;
	a.rendering = function(a) {
		var b = this._node;
		a = a || cc._renderContext;
		if(this._vertexData && b._sprite) {
			this._shaderProgram.use();
			this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
			var d = b._sprite._blendFunc;
			cc.glBlendFunc(d.src, d.dst);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			cc.glBindTexture2D(b._sprite.texture);
			a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
			this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1);
			d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, d, 0);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
				4, a.UNSIGNED_BYTE, !0, d, 8);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, d, 12);
			b._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : b._type === cc.ProgressTimer.TYPE_BAR && (b._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
			cc.g_NumberOfDraws++
		}
	};
	a._syncStatus = function(a) {
		var b = this._node;
		if(b._sprite) {
			var d = cc.Node._dirtyFlags,
				e = this._dirtyFlag,
				f = a ? a._node : null;
			f && f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty && (e |= d.colorDirty);
			f && f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty && (e |= d.opacityDirty);
			a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
			this._dirtyFlag = e;
			b = b._sprite._renderCmd;
			f = b._dirtyFlag;
			e = f & d.colorDirty;
			d = f & d.opacityDirty;
			e && b._syncDisplayColor();
			d && b._syncDisplayOpacity();
			if(e || d) b._updateColor(), this._updateColor();
			this.transform(a);
			b._dirtyFlag =
				0
		}
	};
	a.updateStatus = function() {
		var a = this._node;
		if(a._sprite) {
			var b = cc.Node._dirtyFlags,
				d = this._dirtyFlag,
				a = a._sprite._renderCmd,
				e = a._dirtyFlag,
				f = e & b.colorDirty,
				e = e & b.opacityDirty;
			f && (a._updateDisplayColor(), this._dirtyFlag ^= this._dirtyFlag & b.colorDirty);
			e && (a._updateDisplayOpacity(), this._dirtyFlag ^= this._dirtyFlag & b.opacityDirty);
			if(f || e) a._updateColor(), this._updateColor();
			d & b.transformDirty && this.transform(this.getParentRenderCmd(), !0)
		}
	};
	a.releaseData = function() {
		this._vertexData && (this._vertexArrayBuffer =
			this._vertexData = null, this._vertexDataCount = 0)
	};
	a.initCmd = function() {
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataCount = 0;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a._updateProgress = function() {
		var a = this._node._type;
		a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
		this._vertexDataDirty = !0
	};
	a._updateBar = function() {
		var a = this._node;
		if(a._sprite) {
			var b, d = a._percentage / 100;
			b = a._barChangeRate;
			b = cc.pMult(cc.p(1 - b.x + d * b.x, 1 - b.y + d * b.y), 0.5);
			d = cc.pSub(a._midPoint, b);
			a = cc.pAdd(a._midPoint, b);
			0 > d.x && (a.x += -d.x, d.x = 0);
			1 < a.x && (d.x -= a.x - 1, a.x = 1);
			0 > d.y && (a.y += -d.y, d.y = 0);
			1 < a.y && (d.y -= a.y - 1, a.y = 1);
			if(this._reverseDirection) {
				if(!this._vertexData) {
					this._vertexDataCount = 8;
					var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
					this._vertexArrayBuffer = new ArrayBuffer(8 * e);
					var f = [];
					for(b = 0; 8 > b; b++) f[b] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, b * e);
					f[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0,
						1));
					f[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
					f[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
					f[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
					f[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
					f[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
					f[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
					f[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
					this._vertexData = f
				}
				b = this._vertexData;
				b[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
				b[2].vertices =
					this._vertexFromAlphaPoint(cc.p(d.x, a.y));
				b[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
				b[3].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
				b[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
				b[4].vertices = this._vertexFromAlphaPoint(cc.p(a.x, a.y));
				b[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
				b[5].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
			} else {
				if(!this._vertexData)
					for(this._vertexDataCount = 4, e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer =
						new ArrayBuffer(4 * e), this._vertexData = [], b = 0; 4 > b; b++) this._vertexData[b] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, b * e);
				b = this._vertexData;
				b[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
				b[0].vertices = this._vertexFromAlphaPoint(cc.p(d.x, a.y));
				b[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
				b[1].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
				b[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
				b[2].vertices = this._vertexFromAlphaPoint(cc.p(a.x,
					a.y));
				b[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
				b[3].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
			}
			this._updateColor()
		}
	};
	a._updateRadial = function() {
		var a = this._node;
		if(a._sprite) {
			var b, d = a._midPoint;
			b = a._percentage / 100;
			var e = 2 * cc.PI * (a._reverseDirection ? b : 1 - b),
				a = cc.p(d.x, 1),
				f = cc.pRotateByAngle(a, d, e),
				e = 0;
			if(0 === b) f = a, e = 0;
			else if(1 === b) f = a, e = 4;
			else {
				var g = cc.FLT_MAX,
					h = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
				for(b = 0; b <= h; ++b) {
					var k = (b + (h - 1)) % h,
						m = this._boundaryTexCoord(b % h),
						k =
						this._boundaryTexCoord(k);
					0 === b ? k = cc.pLerp(m, k, 1 - d.x) : 4 === b && (m = cc.pLerp(m, k, 1 - d.x));
					var n = cc.p(0, 0);
					cc.pLineIntersect(m, k, d, f, n) && (0 !== b && 4 !== b || 0 <= n.x && 1 >= n.x) && 0 <= n.y && n.y < g && (g = n.y, e = b)
				}
				f = cc.pAdd(d, cc.pMult(cc.pSub(f, d), g))
			}
			g = !0;
			this._vertexDataCount !== e + 3 && (g = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
			if(!this._vertexData) {
				h = this._vertexDataCount = e + 3;
				m = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
				this._vertexArrayBuffer = new ArrayBuffer(h * m);
				k = [];
				for(b = 0; b < h; b++) k[b] = new cc.V2F_C4B_T2F(null,
					null, null, this._vertexArrayBuffer, b * m);
				this._vertexData = k;
				if(!this._vertexData) {
					cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
					return
				}
			}
			this._updateColor();
			h = this._vertexData;
			if(!g)
				for(h[0].texCoords = this._textureCoordFromAlphaPoint(d), h[0].vertices = this._vertexFromAlphaPoint(d), h[1].texCoords = this._textureCoordFromAlphaPoint(a), h[1].vertices = this._vertexFromAlphaPoint(a), b = 0; b < e; b++) d = this._boundaryTexCoord(b), h[b + 2].texCoords = this._textureCoordFromAlphaPoint(d), h[b + 2].vertices = this._vertexFromAlphaPoint(d);
			h[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(f);
			h[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(f)
		}
	};
	a._boundaryTexCoord = function(a) {
		if(a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
			var b = cc.ProgressTimer.TEXTURE_COORDS;
			return this._node._reverseDirection ? cc.p(b >> 7 - (a << 1) & 1, b >> 7 - ((a << 1) + 1) & 1) : cc.p(b >> (a << 1) + 1 & 1, b >> (a << 1) & 1)
		}
		return cc.p(0, 0)
	};
	a._textureCoordFromAlphaPoint = function(a) {
		var b = this._node._sprite;
		if(!b) return {
			u: 0,
			v: 0
		};
		var d = b.quad,
			e = cc.p(d.bl.texCoords.u,
				d.bl.texCoords.v),
			d = cc.p(d.tr.texCoords.u, d.tr.texCoords.v);
		b.textureRectRotated && (b = a.x, a.x = a.y, a.y = b);
		return {
			u: e.x * (1 - a.x) + d.x * a.x,
			v: e.y * (1 - a.y) + d.y * a.y
		}
	};
	a._vertexFromAlphaPoint = function(a) {
		var b = this._node._sprite;
		if(!b) return {
			x: 0,
			y: 0
		};
		var d = b.quad,
			b = cc.p(d.bl.vertices.x, d.bl.vertices.y),
			d = cc.p(d.tr.vertices.x, d.tr.vertices.y);
		return {
			x: b.x * (1 - a.x) + d.x * a.x,
			y: b.y * (1 - a.y) + d.y * a.y
		}
	};
	a._updateColor = function() {
		var a = this._node;
		if(a._sprite && this._vertexData) {
			for(var a = a._sprite.quad.tl.colors, b = this._vertexData,
					d = 0, e = this._vertexDataCount; d < e; ++d) b[d].colors = a;
			this._vertexDataDirty = !0
		}
	}
})();
var res = {
		bg_png: "res/BJ.png",
		ui_png: "res/ui.png",
		ui_plist: "res/ui.plist",
		ui2_png: "res/ui2.png",
		ui2_plist: "res/ui2.plist",
		help_png: "res/help.png",
		bg_mp3: "res/bmg.mp3",
		catch_mp3: "res/catch.mp3"
	},
	g_resources = [];
for(i in res) g_resources.push(res[i]);
var GC = GC || {};
GC.GAME_STATE = {
	PLAY: 1,
	OVER: 2
};
GC.CONTAINER = {
	OBSTACLE: [],
	GOLDCONTAINER: []
};
var GameSceneLayer = cc.Layer.extend({
		face: null,
		hand: null,
		state: "wait",
		goldArray: null,
		tryTimes: 0,
		ctor: function() {
			this._super();
			this.tryTimes = 0;
			cc.spriteFrameCache.addSpriteFrames(res.ui_plist);
			cc.spriteFrameCache.addSpriteFrames(res.ui2_plist);
			Gold.preset(this);
			this.goldArray = [];
			GameSceneLayer.instance = this;
			GC.CONTAINER.GOLDCONTAINER = [];
			var a = new cc.Sprite(res.bg_png);
			this.addChild(a);
			a.setAnchorPoint(0.5, 0);
			a.setPosition(cc.p(cc.winSize.width / 2, 0));
			a = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("tou.png"));
			this.addChild(a);
			a.setAnchorPoint(cc.p(0.5, 1));
			a.setPosition(cc.winSize.width / 2, cc.winSize.height);
			this.face = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("smile.png"));
			this.addChild(this.face);
			this.face.setAnchorPoint(cc.p(0.5, 1));
			this.face.setPosition(cc.p(cc.winSize.width / 2, cc.winSize.height - 20));
			this.hand = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("hand3.png"));
			this.hand.setPosition(cc.p(0, cc.winSize.height / 1136 * 200));
			this.hand.setRotation(-25);
			this.hand.setAnchorPoint(cc.p(0.9, 0.5));
			this.hand.setLocalZOrder(10);
			this.addChild(this.hand);
			if(isFirst) {
				isFirst = !1;
				var c = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("LOGO_1.png"));
				this.addChild(c);
				this.setAnchorPoint(cc.p(0.5, 1));
				c.setPosition(cc.p(cc.winSize.width / 2, cc.winSize.height / 2 - 260));
				c.setOpacity(0);
				c.setScale(0);
				c.runAction(cc.sequence(cc.spawn(cc.fadeIn(0.5), cc.scaleTo(0.5, 1, 1).easing(cc.easeBounceOut()))));
				var b = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("num2.png"));
				this.addChild(b);
				b.setAnchorPoint(cc.p(0, 1));
				b.setPosition(cc.winSize.width, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80);
				b.setOpacity(0);
				1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width ? (b.y += 80, a = cc.sequence(cc.delayTime(0.6), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 - 180, 80 + cc.winSize.height / 2 - cc.winSize.height / 1136 * 70)).easing(cc.easeBounceOut())))) : a = cc.sequence(cc.delayTime(0.6), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 - 180, cc.winSize.height / 2 -
					cc.winSize.height / 1136 * 80)).easing(cc.easeBounceOut())));
				b.runAction(a);
				var d = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("num0.png"));
				this.addChild(d);
				d.setAnchorPoint(cc.p(0, 1));
				d.setPosition(cc.winSize.width, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80);
				d.setOpacity(0);
				1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width ? (d.y += 80, a = cc.sequence(cc.delayTime(1.2), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 - 83, 80 + cc.winSize.height / 2 - cc.winSize.height /
					1136 * 70)).easing(cc.easeBounceOut())))) : a = cc.sequence(cc.delayTime(1.2), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 - 83, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80)).easing(cc.easeBounceOut())));
				d.runAction(a);
				var e = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("num1.png"));
				this.addChild(e);
				e.setAnchorPoint(cc.p(0, 1));
				e.setPosition(cc.winSize.width, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80);
				e.setOpacity(0);
				1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width ?
					(e.y += 80, a = cc.sequence(cc.delayTime(1.8), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 + 23, 80 + cc.winSize.height / 2 - cc.winSize.height / 1136 * 70)).easing(cc.easeBounceOut())))) : a = cc.sequence(cc.delayTime(1.8), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 + 23, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80)).easing(cc.easeBounceOut())));
				e.runAction(a);
				var f = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("num6.png"));
				this.addChild(f);
				f.setAnchorPoint(cc.p(0,
					1));
				f.setPosition(cc.winSize.width, cc.winSize.height / 2 - cc.winSize.height / 1136 * 80);
				f.setOpacity(0);
				1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width ? (f.y += 80, a = cc.sequence(cc.delayTime(2.4), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 + 102, 80 + cc.winSize.height / 2 - cc.winSize.height / 1136 * 70)).easing(cc.easeBounceOut())))) : a = cc.sequence(cc.delayTime(2.4), cc.spawn(cc.fadeIn(0.8), cc.rotateBy(0.8, 360), cc.moveTo(1, cc.p(cc.winSize.width / 2 + 102, cc.winSize.height /
					2 - cc.winSize.height / 1136 * 80)).easing(cc.easeBounceOut())));
				f.runAction(a);
				var g = new cc.MenuItemImage(cc.spriteFrameCache.getSpriteFrame("shishi.png"), cc.spriteFrameCache.getSpriteFrame("shishi.png"), function() {
					cc.audioEngine.playMusic(res.bg_mp3, !0);
					this.logoAction(c, b, d, e, f);
					h.removeFromParent();
					var a = new HelpLayer;
					this.addChild(a, 100);
					this.addTouchEventListenser()
				}, this);
				g.attr({
					x: cc.winSize.width / 2,
					y: cc.winSize.height / 1136 * 190,
					anchorX: 0.5,
					anchorY: 0.5
				});
				g.setOpacity(0);
				g.setScale(0.75);
				var h = new cc.Menu(g);
				h.x = 0;
				h.y = 0;
				this.addChild(h, 1);
				g.runAction(cc.sequence(cc.delayTime(3.2), cc.fadeIn(0.5), cc.callFunc(function() {
					g.runAction(cc.repeatForever(cc.sequence(cc.scaleTo(0.8, 0.7), cc.scaleTo(0.8, 0.75))))
				}.bind(this))));
				1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width ? (this.face.setScale(0.7), b.setScale(0.7), d.setScale(0.7), e.setScale(0.7), f.setScale(0.7), g.setScale(0.7), c.y += 130, g.setPosition(g.x, g.y + 50)) : this.face.setScale(0.8)
			} else this.addTouchEventListenser(), this.schedule(this.addTarget,
				1), this.schedule(this.updateCollision, 0.05)
		},
		addTouchEventListenser: function() {
			var a = this;
			this.touchListener = cc.EventListener.create({
				event: cc.EventListener.TOUCH_ONE_BY_ONE,
				swallowTouches: !0,
				onTouchBegan: function(c, b) {
					"wait" == a.state && (a.tryTimes++, a.move())
				}
			});
			cc.eventManager.addListener(this.touchListener, this)
		},
		move: function() {
			this.state = "run";
			var a = new cc.MoveTo(0.3, cc.p(640, cc.winSize.height / 1136 * 480)),
				c = new cc.MoveTo(0.3, cc.p(0, cc.winSize.height / 1136 * 200));
			this.hand.runAction(cc.sequence(a,
				cc.callFunc(function() {
					this.cryAction()
				}.bind(this)), cc.delayTime(0.2), c, cc.callFunc(function() {
					this.smileAction()
				}.bind(this)), cc.callFunc(function() {
					this.state = "wait"
				}.bind(this))))
		},
		addTarget: function() {
			var a = Math.round(Math.random() * (cc.winSize.width - 100)) + 100,
				c = Math.round(300 * Math.random()) + 100,
				b = Gold.getOrCreateGround(a, cc.winSize.height + c, this);
			this.goldArray.push(b);
			var d = cc.moveTo(3, cc.p(a, cc.winSize.height / 1136 * 50)),
				a = Math.round(3 * Math.random()),
				e;
			0 == a ? e = 100 : 1 == a ? e = 200 : 2 == a ? e = 300 : 3 == a &&
				(e = 400);
			setTimeout(function() {
				b.runAction(cc.sequence(d, cc.callFunc(function() {})))
			}, e)
		},
		updateCollision: function() {
			for(var a = this, c = null, b = cc.rect(this.hand.getPositionX() - 10, this.hand.getPositionY() - 10, 40, 40), d = 0; d < this.goldArray.length; d++)
				if(c = this.goldArray[d], 100 >= c.y) {
					c.stopAllActions();
					var e = c.x,
						f = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("pia.png"));
					this.addChild(f);
					f.setPosition(cc.p(e, 90));
					f.runAction(cc.fadeOut(0.2));
					c.destroy();
					GC.CONTAINER.GOLDCONTAINER.push(c);
					a.goldArray.splice(d,
						1);
					d--
				} else e = cc.rect(c.getPositionX(), c.getPositionY(), 100, 100), cc.rectIntersectsRect(b, e) && (isAndroid() || (cc.audioEngine.stopMusic(res.bg_mp3), cc.audioEngine.playEffect(res.catch_mp3)), c.stopAllActions(), c.setPosition(this.hand.x, this.hand.y + 50), this.unschedule(this.updateCollision), this.unschedule(this.addTarget), this.happyAction(), setTimeout(function() {
					a.gameOver()
				}, 500))
		},
		happyAction: function() {
			this.face.setSpriteFrame(cc.spriteFrameCache.getSpriteFrame("happy.png"));
			this.hand.stopAllActions();
			this.hand.setSpriteFrame(cc.spriteFrameCache.getSpriteFrame("hand1.png"))
		},
		smileAction: function() {
			this.face.setSpriteFrame(cc.spriteFrameCache.getSpriteFrame("smile.png"))
		},
		cryAction: function() {
			this.face.setSpriteFrame(cc.spriteFrameCache.getSpriteFrame("cry.png"));
			this.hand.setSpriteFrame(cc.spriteFrameCache.getSpriteFrame("hand2.png"))
		},
		logoAction: function(a, c, b, d, e) {
			a.runAction(cc.sequence(cc.scaleTo(0.2, 1, 0), cc.callFunc(function() {
				a.removeFromParent()
			})));
			c.runAction(cc.sequence(cc.scaleTo(0.2,
				1, 0), cc.callFunc(function() {
				c.removeFromParent()
			})));
			b.runAction(cc.sequence(cc.scaleTo(0.2, 1, 0), cc.callFunc(function() {
				b.removeFromParent()
			})));
			d.runAction(cc.sequence(cc.scaleTo(0.2, 1, 0), cc.callFunc(function() {
				d.removeFromParent()
			})));
			e.runAction(cc.sequence(cc.scaleTo(0.2, 1, 0), cc.callFunc(function() {
				e.removeFromParent()
			})))
		},
		gameOver: function() {
			var a = new GameOverLayer(this.tryTimes);
			this.addChild(a, 100)
		}
	}),
	GameScene = cc.Scene.extend({
		onEnter: function() {
			this._super();
			var a = new GameSceneLayer;
			this.addChild(a,
				1)
		}
	});
var Gold = cc.Sprite.extend({
	active: !0,
	ctor: function() {
		this._super(cc.spriteFrameCache.getSpriteFrame("gold.png"))
	},
	reset: function(a, c) {
		this.attr({
			x: a,
			y: c
		})
	},
	destroy: function(a, c, b) {
		this.active = this.visible = !1
	},
	activation: function() {
		this.active = this.visible = !0
	}
});
Gold.getOrCreateGround = function(a, c, b) {
	for(var d = null, e = 0; e < GC.CONTAINER.GOLDCONTAINER.length; e++)
		if(d = GC.CONTAINER.GOLDCONTAINER[e], !1 == d.active) return console.log("getOrCreate"), d.activation(), d.reset(a, c), GC.CONTAINER.GOLDCONTAINER.splice(e, 1), d;
	d = Gold.create(b);
	d.reset(a, c);
	console.log("create");
	return d
};
Gold.create = function(a) {
	var c = new Gold;
	a.addChild(c, 1);
	return c
};
Gold.preset = function(a) {
	for(var c = null, b = 0; 4 > b; b++) c = Gold.create(a), console.log(c), c.destroy(), GC.CONTAINER.GOLDCONTAINER.push(c)
};
var GameOverLayer = cc.LayerColor.extend({
	m_touchListener: null,
	isTouched: !0,
	ctor: function(a) {
		this._super(cc.color(0, 0, 0));
		GameOverLayer.instance = this;
		this.setOpacity(178);
		var c = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("ban.png"));
		this.addChild(c);
		c.setPosition(cc.p(cc.winSize.width / 2, cc.winSize.height / 2 + 150));
		var b = Math.round(Math.random() * (Level.level.length - 1)),
			b = Level.level[b].str;
		setShare("\u6211\u662f" + NoToChinese(a) + "\u628a\u6293\u798f\uff01" + b);
		a = new cc.LabelTTF(b, "arial", "30", cc.size(450,
			400), cc.TEXT_ALIGNMENT_CENTER);
		a.setColor(cc.color(0, 0, 0));
		c.addChild(a);
		a.setPosition(c.width / 2, c.height / 2 - 250);
		a = new cc.MenuItemImage(cc.spriteFrameCache.getSpriteFrame("restart1.png"), cc.spriteFrameCache.getSpriteFrame("restart2.png"), function() {
			isAndroid() || cc.audioEngine.playMusic(res.bg_mp3);
			this.resetGame()
		}, this);
		a.attr({
			x: c.width / 2 - 150,
			y: -90,
			anchorX: 0.5,
			anchorY: 0.5
		});
		a = new cc.Menu(a);
		a.x = 0;
		a.y = 0;
		c.addChild(a, 1);
		a = new cc.MenuItemImage(cc.spriteFrameCache.getSpriteFrame("qfshare1.png"), cc.spriteFrameCache.getSpriteFrame("qfshare2.png"),
			function() {
				this.isTouched && (this.isTouched = !1, this.shareGame())
			}, this);
		a.attr({
			x: c.width / 2 + 150,
			y: -90,
			anchorX: 0.5,
			anchorY: 0.5
		});
		a = new cc.Menu(a);
		a.x = 0;
		a.y = 0;
		c.addChild(a, 1);
		c = {
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this.onTouchBegan
		};
		cc.eventManager.addListener(c, this);
		this.m_touchListener = c
	},
	resetGame: function() {
		cc.director.runScene(new GameScene)
	},
	shareGame: function() {
		var a = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("sharetitle.png"));
		GameOverLayer.instance.addChild(a);
		a.setAnchorPoint(cc.p(1, 1));
		a.setPosition(cc.p(cc.winSize.width - 10, cc.winSize.height - 10))
	},
	onTouchBegan: function(a, c) {
		c.getCurrentTarget();
		return !0
	}
});
var HelpLayer = cc.LayerColor.extend({
	m_touchListener: null,
	isTouched: !1,
	gameLayer: null,
	ctor: function() {
		this._super(cc.color(0, 0, 0));
		this.setOpacity(178);
		var a = new cc.Sprite(res.help_png);
		this.addChild(a);
		a.setPosition(cc.p(cc.winSize.width / 2, cc.winSize.height / 2 + 50));
		var c = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("bianxian.png"));
		this.addChild(c);
		c.setPosition(cc.winSize.width / 2, cc.winSize.height / 1136 * 320);
		c.setRotation(-10);
		c = {
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this.onTouchBegan
		};
		cc.eventManager.addListener(c, this);
		this.m_touchListener = c;
		1.5 >= cc.view.getFrameSize().height / cc.view.getFrameSize().width && a.setScale(1)
	},
	onTouchBegan: function(a, c) {
		c.getCurrentTarget().removeFromParent();
		GameSceneLayer.instance.addTarget();
		GameSceneLayer.instance.schedule(GameSceneLayer.instance.addTarget, 1);
		GameSceneLayer.instance.schedule(GameSceneLayer.instance.updateCollision, 0.1);
		return !0
	}
});
var Level = {
	level: [{
		str: "\u7334\u5e74\u5230\u6765\u5f00\u5fc3\u7b11\uff0c\u5409\u7334\u5982\u610f\u7965\u745e\u7167\u3002\u4e8b\u4e1a\u5982\u7334\u84ec\u52c3\u8d77\uff0c\u5de5\u4f5c\u4f3c\u7334\u6b22\u5feb\u8df3\u3002\u5bb6\u5ead\u7f8e\u6ee1\u7334\u5149\u8000\uff0c\u7236\u6bcd\u5b89\u5eb7\u59bb\u513f\u5a07\u3002\u4e09\u4e16\u540c\u5802\u559c\u6d0b\u6d0b\uff0c\u5bb6\u5ead\u548c\u7766\u5e78\u798f\u8000\u3002\u613f\u4f60\u7334\u5e74\u8eab\u4f53\u5eb7\uff0c\u6ee1\u9762\u7334\u5149\u7b11\u707f\u70c2\uff01"
	}, {
		str: "\u6708\u4eae\u5347\u8d77\u8981\u4e00\u5929\uff0c\u5730\u7403\u516c\u8f6c\u8981\u4e00\u5e74\uff0c\u60f3\u4e00\u4e2a\u4eba\u8981\u4e8c\u5341\u56db\u5c0f\u65f6\uff0c\u7231\u4e00\u4e2a\u4eba\u8981\u4e00\u8f88\u5b50\uff0c\u4f46\u4e00\u53e5\u8d34\u5fc3\u795d\u798f\u53ea\u8981\u4e00\u79d2\uff1a\u7334\u5e74\u5feb\u4e50\uff01"
	}, {
		str: "\u6b22\u6b22\u559c\u559c\u8fce\u7334\u5e74\uff0c\u4e07\u4e8b\u5982\u610f\u5e73\u5b89\u5e74\uff0c\u626c\u7709\u5410\u6c14\u987a\u5fc3\u5e74\uff0c\u68a6\u60f3\u6210\u771f\u53d1\u8d22\u5e74\uff0c\u4e8b\u4e1a\u8f89\u714c\u6210\u529f\u5e74\uff0c\u7855\u679c\u7d2f\u7d2f\u4e30\u6536\u5e74\u3002\u795d\u541b\u5c81\u5c81\u6709\u597d\u5e74\uff01"
	}, {
		str: "\u7334\u5e74\u5230\uff0c\u5feb\u4e50\u628a\u4f60\u9017\uff0c\u6b22\u559c\u8fde\u8fde;\u7f8e\u597d\u628a\u4f60\u5ba0\uff0c\u5e78\u798f\u65e0\u9650;\u5409\u7965\u628a\u4f60\u7ed5\uff0c\u597d\u8fd0\u65e0\u7a77;\u8d22\u6c14\u628a\u4f60\u718f\uff0c\u8d22\u8fd0\u4ea8\u901a;\u5e73\u5b89\u628a\u4f60\u4fdd\uff0c\u798f\u5bff\u7ef5\u7ef5;\u670b\u53cb\u5219\u628a\u4f60\u795d\u798f\uff0c\u60c5\u6df1\u8c0a\u539a\u3002\u795d\u7334\u5e74\u5f00\u6000\uff0c\u798f\u5bff\u5b89\u5eb7!"
	}, {
		str: "\u5409\u7965\u5e78\u798f\u65b0\u5e74\u597d\uff0c\u6b22\u5929\u559c\u5730\u7334\u513f\u8dd1\u3002\u5065\u5eb7\u6765\u95ee\u5019\uff0c\u5feb\u4e50\u6765\u62e5\u62b1\u3002\u548c\u8c10\u6765\u793a\u597d\u3002\u57282016\u5e74\u65b0\u6625\u4f73\u8282\u6765\u4e34\u65f6,\u795d\u798f\u4f60\uff1a\u5c81\u5c81\u5e73\u5b89\uff0c\u8d22\u6e90\u6eda\u6eda\uff01"
	}, {
		str: "\u6211\u613f\uff1a\u65b0\u5e74\u7684\u7b2c\u4e00\u9897\u9732\u73e0\u56e0\u4f60\u800c\u7f8e\u4e3d\u6676\u83b9\uff0c\u65b0\u5e74\u7684\u7b2c\u4e00\u4e2a\u9ece\u660e\u56e0\u4f60\u800c\u60ec\u610f\u5b81\u9759\uff0c\u90a3\u65b0\u5e74\u7684\u7b2c\u4e00\u7f15\u9633\u5149\u56e0\u4f60\u800c\u6e29\u6696\u8212\u5fc3\u60c5\u3002\u8877\u5fc3\u795d\u613f\uff0c\u7334\u5e74\u5feb\u4e50\uff01"
	}, {
		str: "\u4e94\u5f69\u7f24\u7eb7\u6d41\u5149\u6ea2\uff0c\u7334\u5e74\u6625\u5149\u7f8e\u666f\u4e3d\u3002\u6b22\u5929\u559c\u5730\u94f6\u7334\u8df3\uff0c\u8d77\u821e\u5171\u8e48\u5531\u5927\u620f\u3002\u7f8e\u9152\u98d8\u9999\u670b\u53cb\u8385\uff0c\u5171\u540c\u5e72\u676f\u8bae\u5927\u4e8b\u3002\u643a\u624b\u7334\u5e74\u5efa\u5927\u4e1a\uff0c\u5fc3\u60f3\u4e8b\u6210\u521b\u4f73\u7ee9\u3002\u613f\u4f60\u9a6c\u4e0a\u5c01\u201c\u5019\u201d\u6b65\u6b65\u9ad8\uff01"
	}, {
		str: "\u7480\u74a8\u7684\u7fa4\u661f\u5728\u95ea\u8000\uff0c\u7334\u5e74\u7684\u6b22\u4e50\u5728\u821e\u8e48\u3002\u50b2\u971c\u7684\u814a\u6885\u8fce\u98ce\u7b11\uff0c\u7334\u5e74\u7684\u5e78\u798f\u6696\u5fc3\u6f6e\u3002\u6e29\u6696\u7684\u9633\u5149\u6765\u76f8\u7167\uff0c\u7334\u5e74\u7684\u795d\u798f\u4e0d\u80fd\u5c11\u3002\u613f\u4f60\u7334\u5e74\u4e50\u6dd8\u6dd8\uff0c\u4e8b\u4e1a\u521b\u65b0\u9ad8\uff01"
	}, {
		str: "\u7334\u5e74\u5230\uff0c\u597d\u8fd0\u5230\u3002\u5e78\u798f\u56f4\u4f60\u7ed5\uff0c\u5065\u5eb7\u5bf9\u4f60\u628a\u624b\u62db\uff0c\u5e73\u5b89\u5bf9\u4f60\u9732\u5fae\u7b11\uff0c\u5409\u661f\u628a\u4f60\u7167\uff0c\u8d22\u795e\u7275\u7740\u4f60\u8dd1\uff0c\u6240\u6709\u597d\u4e8b\u90fd\u6765\u5230\uff0c\u795d\u4f60\u5728\u65b0\u7684\u4e00\u5e74\u91cc\u5e78\u798f\u4e50\u900d\u9065\uff01"
	}, {
		str: "\u795d\u4f60\u7334\u5e74\u559c\u6c14\u6d0b\u6d0b\uff0c\u6ee1\u9762\u9633\u5149\u707f\u70c2\uff0c\u7231\u60c5\u626c\u7709\u5410\u6c14\uff0c\u4e8b\u4e1a\u6d0b\u6d0b\u5f97\u610f\uff0c\u6666\u6c14\u626c\u957f\u800c\u53bb\uff0c\u4e07\u4e8b\u9633\u5173\u5927\u9053\uff0c\u7334\u5e74\u4e00\u65fa\u5411\u524d\uff01"
	}, {
		str: "\u7334\u5e74\u5230\u6765\u5f00\u5fc3\u7b11\uff0c\u5409\u7334\u5982\u610f\u7965\u745e\u7167\u3002\u4e8b\u4e1a\u5982\u7334\u84ec\u52c3\u8d77\uff0c\u5de5\u4f5c\u4f3c\u7334\u6b22\u5feb\u8df3\u3002\u5bb6\u5ead\u7f8e\u6ee1\u7334\u5149\u8000\uff0c\u7236\u6bcd\u5b89\u5eb7\u59bb\u513f\u5a07\u3002\u4e09\u4e16\u540c\u5802\u559c\u6d0b\u6d0b\uff0c\u5bb6\u5ead\u548c\u7766\u5e78\u798f\u8000\u3002\u613f\u4f60\u7334\u5e74\u8eab\u4f53\u5eb7\uff0c\u6ee1\u9762\u7334\u5149\u7b11\u707f\u70c2\uff01"
	}, {
		str: "\u4e00\u53ea\u5409\u7334\u5230\u4eba\u95f4\uff0c\u4e24\u773c\u653e\u5149\u62dc\u65b0\u5e74\uff0c\u4e09\u751f\u6709\u5e78\u505a\u670b\u53cb\uff0c\u56db\u5b63\u5e73\u5b89\u5feb\u4e50\u884c\uff0c\u4e94\u8c37\u4e30\u767b\u519c\u5bb6\u4e50\uff0c\u516d\u755c\u5174\u65fa\u6c11\u5e78\u798f\uff0c\u4e03\u8001\u516b\u5341\u6021\u7136\u4e50\uff0c\u516b\u9762\u5a01\u98ce\u559c\u8fce\u6625,\u795d\u4f60\u7334\u5e74\u5927\u5409\uff01"
	}, {
		str: "\u4f60\u613f\uff0c\u6216\u8005\u4e0d\u613f\u610f\uff0c\u7f8a\u5e74\u90fd\u5c06\u8fc7\u53bb\u3002\u4f60\u60f3\u6216\u8005\u4e0d\u60f3\u7ecf\u5386\uff0c\u65b0\u7684\u7334\u5e74\u90fd\u5c06\u5230\u6765\u3002\u4f60\u4fe1\u6216\u8005\u4e0d\u4fe1\uff0c\u6211\u4eec\u7684\u751f\u6d3b\u5c06\u4f1a\u8d8a\u6765\u8d8a\u597d\u3002\u795d\u4f60\u4e07\u4e8b\u5982\u610f\uff0c\u7334\u5e74\u5409\u7965\uff01"
	}]
};
var isFirst = !0;
cc.game.onStart = function() {
	!cc.sys.isNative && document.getElementById("cocosLoading") && document.body.removeChild(document.getElementById("cocosLoading"));
	cc.view.enableRetina(!1);
	cc.view.enableAutoFullScreen(!1);
	cc.view.adjustViewPort(!0);
	cc.view.setDesignResolutionSize(640, 1136, cc.ResolutionPolicy.FIXED_WIDTH);
	cc.view.resizeWithBrowserSize(!0);
	cc.LoaderScene.preload(g_resources, function() {
		cc.director.runScene(new GameScene)
	}, this)
};
cc.game.run();